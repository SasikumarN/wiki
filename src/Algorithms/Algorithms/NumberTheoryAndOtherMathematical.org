#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: Number theory and Other Mathematical
#+OPTIONS: num:nil H:2


* Primality Test
** Optimized
1. Instead of checking till n, we can check till √n because a larger
   factor of n must be a multiple of smaller factor that has been
   already checked
2. The algorithm can be improved further by observing that all primes
   are of the form 6k ± 1, with the exception of 2 and 3. This is
   because all integers can be expressed as (6k + i) for some integer
   k and for i = -1, 0, 1, 2, 3, or 4; 2 divides (6k + 0), (6k + 2),
   (6k + 4); and 3 divides (6k + 3). So a more efficient method is to
   test if n is divisible by 2 or 3, then to check through all the
   numbers of form 6k ± 1.

#+begin_src c++
bool isPrime(int n) {
  if (n <= 1)  return false;
  if (n <= 3)  return true;
 
  if (n%2 == 0 || n%3 == 0) return false;
  for (int i = 5; i*i <= n; i = i+6) { 
    if (n%i == 0 || n%(i+2) == 0) {
      return false;
    }
  }
  return true;
}
#+end_src
** Fermat’s method
This method is a probabilistic method and is based on below [[https://en.wikipedia.org/wiki/Fermat's_little_theorem][Fermat’s
Little Theorem]].

#+begin_src sh
Fermat's Little Theorem:
If n is a prime number, then for every a, 1 <= a < n,

an-1 ≡ 1 (mod n)
 OR 
an-1 % n = 1 
 

Example: Since 5 is prime, 24 ≡ 1 (mod 5) [or 24%5 = 1],
         34 ≡ 1 (mod 5) and 44 ≡ 1 (mod 5) 

         Since 7 is prime, 26 ≡ 1 (mod 7),
         36 ≡ 1 (mod 7), 46 ≡ 1 (mod 7) 
         56 ≡ 1 (mod 7) and 66 ≡ 1 (mod 7) 
#+end_src

If a given number is prime, then this method always returns true. If
given number is composite (or non-prime), then it may return true or
false, but the probability of producing incorrect result for composite
is low and can be reduced by doing more iterations.

[[./Files/fermat_is_prime.cc]]

#+INCLUDE: "./Files/fermat_is_prime.cc" src c++
** Miller–Rabin[fn:1]
This method is a probabilistic method (Like Fermat), but it generally
preferred over Fermat’s method.
#+begin_src sh
// It returns false if n is composite and returns true if n
// is probably prime.  k is an input parameter that determines
// accuracy level. Higher value of k indicates more accuracy.
bool isPrime(int n, int k)
1) Handle base cases for n < 3
2) If n is even, return false.
3) Find an odd number d such that n-1 can be written as d*2r. 
   Note that since, n is odd (n-1) must be even and r must be 
   greater than 0.
4) Do following k times
     if (millerTest(n, d) == false)
          return false
5) Return true.

// This function is called for all k trials. It returns 
// false if n is composite and returns false if n is probably
// prime.  
// d is an odd number such that  d*2r = n-1 for some r >= 1
bool millerTest(int n, int d)
1) Pick a random number 'a' in range [2, n-2]
2) Compute: x = pow(a, d) % n
3) If x == 1 or x == n-1, return true.

// Below loop mainly runs 'r-1' times.
4) Do following while d doesn't become n-1.
     a) x = (x*x) % n.
     b) If (x == 1) return false.
     c) If (x == n-1) return true. 
#+end_src

Example:
#+begin_src sh
Input: n = 13,  k = 2.

1) Compute d and r such that d*2r = n-1, 
     d = 3, r = 2. 
2) Call millerTest k times.

1st Iteration:
1) Pick a random number 'a' in range [2, n-2]
      Suppose a = 4

2) Compute: x = pow(a, d) % n
     x = 43 % 13 = 12

3) Since x = (n-1), return true.

IInd Iteration:
1) Pick a random number 'a' in range [2, n-2]
      Suppose a = 5

2) Compute: x = pow(a, d) % n
     x = 53 % 13 = 8

3) x neither 1 nor 12.

4) Do following (r-1) = 1 times
   a) x = (x * x) % 13 = (8 * 8) % 13 = 12
   b) Since x = (n-1), return true.

Since both iterations return true, we return true.
#+end_src

[[./Files/miller-rabin_prime.cc]]

#+INCLUDE: "./Files/miller-rabin_prime.cc" src c++

* Sieve of Eratosthenes
Following is the algorithm to find all the prime numbers less than or equal to a given integer n by Eratosthenes’ method:

1. Create a list of consecutive integers from 2 to n: (2, 3, 4, …,
   n).
2. Initially, let p equal 2, the first prime number.
3. Starting from p, count up in increments of p and mark each of these
   numbers greater than p itself in the list. These numbers will be
   2p, 3p, 4p, etc.; note that some of them may have already been
   marked.

4. Find the first number greater than p in the list that is not
   marked. If there was no such number, stop. Otherwise, let p now
   equal this number (which is the next prime), and repeat from
   step 3.

[[./Files/sieve_of_eratosthenes.cc]]

#+INCLUDE: "./Files/sieve_of_eratosthenes.cc" src c++
* Wilson’s Theorem
Wilson’s theorem states that a natural number p > 1 is a prime number
if and only if

$(n-1)!\ \equiv\ -1 \pmod n$ .

但是由于阶乘是呈爆炸增长的，其结论对于实际操作意义不大。

* Pollard’s Rho Algorithm for Prime Factorization[fn:2]
Given a positive integer n, and that it is composite, find a divisor
of it.

*Simple approach*: Test all integers less than √n

A large enough number will still mean a great deal of work. Pollard’s
Rho is a prime factorization algorithm, particularly fast for a large
composite number with small prime factors. The Rho algorithm’s most
remarkable success was the factorization of eighth Fermat number:
1238926361552897 * 93461639715357977769163558199606896584051237541638188580280321.

*Algorithm:*

1. Start with random x and c. Take y equal to x and f(x) = x2 + c.
2. While a divisor isn’t obtained
   + Update x to f(x) (modulo n) [Tortoise Move]
   + Update y to f(f(y)) (modulo n) [Hare Move]
   + Calculate GCD of |x-y| and n
   + If GCD is not unity
     + If GCD is n, repeat from step 2 with another set of x, y and c
     + Else GCD is our answer

[[./Files/pollard_rho.cc]]

#+INCLUDE: "./Files/pollard_rho.cc" src c++
* Basic and Extended Euclidean algorithms
#+begin_src c++
  int gcd(int a, int b) {
    if (a == 0)
      return b;
    return gcd(b % a, a);
  }
#+end_src
** Extended Euclidean Algorithm
Extended Euclidean algorithm also finds integer coefficients x and y
such that:

#+begin_src sh
  ax + by = gcd(a, b)
#+end_src

#+begin_src sh
As seen above, x and y are results for inputs a and b,
   a.x + b.y = gcd                      ----(1)  

And x1 and y1 are results for inputs b%a and a
   (b%a).x1 + a.y1 = gcd   
                    
When we put b%a = (b - (⌊b/a⌋).a) in above, 
we get following. Note that ⌊b/a⌋ is floor(a/b)

   (b - (⌊b/a⌋).a).x1 + a.y1  = gcd

Above equation can also be written as below
   b.x1 + a.(y1 - (⌊b/a⌋).x1) = gcd      ---(2)

After comparing coefficients of 'a' and 'b' in (1) and 
(2), we get following
   x = y1 - ⌊b/a⌋ * x1
   y = x1
#+end_src

[[./Files/gcd_extended.cc]]

#+INCLUDE: "./Files/gcd_extended.cc" src c++

* Modular multiplicative inverse
Given two integers ‘a’ and ‘m’, find modular multiplicative
inverse of ‘a’ under modulo ‘m’.

The modular multiplicative inverse is an integer ‘x’ such that.
#+begin_src sh
 a x ≡ 1 (mod m)
#+end_src
The value of x should be in {0, 1, 2, … m-1},

The multiplicative inverse of “a modulo m” exists if and only if a
and m are relatively prime (i.e., if gcd(a, m) = 1).



* 不用除法和求模运算，判断一个数能否被3整除
** method1
这个数的每一个位上的数字加起来后，和为3的倍数。 
每个位相加，然后不断减去3,看结果是不是等于0
#+begin_src c
bool parse(unsigned int n)
{
    char buffer[1024];
    int i,length;
    int sum = 0;
    if(n < 10)
    {
        if(n == 0 || n == 3 || n == 6 || n == 9)
            return true;
        else
            return false;
    }
    sprintf(buffer,"%d",n);
    length = strlen(buffer);
    for(i = 0; i != length; i++)
        sum += buffer[i] - '0';
    return parse(sum);
}
#+end_src

** method2
3 = 0B11
如果a能被3整除，a=b×3,则a的最低位和b的最低位相同，a的次低位=b的次低位
+b的最低位，所以b的次低位=a的次低位-b的最低位，以此求出b。若不能则a不
能被3整出

#+begin_src c
        bool divideby3(int n)
        {
          int temp;
          if(n < 0)
            n = -n;
          while(n > 0){
            temp = n & 1;
            n >>= 1;
            n = n - temp;
          }
          return (n == 0);
        }
#+end_src

* BIT Manipulation
* cc
#+begin_src sh

#+end_src

+INCLUDE: "./Files/" src c++

* Footnotes

[fn:1] http://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/

[fn:2] http://www.geeksforgeeks.org/pollards-rho-algorithm-prime-factorization/

