#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: Graph Algorithms
#+OPTIONS: num:nil H:2


* Breadth First Traversal for a Graph
[[./Files/breadth-first-traversal.cc][breadth-first-traversal.cc]]

#+INCLUDE: "./Files/breadth-first-traversal.cc" src c++

* Depth First Traversal for a Graph
[[./Files/depth-first-traversal.cc][depth-first-traversal.cc]]

#+INCLUDE: "./Files/depth-first-traversal.cc" src c++
* Dijkstra’s shortest path algorithm
1) Create a set sptSet (shortest path tree set) that keeps track of
   vertices included in shortest path tree, i.e., whose minimum
   distance from source is calculated and finalized. Initially, this
   set is empty.
2) Assign a distance value to all vertices in the input graph.
   Initialize all distance values as INFINITE. Assign distance value
   as 0 for the source vertex so that it is picked first.
3) While sptSet doesn’t include all vertices
   a) Pick a vertex u which is not there in sptSetand has minimum
   distance value.
   b) Include u to sptSet.
   c) Update distance value of all adjacent vertices of u. To update
   the distance values, iterate through all adjacent vertices. For
   every adjacent vertex v, if sum of distance value of u (from
   source) and weight of edge u-v, is less than the distance value of
   v, then update the distance value of v.

[[./Files/dijkstra-shortest-path.cc][dijkstra-shortest-path.cc]]

#+INCLUDE: "./Files/dijkstra-shortest-path.cc" src c++

* Floyd Warshall Algorithm (All Pairs Shortest Path)
We initialize the solution matrix same as the input graph matrix as a
first step. Then we update the solution matrix by considering all
vertices as an intermediate vertex. The idea is to one by one pick all
vertices and update all shortest paths which include the picked vertex
as an intermediate vertex in the shortest path. When we pick vertex
number k as an intermediate vertex, we already have considered
vertices {0, 1, 2, .. k-1} as intermediate vertices. For every pair
(i, j) of source and destination vertices respectively, there are two
possible cases.

1) k is not an intermediate vertex in shortest path from i to j. We
   keep the value of dist[i][j] as it is.
2) k is an intermediate vertex in shortest path from i to j. We update
   the value of dist[i][j] as dist[i][k] + dist[k][j].

[[./Files/floyd-warshall-algorithm.cc][floyd-warshall-algorithm.cc]]

#+INCLUDE: "./Files/floyd-warshall-algorithm.cc" src c++

* Union-Find Algorithm(Detect Cycle in an Undirected Graph)
+ Find: Determine which subset a particular element is in. This can be
  used for determining if two elements are in the same subset.
+ Union: Join two subsets into a single subset.

[[./Files/union-find-algorithm.cc][union-find-algorithm.cc]]

#+INCLUDE: "./Files/union-find-algorithm.cc" src c++
* Kruskal’s Minimum Spanning Tree Algorithm
1. Sort all the edges in non-decreasing order of their weight.
2. Pick the smallest edge. Check if it forms a cycle with the spanning
   tree  formed so far. If cycle is not formed, include this edge.
   Else, discard it.  
3. Repeat step#2 until there are (V-1) edges in the spanning tree.

[[./Files/kruskal-min-spanning-tree.cc][kruskal-min-spanning-tree.cc]]

#+INCLUDE: "./Files/kruskal-min-spanning-tree.cc" src c++

* Prim’s Minimum Spanning Tree
1) Create a set mstSet that keeps track of vertices already included
   in MST.
2) Assign a key value to all vertices in the input graph. Initialize
   all key values as INFINITE. Assign key value as 0 for the first
   vertex so that it is picked first.
3) While mstSet doesn’t include all vertices
   a) Pick a vertex u which is not there in mstSet and has minimum key
   value.
   b) Include u to mstSet.
   c) Update key value of all adjacent vertices of u. To update the
   key values, iterate through all adjacent vertices. For every
   adjacent vertex v, if weight of edge u-v is less than the previous
   key value of v, update the key value as weight of u-v

[[./Files/prim-min-spanning-tree.cc][prim-min-spanning-tree.cc]]

#+INCLUDE: "./Files/prim-min-spanning-tree.cc" src c++

* Topological Sorting
Topological sorting for Directed Acyclic Graph (DAG) is a linear
ordering of vertices such that for every directed edge uv, vertex u
comes before v in the ordering. Topological Sorting for a graph is not
possible if the graph is not a DAG.

[[./Files/topological-sorting.cc][topological-sorting.cc]]

#+INCLUDE: "./Files/topological-sorting.cc" src c++

* Articulation Points (or Cut Vertices) in a Graph
A O(V+E) algorithm to find all Articulation Points (APs)
The idea is to use DFS (Depth First Search). In DFS, we follow
vertices in tree form called DFS tree. In DFS tree, a vertex u is
parent of another vertex v, if v is discovered by u (obviously v is an
adjacent of u in graph). In DFS tree, a vertex u is articulation point
if one of the following two conditions is true.

1) u is root of DFS tree and it has at least two children.
2) u is not root of DFS tree and it has a child v such that no vertex
   in subtree rooted with v has a back edge to one of the ancestors
   (in DFS tree) of u.

We do DFS traversal of given graph with additional code to find out
Articulation Points (APs). In DFS traversal, we maintain a =parent[]=
array where =parent[u]= stores parent of vertex u. Among the above
mentioned two cases, the first case is simple to detect. For every
vertex, count children. If currently visited vertex u is root
(=parent[u]= is NIL) and has more than two children, print it.

How to handle second case? The second case is trickier. We maintain an
array =disc[]= to store discovery time of vertices. For every node u, we
need to find out the earliest visited vertex (the vertex with minimum
discovery time) that can be reached from subtree rooted with u. So we
maintain an additional array =low[]= which is defined as follows.

#+begin_src sh
low[u] = min(disc[u], disc[w]) 
where w is an ancestor of u and there is a back edge from 
some descendant of u to w.
#+end_src

[[./Files/articulation-points.cc][articulation-points.cc]]

#+INCLUDE: "./Files/articulation-points.cc" src c++

* Bridges in a graph
An edge in an undirected connected graph is a bridge iff removing it
disconnects the graph. For a disconnected undirected graph, definition
is similar, a bridge is an edge removing which increases number of
connected components.

A simple approach is to one by one remove all edges and see if removal
of a edge causes disconnected graph. Following are steps of simple
approach for connected graph.

1) For every edge (u, v), do following
   a) Remove (u, v) from graph
   b) See if the graph remains connected (We can either use BFS or
   DFS)
   c) Add (u, v) back to the graph.

Time complexity of above method is O(E*(V+E)) for a graph represented
using adjacency list.

*A O(V+E) algorithm to find all Bridges*
The idea is similar to O(V+E) algorithm for Articulation Points. We do
DFS traversal of the given graph. In DFS tree an edge(u, v) (u is
parent of v in DFS tree) is bridge if there does not exit any other
alternative to reach u or an ancestor of u from subtree rooted with v.
As discussed in the previous post, the value low[v] indicates earliest
visited vertex reachable from subtree rooted with v. The condition for
an edge(u, v) to be a bridge is, =low[v] > disc[u]=.

[[./Files/bridges-in-a-graph.cc][bridges-in-a-graph.cc]]

#+INCLUDE: "./Files/bridges-in-a-graph.cc" src c++

* Tarjan's strongly connected components algorithm
** Overview
[[https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm][Tarjan's algorithm]] is an algorithm in graph theory for finding the
strongly connected components of a graph. It runs in linear time,
matching the time bound for alternative methods including Kosaraju's
algorithm and the path-based strong component algorithm.
** The algorithm in pseudocode
#+begin_src sh
 algorithm tarjan is
  input: graph G = (V, E)
  output: set of strongly connected components (sets of vertices)

  index := 0
  S := empty
  for each v in V do
    if (v.index is undefined) then
      strongconnect(v)
    end if
  end for

  function strongconnect(v)
    // Set the depth index for v to the smallest unused index
    v.index := index
    v.lowlink := index
    index := index + 1
    S.push(v)
    v.onStack := true

    // Consider successors of v
    for each (v, w) in E do
      if (w.index is undefined) then
        // Successor w has not yet been visited; recurse on it
        strongconnect(w)
        v.lowlink  := min(v.lowlink, w.lowlink)
      else if (w.onStack) then
        // Successor w is in stack S and hence in the current SCC
        v.lowlink  := min(v.lowlink, w.index)
      end if
    end for

    // If v is a root node, pop the stack and generate an SCC
    if (v.lowlink = v.index) then
      start a new strongly connected component
      repeat
        w := S.pop()
        w.onStack := false
        add w to current strongly connected component
      while (w != v)
      output the current strongly connected component
    end if
  end function
#+end_src 
** Strong connectivity
In undirected graphs, two vertices are connected if they have a path
connecting them. How should we define connected in a directed graph?

We say that a vertex a is strongly connected to b if there exist two
paths, one from a to b and another from b to a.

Note that we allow the two paths to share vertices or even to share
edges. We will use a ~ b as shorthand for "a is strongly connected to
b". We will allow very short paths, with one vertex and no edges, so
that any vertex is strongly connected to itself.
** Strong connectivity algorithm[fn:1]
Define the DFS numbering dfsnum(v) to be the number of vertices
visited before v in the DFS. Then if there is a back or cross edge out
of the subtree of v, it's to something visited before v and therefore
with a smaller dfsnum. We use this by defining the low value low(v) to
be the smallest dfsnum of a vertex reachable by a back or cross edge
from the subtree of v. If there is no such edge, low(v)=dfsnum(v).
Then rephrasing what we've seen so far, v is a head of a component
exactly when low(v)=dfsnum(v). The advantage of using these
definitions is that dfsnum(v) is trivial to calculate as we perform
the DFS, and low(v) is easily computed by combining the low values
from the children of v with the values coming from back or cross edges
out of v itself.

We use one more simple data structure, a stack L (represented as a
list) which we use to identify the subtree rooted at a vertex. We
simply push each new vertex onto L as we visit it; then when we have
finished visiting a vertex, its subtree will be everything pushed
after it onto L. If v is a head, and we've already deleted the other
heads in that subtree, the remaining vertices left on L will be
exactly the component [v].

We are now ready to describe the actual algorithm. It simply performs
a DFS, keeping track of the low and dfsnum values defined above, using
them to identify heads of components, and when finding a head deleting
the whole component from the graph, using L to find the vertices of
the component.

** Algorithm in Python
[[./Files/tarjan_strongly_connected.py][tarjan strongly connected.py]]

#+INCLUDE: "./Files/tarjan_strongly_connected.py" src python
** More
+ [[https://gist.github.com/chadhutchins/1440602][Tarjan's strongly connected components algorithm in Javascript]]
+ [[https://github.com/bwesterb/py-tarjan][Python implementation of Tarjan's algorithm]]

* Ford-Fulkerson Algorithm for Maximum Flow Problem
Given a graph which represents a flow network where every edge has a
capacity. Also given two vertices source ‘s’ and sink ‘t’ in the
graph, find the maximum possible flow from s to t with following
constraints:
1) Flow on an edge doesn’t exceed the given capacity of the edge.
2) Incoming flow is equal to outgoing flow for every vertex except s
   and t.

[[./Files/ford-fulkerson.cc]]

#+INCLUDE: "./Files/ford-fulkerson.cc" src c++

* cc
#+begin_src c++

#+end_src

* Footnotes

[fn:1] http://www.ics.uci.edu/~eppstein/161/960220.html#sca



