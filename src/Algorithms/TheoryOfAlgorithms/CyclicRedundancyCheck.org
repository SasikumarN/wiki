#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: Cyclic redundancy check
#+OPTIONS: num:nil H:2


* Overview
Cyclic Redundancy Check循环冗余检验，是基于数据计算一组效验码，用于核
对数据传输过程中是否被更改或传输错误。
* The Basic Idea Behind CRC Algorithms
The basic idea of CRC algorithms is simply to treat the message as an
enormous binary number, to divide it by another fixed binary number,
and to make the remainder from this division the checksum. Upon
receipt of the message, the receiver can perform the same division and
compare the remainder with the "checksum" (transmitted remainder).
* Binary Arithmetic with No Carries
Adding two numbers in CRC arithmetic is the same as adding numbers in
ordinary binary arithmetic except there is no carry. This means that
each pair of corresponding bits determine the corresponding output bit
without reference to any other bit positions. For example:

#+begin_src sh
        10011011
       +11001010
        --------
        01010001
        --------
#+end_src
There are only four cases for each bit position:

#+begin_src sh
   0+0=0
   0+1=1
   1+0=1
   1+1=0  (no carry)
# Subtraction is identical:
        10011011
       -11001010
        --------
        01010001
        --------
#+end_src

In fact, both addition and subtraction in CRC arithmetic is equivalent
to the XOR operation, and the XOR operation is its own inverse. 

Here's a fully worked division:
#+begin_src sh
            1100001010
       _______________
10011 ) 11010110110000
        10011,,.,,....
        -----,,.,,....
         10011,.,,....
         10011,.,,....
         -----,.,,....
          00001.,,....
          00000.,,....
          -----.,,....
           00010,,....
           00000,,....
           -----,,....
            00101,....
            00000,....
            -----,....
             01011....
             00000....
             -----....
              10110...
              10011...
              -----...
               01010..
               00000..
               -----..
                10100.
                10011.
                -----.
                 01110
                 00000
                 -----
                  1110 = Remainder
#+end_src

Thus we see that CRC arithmetic is primarily about XORing particular
values at various shifting offsets.

* Choosing A Poly
Choosing a poly is somewhat of a black art and the reader is referred
to[fn:1] (p.130-132) which has a very clear discussion of this issue. 

Some popular polys are:

| name        | Polys                                            |        Hex |
|-------------+--------------------------------------------------+------------|
| CRC12       | x^12 + x^11 + x^3 + x^2 + x + 1                  |      0x80F |
| CRC16       | x^16 + x^15 + x^2 + 1                            |     0x8005 |
| CRC16-CCITT | x^16 + x^12 + x^5 + 1                            |     0x1021 |
| CRC32       | x^32 + x^26 + x^23 + x^22 + x^16 + x^12 +        | 0x04C11DB7 |
|             | x^11+ x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1 |            |

* A Straightforward CRC Implementation
#+begin_src sh
            3   2   1   0   Bits
          +---+---+---+---+
 Pop! <-- |   |   |   |   | <----- Augmented message
          +---+---+---+---+
       1    0   1   1   1   = The Poly
#+end_src
To perform the division perform the following:

#+begin_src sh
   Load the register with zero bits.
   Augment the message by appending W zero bits to the end of it.
   While (more message bits)
      Begin
      Shift the register left by one bit, reading the next bit of the
         augmented message into register bit position 0.
      If (a 1 bit popped out of the register during step 3)
         Register = Register XOR Poly.
      End
   The register now contains the remainder.
#+end_src

* A Table-Driven Implementation
 The straightforward method operates at the bit level, it is rather awkward
 to code (even in C), and inefficient to execute (it has to loop once
 for each bit). To speed it up, we need to find a way to enable the
 algorithm to process the message in units larger than one bit.

For the purposes of discussion, let us switch from a 4-bit poly to a
32-bit one. Our register looks much the same, except the boxes
represent bytes instead of bits, and the Poly is 33 bits (one implicit
1 bit at the top and 32 "active" bits) (W=32).

#+begin_src sh
             3    2    1    0   Bytes
          +----+----+----+----+
 Pop! <-- |    |    |    |    | <----- Augmented message
          +----+----+----+----+
         1<------32 bits------>
#+end_src
Consider for a moment that we use the top 8 bits of the register to
calculate the value of the top bit of the register during the next 8
iterations. Suppose that we drive the next 8 iterations using the
calculated values (which we could perhaps store in a single byte
register and shift out to pick off each bit). Then we note three
things:

+ The top byte of the register now doesn't matter. No matter how many
  times and at what offset the poly is XORed to the top 8 bits, they
  will all be shifted out the right hand side during the next 8
  iterations anyway.
+ The remaining bits will be shifted left one position and the
  rightmost byte of the register will be shifted in the next byte
+ While all this is going on, the register will be subjected to a
  series of XOR's in accordance with the bits of the pre-calculated
  control byte.

Perhaps you can see the solution now. Putting all the pieces together
we have an algorithm that goes like this:

#+begin_src sh
   While (augmented message is not exhausted)
      Begin
      Examine the top byte of the register
      Calculate the control byte from the top byte of the register
      Sum all the Polys at various offsets that are to be XORed into
         the register in accordance with the control byte
      Shift the register left by one byte, reading a new message byte
         into the rightmost byte of the register
      XOR the summed polys to the register
      End
#+end_src

As it stands this is not much better than the SIMPLE algorithm.
However, it turns out that most of the calculation can be precomputed
and assembled into a table. As a result, the above algorithm can be
reduced to:

#+begin_src sh
While (augmented message is not exhaused)
      Begin
      Top = top_byte(Register);
      Register = (Register << 24) | next_augmessage_byte;
      Register = Register XOR precomputed_table[Top];
      End
#+end_src

The above is a very efficient algorithm requiring just a shift, and
OR, an XOR, and a table lookup per byte. 

In C, the algorithm main loop looks like this:
#+begin_src c
     r=0;
     while (len--)
       {
        byte t = (r >> 24) & 0xFF;
        r = (r << 8) | *p++;
        r^=table[t];
       }
#+end_src
where len is the length of the augmented message in bytes, p points to
the augmented message, r is the register, t is a temporary, and table
is the computed table. This code can be made even more unreadable as
follows:

#+begin_src c
r=0;
   while (len--)
          r = ((r << 8) | *p++) ^ t[(r >> 24) & 0xFF];
#+end_src

* A Slightly Mangled Table-Driven Implementation
* cc
#+begin_src sh

#+end_src

#+begin_src c++

#+end_src

* Footnotes

[fn:1] Tanenbaum, A.S., "Computer Networks", Prentice Hall, 1981, ISBN: 0-13-164699-0. Comment: Section 3.5.3 on pages 128 to 132 provides a very clear description of CRC codes. However, it does not describe table-driven implementation techniques.



