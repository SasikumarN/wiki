<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>inter-process communication</title>
<!-- 2016-02-03 Wed 22:49 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">inter-process communication</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">IPC Shared Memory</a>
<ul>
<li><a href="#sec-1-1">Accessing a Shared Memory Segment</a></li>
<li><a href="#sec-1-2">Attaching and Detaching a Shared Memory Segment</a></li>
<li><a href="#sec-1-3">Example</a></li>
<li><a href="#sec-1-4">POSIX Shared Memory</a></li>
</ul>
</li>
<li><a href="#sec-2">Sharing semaphores between processes</a></li>
<li><a href="#sec-3">Message queues</a></li>
<li><a href="#sec-4">Socket</a></li>
<li><a href="#sec-5">Pipes</a>
<ul>
<li><a href="#sec-5-1">Anonymous Pipes</a></li>
<li><a href="#sec-5-2">Named Pipes</a></li>
</ul>
</li>
<li><a href="#sec-6">More</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">IPC Shared Memory</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Accessing a Shared Memory Segment</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">shmget</span>(<span style="color: #98fb98;">key_t</span> <span style="color: #eedd82;">key</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shmflg</span>);
</pre>
</div>
<p>
is used to obtain access to a shared memory segment. 
</p>

<ul class="org-ul">
<li>The <code>key</code> argument is a access value associated with the semaphore ID.
</li>
<li>The <code>size</code> argument is the size in bytes of the requested shared memory.
</li>
<li>The <code>shmflg</code> argument specifies the initial access permissions and
creation control flags.
</li>
<li>When the call succeeds, it returns the shared memory segment ID.
This call is also used to get the ID of an existing shared segment
(from a process requesting sharing of some existing memory portion).
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/ipc.h&gt;</span> 
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/shm.h&gt;</span> 
... 
key_t key; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">key to be passed to shmget() </span><span style="color: #ff7f24;">*/</span> 
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shmflg</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">shmflg to be passed to shmget() </span><span style="color: #ff7f24;">*/</span> 
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shmid</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">return value from shmget() </span><span style="color: #ff7f24;">*/</span> 
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">size</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">size to be passed to shmget() </span><span style="color: #ff7f24;">*/</span> 
... 
key = ... 
size = ...
shmflg) = ... 
<span style="color: #00ffff;">if</span> ((shmid = shmget (key, size, shmflg)) == -1) {
   perror(<span style="color: #ffa07a;">"shmget: shmget failed"</span>); exit(1); } <span style="color: #00ffff;">else</span> {
   (<span style="color: #98fb98;">void</span>) fprintf(stderr, <span style="color: #ffa07a;">"shmget: shmget returned %d\n"</span>, shmid);
   exit(0);
}
</pre>
</div>
</div>

<ul class="org-ul"><li><a id="sec-1-1-1" name="sec-1-1-1"></a>Controlling a Shared Memory Segment<br  /><div class="outline-text-4" id="text-1-1-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">shmctl</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shmid</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cmd</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">shmid_ds</span> *<span style="color: #eedd82;">buf</span>);
</pre>
</div>
<p>
is used to alter the permissions and other characteristics of a shared
memory segment.
</p>

<p>
The cmd argument is one of following control commands:
</p>

<ul class="org-ul">
<li><code>SHM_LOCK</code>
&#x2013; Lock the specified shared memory segment in memory. The process
must have the effective ID of superuser to perform this command.
</li>

<li><code>SHM_UNLOCK</code>
&#x2013; Unlock the shared memory segment. The process must have the
effective ID of superuser to perform this command.
</li>

<li><code>IPC_STAT</code>
&#x2013; Return the status information contained in the control structure
and place it in the buffer pointed to by buf. The process must have
read permission on the segment to perform this command.
</li>

<li><code>IPC_SET</code>
&#x2013; Set the effective user and group identification and access
permissions. The process must have an effective ID of owner, creator
or superuser to perform this command.
</li>

<li><code>IPC_RMID</code>
  &#x2013; Remove the shared memory segment.
</li>
</ul>

<p>
The <code>buf</code> is a sructure of type <code>struct shmid_ds</code> which is defined in
<code>&lt;sys/shm.h&gt;</code>.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/ipc.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/shm.h&gt;</span>
...
<span style="color: #98fb98;">int</span> cmd; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">command code for shmctl() </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shmid</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">segment ID </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">shmid_ds</span> <span style="color: #eedd82;">shmid_ds</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">shared memory data structure to </span>
<span style="color: #ff7f24;">                             hold results </span><span style="color: #ff7f24;">*/</span> 
...
shmid = ...
cmd = ...
<span style="color: #00ffff;">if</span> ((rtrn = shmctl(shmid, cmd, shmid_ds)) == -1) {
    perror(<span style="color: #ffa07a;">"shmctl: shmctl failed"</span>);
    exit(1);
}
</pre>
</div>
</div>
</li></ul>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Attaching and Detaching a Shared Memory Segment</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<code>shmat()</code> and <code>shmdt()</code> are used to attach and detach shared memory
segments.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">shmat</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shmid</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">shmaddr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shmflg</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">shmdt</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">shmaddr</span>);
</pre>
</div>

<ul class="org-ul">
<li><code>shmat()</code> returns a pointer, shmaddr, to the head of the shared
segment associated with a valid shmid. 
</li>
<li><code>shmdt()</code> detaches the shared memory segment located at the address
indicated by shmaddr.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span> 
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/ipc.h&gt;</span> 
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/shm.h&gt;</span> 

<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">state</span> { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Internal record of attached segments. </span><span style="color: #ff7f24;">*/</span> 
          <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shmid</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">shmid of attached segment </span><span style="color: #ff7f24;">*/</span> 
          <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">shmaddr</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">attach point </span><span style="color: #ff7f24;">*/</span> 
          <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shmflg</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">flags used on attach </span><span style="color: #ff7f24;">*/</span>
         } <span style="color: #eedd82;">ap</span>[MAXnap]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">State of current attached segments. </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nap</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Number of currently attached segments. </span><span style="color: #ff7f24;">*/</span>
...
<span style="color: #98fb98;">char</span> *addr; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">address work variable </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">register</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">work area </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">register</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">state</span> *<span style="color: #eedd82;">p</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">ptr to current state entry </span><span style="color: #ff7f24;">*/</span>
...
p = &amp;ap[nap++];
p-&gt;shmid = ...
p-&gt;shmaddr = ...
p-&gt;shmflg = ...

p-&gt;shmaddr = shmat(p-&gt;shmid, p-&gt;shmaddr, p-&gt;shmflg);
<span style="color: #00ffff;">if</span>(p-&gt;shmaddr == (<span style="color: #98fb98;">char</span> *)-1) {
     perror(<span style="color: #ffa07a;">"shmop: shmat failed"</span>);
     nap--;
    } <span style="color: #00ffff;">else</span>
    (<span style="color: #98fb98;">void</span>) fprintf(stderr, <span style="color: #ffa07a;">"shmop: shmat returned %#8.8x\n"</span>,
p-&gt;shmaddr);
... 
i = shmdt(addr);
<span style="color: #00ffff;">if</span>(i == -1) {
    perror(<span style="color: #ffa07a;">"shmop: shmdt failed"</span>);
    } <span style="color: #00ffff;">else</span> {
  (<span style="color: #98fb98;">void</span>) fprintf(stderr, <span style="color: #ffa07a;">"shmop: shmdt returned %d\n"</span>, i);

<span style="color: #00ffff;">for</span> (p = ap, i = nap; i--; p++)   
  <span style="color: #00ffff;">if</span> (p-&gt;shmaddr == addr) *p = ap[--nap];

}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Example</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li><code>shm_server.c</code>
   &#x2013; simply creates the string and shared memory portion.
</li>
<li><code>shm_client.c</code>
 &#x2013; attaches itself to the created shared memory portion and uses
the string
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">After running the Server you can see the attached Shared Memory </span>
$<span style="color: #eedd82;">ipcs</span> -m
------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status    
0x0000162e 4292614    xxx        666        27         1                       
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">After running the client the memory is freed.</span>
$<span style="color: #eedd82;">ipcs</span> -m
------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status    
0x0000162e 4292614    xxx        666        27         0
</pre>
</div>

<p>
<code>shm_server.c</code>
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/ipc.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/shm.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SHMSZ</span>     27

<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shmid</span>;
  <span style="color: #98fb98;">key_t</span> <span style="color: #eedd82;">key</span>;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">shm</span>, *<span style="color: #eedd82;">s</span>;
  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * We'll name our shared memory segment</span>
<span style="color: #ff7f24;">   * "5678".</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  key = 5678;
  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * Create the segment.</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #00ffff;">if</span> ((shmid = shmget(key, SHMSZ, IPC_CREAT | 0666)) &lt; 0) {
    perror(<span style="color: #ffa07a;">"shmget"</span>);
    exit(1);
  }
  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * Now we attach the segment to our data space.</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #00ffff;">if</span> ((shm = shmat(shmid, <span style="color: #7fffd4;">NULL</span>, 0)) == (<span style="color: #98fb98;">char</span> *) -1) {
    perror(<span style="color: #ffa07a;">"shmat"</span>);
    exit(1);
  }
  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * Now put some things into the memory for the</span>
<span style="color: #ff7f24;">   * other process to read.</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  s = shm;
  <span style="color: #00ffff;">for</span> (c = <span style="color: #ffa07a;">'a'</span>; c &lt;= <span style="color: #ffa07a;">'z'</span>; c++)
    *s++ = c;
  *s = <span style="color: #7fffd4;">NULL</span>;
  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * Finally, we wait until the other process </span>
<span style="color: #ff7f24;">   * changes the first character of our memory</span>
<span style="color: #ff7f24;">   * to '*', indicating that it has read what </span>
<span style="color: #ff7f24;">   * we put there.</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #00ffff;">while</span> (*shm != <span style="color: #ffa07a;">'*'</span>)
    sleep(1);
  exit(0);
}
</pre>
</div>

<p>
<code>shm_client.c</code>
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/ipc.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/shm.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SHMSZ</span>     27

<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shmid</span>;
  <span style="color: #98fb98;">key_t</span> <span style="color: #eedd82;">key</span>;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">shm</span>, *<span style="color: #eedd82;">s</span>;
  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * We need to get the segment named</span>
<span style="color: #ff7f24;">   * "5678", created by the server.</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  key = 5678;
  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * Locate the segment.</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #00ffff;">if</span> ((shmid = shmget(key, SHMSZ, 0666)) &lt; 0) {
    perror(<span style="color: #ffa07a;">"shmget"</span>);
    exit(1);
  }
  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * Now we attach the segment to our data space.</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #00ffff;">if</span> ((shm = shmat(shmid, <span style="color: #7fffd4;">NULL</span>, 0)) == (<span style="color: #98fb98;">char</span> *) -1) {
    perror(<span style="color: #ffa07a;">"shmat"</span>);
    exit(1);
  }
  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * Now read what the server put in the memory.</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #00ffff;">for</span> (s = shm; *s != <span style="color: #7fffd4;">NULL</span>; s++)
    putchar(*s);
  putchar(<span style="color: #ffa07a;">'\n'</span>);
  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * Finally, change the first character of the </span>
<span style="color: #ff7f24;">   * segment to '*', indicating we have read </span>
<span style="color: #ff7f24;">   * the segment.</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  *shm = <span style="color: #ffa07a;">'*'</span>;
  exit(0);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">POSIX Shared Memory</h3>
<div class="outline-text-3" id="text-1-4">
<p>
POSIX shared memory is actually a variation of mapped memory. The
major differences are to use <code>shm_open()</code> to open the shared memory
object (instead of calling <code>open()</code>) and use <code>shm_unlink()</code> to close and
delete the object (instead of calling <code>close()</code> which does not remove
the object).
</p>
</div>

<ul class="org-ul"><li><a id="sec-1-4-1" name="sec-1-4-1"></a>Create the memory segment<br  /><div class="outline-text-4" id="text-1-4-1">
<p>
Create shared memory segment by using <code>shm_open()</code>. The <code>shm_open()</code> call
establishes a connection between a shared memory object and a file
descriptor. It creates an open file description that refers to the
shared memory object and a file descriptor that refers to that open
file description.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/mman.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">shm_open</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">oflag</span>, <span style="color: #98fb98;">mode_t</span> <span style="color: #eedd82;">mode</span>);
</pre>
</div>

<ul class="org-ul">
<li>The name argument points to a string naming a shared memory object.
</li>
<li>If successful, <code>shm_open()</code> returns a file descriptor for the shared
memory object that is the lowest numbered file descriptor not
currently open for that process.
</li>
<li>oflag: file access modes
<ul class="org-ul">
<li><code>O_RDONLY</code> will create a read-only segment.
</li>
<li><code>O_RDWR</code> will create a segment that we can read and write from/to
the memory segment.
</li>
<li><code>O_CREAT</code> creates the segment if it does not exist or a handle to
it if it does exist.
</li>
<li><code>O_EXCL</code> will return an error if the segment already exists.
</li>
</ul>
</li>
<li>The last parameters are the file access permissions.
</li>
</ul>
</div>
</li>

<li><a id="sec-1-4-2" name="sec-1-4-2"></a>Set the size of the memory segment<br  /><div class="outline-text-4" id="text-1-4-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ftruncate</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">file_descriptor</span>, <span style="color: #98fb98;">off_t</span> <span style="color: #eedd82;">length</span>);
</pre>
</div>
</div>
</li>

<li><a id="sec-1-4-3" name="sec-1-4-3"></a>Map the shared memory region<br  /><div class="outline-text-4" id="text-1-4-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/mman.h&gt;</span>
<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">mmap</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">len</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">prot</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">flags</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>, <span style="color: #98fb98;">off_t</span> <span style="color: #eedd82;">offset</span>);
</pre>
</div>
<p>
The <code>mmap()</code> function establishes a mapping between the address space of
the process for len bytes to the memory object represented by the file
descriptor fd at offset off for len bytes.
</p>

<p>
The <code>mmap()</code> returns a pointer to the shared memory segment. After the
process finished, it can unmap it from the address space of the
process using <code>munmap()</code> call:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/mman.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">munmap</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">len</span>)
</pre>
</div>
<p>
The shared memory can be removed from the system using <code>shm_unlink()</code>.
It causes the shared memory to be deleted when the last process
detaches from it.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/mman.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">shm_unlink</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>)
</pre>
</div>
</div>
</li>

<li><a id="sec-1-4-4" name="sec-1-4-4"></a>Example<br  /><div class="outline-text-4" id="text-1-4-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/mman.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">pthread_mutexattr_t</span> <span style="color: #eedd82;">attributes</span>;
  pthread_mutexattr_init(&amp;attributes);
  pthread_mutexattr_setpshared(&amp;attributes, PTHREAD_PROCESS_SHARED);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">handle</span> = shm_open(<span style="color: #ffa07a;">"/shm"</span>, O_CREAT | O_RDWR, 0777);
  ftruncate(handle, 2048*<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>));
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">memory</span> = (<span style="color: #98fb98;">char</span> *)mmap(0, 2048*<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>), PROT_READ | PROT_WRITE,
                              MAP_SHARED, handle, 0);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">mutex share</span>
  <span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span> = (<span style="color: #98fb98;">pthread_mutex_t</span>*)memory;
  pthread_mutex_init(mutex, &amp;attributes);
  pthread_mutexattr_destroy(&amp;attributes);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">variable share</span>
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">count</span> = (<span style="color: #98fb98;">int</span>*)(memory + <span style="color: #00ffff;">sizeof</span>(pthread_mutex_t));
  *count = 0;
  printf(<span style="color: #ffa07a;">"Initial count = %d\n"</span>, *count);

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">value_returned_from_child</span> = 0;
  <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span> = fork();
  <span style="color: #00ffff;">if</span> (pid == 0) {
    pthread_mutex_lock(mutex);
    (*count)++;
    printf(<span style="color: #ffa07a;">"Child process increased the count to %d\n"</span>, *count);
    pthread_mutex_unlock(mutex);
    value_returned_from_child = 99;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">status</span>;
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">waiting for the child process to finish</span>
    waitpid(pid, &amp;status, 0);
    value_returned_from_child = WEXITSTATUS(status);
    printf(<span style="color: #ffa07a;">"value_returned_from_child = %d\n"</span>, value_returned_from_child);
    pthread_mutex_lock(mutex);
    (*count)++;
    printf(<span style="color: #ffa07a;">"Parent process increased the count to %d\n"</span>, *count);
    pthread_mutex_unlock(mutex);
  }
  munmap(memory, 2048*<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>));
  shm_unlink(<span style="color: #ffa07a;">"/shm"</span>);
  <span style="color: #00ffff;">return</span> value_returned_from_child;
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">g++ -o ipc ipc.cc -Wall -lpthread -lrt
</pre>
</div>

<p>
The parent process sets up a mutex that's shared with its child
process. Then, the parent forks a child, and wait for the child to
complete (<code>waitpid()</code>).
</p>

<p>
The macro <code>WEXITSTATUS</code> does the conversion of the exit status from
<code>waitpid()</code> into the return value from the child process.
</p>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Sharing semaphores between processes</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;semaphore.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">status</span>;
  <span style="color: #98fb98;">sem_t</span> *<span style="color: #eedd82;">semaphore</span> =  sem_open(<span style="color: #ffa07a;">"/sema"</span>, O_CREAT,  0777, 1);

  <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span> = fork();
  <span style="color: #00ffff;">if</span> (pid == 0) {
    printf(<span style="color: #ffa07a;">"child\n"</span>);
    sem_post(semaphore);
    sem_close(semaphore);
  } <span style="color: #00ffff;">else</span> {
    sem_wait(semaphore);
    printf(<span style="color: #ffa07a;">"parent\n"</span>);
    sem_close(semaphore);
    sem_unlink(<span style="color: #ffa07a;">"/sema"</span>);
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Message queues</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;mqueue.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PMODE</span> 0655

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">status</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">mq_attr</span> <span style="color: #eedd82;">attr</span>;
  attr.mq_maxmsg = 10;
  attr.mq_msgsize = 20;
  <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span> = fork();
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">child process - sending message</span>
  <span style="color: #00ffff;">if</span> (pid == 0) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">message</span>[20];
    strncpy(message, <span style="color: #ffa07a;">"Hello Parent!"</span>, 13);
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">write/create - attr needed because of O_CREAT</span>
    <span style="color: #98fb98;">mqd_t</span> <span style="color: #eedd82;">mqfd</span> = mq_open(<span style="color: #ffa07a;">"/test1"</span>, O_WRONLY|O_CREAT, PMODE, &amp;attr);
    <span style="color: #00ffff;">if</span>(mqfd == -1) {
      perror(<span style="color: #ffa07a;">"Child mq_open failure"</span>);
      exit(0);
    }
    status = mq_send(mqfd, message, strlen(message)+1, 0);
    <span style="color: #00ffff;">if</span> (status == -1) {
      perror(<span style="color: #ffa07a;">"mq_send failure\n"</span>);
    }
    <span style="color: #00ffff;">else</span> {
      printf(<span style="color: #ffa07a;">"Child is sending message: %s\n"</span>, message);
      printf(<span style="color: #ffa07a;">"mq_send successful\n"</span>);
    }
    mq_close(mqfd);
    printf(<span style="color: #ffa07a;">"Child process done\n"</span>);
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">parent - receiving message</span>
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">read only</span>
    <span style="color: #98fb98;">mqd_t</span> <span style="color: #eedd82;">mqfd</span> = mq_open(<span style="color: #ffa07a;">"/test1"</span>, O_RDONLY|O_CREAT, PMODE, &amp;attr);
    <span style="color: #00ffff;">if</span> (mqfd == -1) {
      perror(<span style="color: #ffa07a;">"Parent mq_open failure"</span>);
      exit(0);
    }
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Parent is waiting for the child process to finish</span>
    waitpid(pid, &amp;status, 0);
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[100];
    status = mq_receive(mqfd, buf, 100, 0);
    <span style="color: #00ffff;">if</span> (status == -1) {
      perror(<span style="color: #ffa07a;">"mq_receive failure\n"</span>);
    } <span style="color: #00ffff;">else</span> {
      printf(<span style="color: #ffa07a;">"mq_receive successful\n"</span>);
      printf(<span style="color: #ffa07a;">"Parent received message: %s\n"</span>, buf);
    }
    mq_close(mqfd);
    mq_unlink(<span style="color: #ffa07a;">"/test1"</span>);
    printf(<span style="color: #ffa07a;">"Parent process done\n"</span>);
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Socket</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>server.c</code>
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/socket.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;netinet/in.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">error</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">msg</span>)
{
  perror(msg);
  exit(1);
}

<span style="color: #98fb98;">void</span>* <span style="color: #87cefa;">echo</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">param</span>)
{
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[1024];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;
  pthread_detach(pthread_self());
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span> = (<span style="color: #98fb98;">int</span>)param;
  <span style="color: #00ffff;">while</span> (count = read(s, buf, 1023) &gt; 0) {
    printf(<span style="color: #ffa07a;">"Server received %s\n"</span>, buf);
    printf(<span style="color: #ffa07a;">"Server sending it back\n"</span>);
    write(s, buf, strlen(buf));
  }
  close(s);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sockfd</span>, <span style="color: #eedd82;">newsockfd</span>, <span style="color: #eedd82;">portno</span> = 9999;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">create a TCP/IP socket</span>
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  <span style="color: #00ffff;">if</span> (sockfd &lt; 0)
    error(<span style="color: #ffa07a;">"ERROR opening socket"</span>);

  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sockaddr_in</span> <span style="color: #eedd82;">serv_addr</span>;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">clear address structure</span>
  bzero((<span style="color: #98fb98;">char</span> *) &amp;serv_addr, <span style="color: #00ffff;">sizeof</span>(serv_addr));
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">setup the host_addr structure for use in bind call </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">server byte order</span>
  serv_addr.sin_family = AF_INET;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">automatically be filled with current host's IP address</span>
  serv_addr.sin_addr.s_addr = INADDR_ANY;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">port number to bind to</span>
  serv_addr.sin_port = htons(portno);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">This bind() call will bind  the socket to the current IP address on port</span>
  <span style="color: #00ffff;">if</span> (bind(sockfd, (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sockaddr</span> *) &amp;serv_addr, <span style="color: #00ffff;">sizeof</span>(serv_addr)) &lt; 0) {
    error(<span style="color: #ffa07a;">"ERROR on binding"</span>);
  }
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">This listen() call tells the socket to listen to the incoming connections.</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The listen() function places all incoming connection into a backlog queue</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">until accept() call accepts the connection.</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Here, we set the maximum size for the backlog queue to 5.</span>
  listen(sockfd, 5);
  <span style="color: #00ffff;">while</span> (newsockfd = accept(sockfd, 0, 0)) {
    <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">t</span>;
    pthread_create(&amp;t, 0, echo, (<span style="color: #98fb98;">void</span>*)newsockfd);
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<p>
<code>client.c</code>
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/socket.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;netinet/in.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;netdb.h&gt;</span>

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">error</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">msg</span>)
{
  perror(msg);
  exit(0);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sockfd</span>, <span style="color: #eedd82;">portno</span> = 9999;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sockaddr_in</span> <span style="color: #eedd82;">serv_addr</span>;
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  <span style="color: #00ffff;">if</span> (sockfd &lt; 0)
    error(<span style="color: #ffa07a;">"ERROR opening socket"</span>);
  bzero(&amp;serv_addr, <span style="color: #00ffff;">sizeof</span>(serv_addr));
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = inet_addr(<span style="color: #ffa07a;">"127.0.0.1"</span>);
  serv_addr.sin_port = htons(portno);

  <span style="color: #00ffff;">if</span> (connect(sockfd, (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sockaddr</span> *) &amp;serv_addr, <span style="color: #00ffff;">sizeof</span>(serv_addr)) == 0) {
    printf(<span style="color: #ffa07a;">"Client sending 'hello server!' to server\n"</span>);
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[1024];
    strncpy(buf, <span style="color: #ffa07a;">"hello server!"</span>, 20);
    write(sockfd, buf, strlen(buf));
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span> = read(sockfd, buf, 1024);
    printf(<span style="color: #ffa07a;">"Got echo of %s from server\n"</span>, buf);
    shutdown(sockfd, SHUT_RDWR);
  } <span style="color: #00ffff;">else</span>
    error(<span style="color: #ffa07a;">"ERROR connecting"</span>);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Pipes</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Anonymous Pipes</h3>
<div class="outline-text-3" id="text-5-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">status</span>, <span style="color: #eedd82;">myPipe</span>[2];
  pipe(myPipe);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">create the pipe</span>
  <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span> = fork();
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">child process </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #00ffff;">if</span> (pid == 0) {
    close(myPipe[0]);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">close unused read end</span>
    write(myPipe[1], <span style="color: #ffa07a;">"a"</span>, 1);
    printf(<span style="color: #ffa07a;">"Child process sent 'a'\n"</span>);
    close(myPipe[1]);
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">parent process </span><span style="color: #ff7f24;">*/</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buffer</span>[21];
    close(myPipe[1]);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">close unused write end</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pid_child</span> = wait(&amp;status);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">length</span> = read(myPipe[0], buffer, 20);
    buffer[length] = <span style="color: #ffa07a;">'\0'</span>;
    printf(<span style="color: #ffa07a;">"Parent process received '%s'\n"</span>, buffer);
    close(myPipe[0]);
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Named Pipes</h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/stat.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">status</span>;
  mknod(<span style="color: #ffa07a;">"/tmp/pipefile"</span>, S_IFIFO | S_IRUSR | S_IWUSR, 0);
  <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span> = fork();
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">child process </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #00ffff;">if</span> (pid == 0) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">myPipe</span> = open(<span style="color: #ffa07a;">"/tmp/pipefile"</span>, O_WRONLY);
    write(myPipe, <span style="color: #ffa07a;">"a"</span>, 1);
    printf(<span style="color: #ffa07a;">"Child process sent 'a'\n"</span>);
    close(myPipe);
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">parent process </span><span style="color: #ff7f24;">*/</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">myPipe</span> = open(<span style="color: #ffa07a;">"/tmp/pipefile"</span>, O_RDONLY);
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buffer</span>[21];
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pid_child</span> = wait(&amp;status);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">length</span> = read(myPipe, buffer, 20);
    buffer[length] = <span style="color: #ffa07a;">'\0'</span>;
    printf(<span style="color: #ffa07a;">"Parent process received '%s'\n"</span>, buffer);
    close(myPipe);
  }
  unlink(<span style="color: #ffa07a;">"/tmp/pipefile"</span>);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">More</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li><a href="https://www.cs.cf.ac.uk/Dave/C/node27.html#SECTION002760000000000000000">Some further example(shmget,shmctl,shmop)</a>
</li>
<li><a href="http://www.ibm.com/developerworks/aix/library/au-concurrent_boost/">Concurrent programming with Boost using IPC and MPI libraries</a>
</li>
<li><a href="http://www.bogotobogo.com/cplusplus/multithreading_ipc.php">MultiThreading/Parallel Programming IPC</a>
</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2016-02-03 Wed 22:49</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
