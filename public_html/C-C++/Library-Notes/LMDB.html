<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Symas Lightning Memory-Mapped Database (LMDB) Notes</title>
<!-- 2016-04-26 Tue 22:39 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Symas Lightning Memory-Mapped Database (LMDB) Notes</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Overview</a></li>
<li><a href="#sec-2">LMDB基本架构</a></li>
<li><a href="#sec-3">使用Memory Map</a>
<ul>
<li><a href="#sec-3-1">Memory Map原理</a></li>
<li><a href="#sec-3-2">Linux下mmap的实现过程与普通文件io操作</a></li>
<li><a href="#sec-3-3">lmdb使用mmap过程</a></li>
</ul>
</li>
<li><a href="#sec-4">B-tree/B+tree/B*tree</a>
<ul>
<li><a href="#sec-4-1">B-tree</a></li>
<li><a href="#sec-4-2">B+tree</a></li>
<li><a href="#sec-4-3">B*tree</a></li>
<li><a href="#sec-4-4">More</a></li>
<li><a href="#sec-4-5">lmdb中的使用</a></li>
</ul>
</li>
<li><a href="#sec-5">COW and MVCC</a></li>
<li><a href="#sec-6">事务控制</a></li>
<li><a href="#sec-7">核心代码流程</a></li>
<li><a href="#sec-8">LMDB 核心数据结构</a></li>
<li><a href="#sec-9">cc</a></li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Overview</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>homepage: <a href="http://symas.com/mdb/">http://symas.com/mdb/</a>
</li>
<li><a href="https://github.com/LMDB/lmdb">https://github.com/LMDB/lmdb</a>
</li>
<li>source codes doc: <a href="http://symas.com/mdb/doc/starting.html">http://symas.com/mdb/doc/starting.html</a>
</li>
<li>official repo on openldap.org:
<a href="http://www.openldap.org/software/repo.html">http://www.openldap.org/software/repo.html</a>
</li>
</ul>

<p>
LMDB(Lightning Memory-Mapped Database) is a tiny database with some great capabilities:
</p>
<ul class="org-ul">
<li>Ordered-map interface (keys are always sorted, supports range lookups)
</li>
<li>Fully transactional, full ACID (Atomicity, Consistency, Isolation,
Durability) semantics with MVCC(Multiversion concurrency control).
</li>
<li>Reader/writer transactions: readers don't block writers and writers
don't block readers. Writers are fully serialized, so writes are
always deadlock-free.
</li>
<li>Read transactions are extremely cheap, and can be performed using no
mallocs or any other blocking calls.
</li>
<li>Supports multi-thread and multi-process concurrency, environments
may be opened by multiple processes on the same host.
</li>
<li>Multiple sub-databases may be created with transactions covering all
sub-databases.
</li>
<li>Memory-mapped, allowing for zero-copy lookup and iteration.
</li>
<li>Maintenance-free, no external process or background
cleanup/compaction required.
</li>
<li>Crash-proof, no logs or crash recovery procedures required.
</li>
<li>No application-level caching. LMDB fully exploits the operating
system's buffer cache.
</li>
<li>32KB of object code and 6KLOC of C.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">LMDB基本架构</h2>
<div class="outline-text-2" id="text-2">
<p>
lmdb的基本架构如下:
<img src="./Files/lmdb-arch.svg" alt="lmdb-arch.svg" />
</p>

<p>
lmdb的基本做法是使用mmap文件映射，不管这个文件存储实在内存上还是在持久存储上。lmdb的所有读取操作都是通过mmap将要访问的文件只读的映射到虚拟内存中，直接访问相应的地址.因为使用了read-only的mmap，同样避免了程序错误将存储结构写坏的风险。并且IO的调度由操作系统的页调度机制完成。而写操作，则是通过write系统调用进行的，这主要是为了利用操作系统的文件系统一致性，避免在被访问的地址上进行同步。
</p>

<p>
lmdb把整个虚拟存储组织成B+Tree存储,索引和值读存储在B+Tree的页面上.对外提供了关于B+Tree的操作方式，利用cursor游标进行。可以进行增删改查。
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">使用Memory Map</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Memory Map原理</h3>
<div class="outline-text-3" id="text-3-1">
<p>
内存映射就是把物理内存映射到进程的地址空间之内，这些应用程序就可以直接使用输入输出的地址空间.由此可以看出，使用内存映射文件处理存储于磁盘上的文件时，将不需要由应用程序对文件执行I/O操作，这意味着在对文件进行处理时将不必再为文件申请并分配缓存，所有的文件缓存操作均由系统直接管理，由于取消了将文件数据加载到内存、数据从内存到文件的回写以及释放内存块等步骤，使得内存映射文件在处理大数据量的文件时能起到相当重要的作用。
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Linux下mmap的实现过程与普通文件io操作</h3>
<div class="outline-text-3" id="text-3-2">
<p>
mmap映射原理与过程<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>:
<img src="./Files/mmap-linux.gif" alt="mmap-linux.gif" />
</p>

<p>
一般文件io操作方式:
<img src="./Files/normal-file-io.gif" alt="normal-file-io.gif" />
</p>

<p>
通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高，
read()是系统调用，其中进行了数据拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间，在这个过程中，实际上完成了 <b>两次数据拷贝</b> ；而mmap()也是系统调用，如前所述，mmap()中没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的，由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了 <b>一次数据拷贝</b> 。因此，内存映射的效率要比
read/write效率高。
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">lmdb使用mmap过程</h3>
<div class="outline-text-3" id="text-3-3">
<p>
lmdb创建完env对象,打开时,会做data file和lock file的mmap映射:
</p>

<div class="org-src-container">

<pre class="src src-c++">env-&gt;me_lfd = open(lpath, O_RDWR|O_CREAT|MDB_CLOEXEC, mode);
<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">m</span> = mmap(<span style="color: #7fffd4;">NULL</span>, rsize, PROT_READ|PROT_WRITE, MAP_SHARED,
                        env-&gt;me_lfd, 0);
env-&gt;me_txns = m;

env-&gt;me_fd = open(dpath, oflags, mode);

env-&gt;me_map = mmap(addr, env-&gt;me_mapsize, prot, MAP_SHARED,
                env-&gt;me_fd, 0);
</pre>
</div>

<p>
其他时刻都直接使用内存指针，通过系统级别的缺页异常获取对应的数据。页面内数据的获取和使用 <code>MDB_CURSOR_GET</code> 进行。页面的获取和key查询通过
<code>mdb_page_get/mdb_page_search</code> 完成.
</p>

<p>
页面头部大小及内容是固定的，具体的含义代表根据flags决定，在头部之后紧接的是node，真正的key-value值对所在位置的索引，因此访问这些node时通过指针计算即可得到对应的位置。
</p>

<p>
lmdb 之后是如何将页面给映射进进程地址空间呢.lmdb通过 <code>mdb_page_get</code> 函数以 pgno 为主要参数获得页面并返回页面指针。若仅仅是只读事务且环境对象是以只读方式打开的，page的获取很简单，根据 <code>page= (MDB_page
*)(env-&gt;me_map + env-&gt;me_psize * pgno);</code> 获得。
</p>

<p>
在lmdb中B+Tree的是基于append-only B+Tree改造的。对于数据增加、修改、删除导致页面增加时，pageno也增加，当旧页面(数据旧版本）被重用时，pageno
保持不变，因此pageno保持了在数据文件中的顺序性，从而在获取页面时，只需要进行简单计算即可以。同时在创建env对象时，数据库已经被整个映射进整个进程空间，因此系统在映射时，会给数据库文件保留全部地址空间，从而在根据上述算法获取真实数据库，系统触发缺页错误，进而从数据文件中获取整个页面内容。此为最简单有效方式，否则不将全部数据映射进地址空间，对于未映射部分还需要在访问页面时判断是否已经被映射，未被映射时进行映射。
</p>

<p>
在需要时在通过文件方式写入。lmdb保证任意时刻只有一个写操作在进行，从而避免了并发时数据被破坏。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">B-tree/B+tree/B*tree</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">B-tree</h3>
<div class="outline-text-3" id="text-4-1">
<p>
B-tree又叫平衡多路查找树。一棵m阶的B-tree (m叉树)的特性如下：<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>
<ol class="org-ol">
<li>树中每个结点至多有m个孩子；
</li>
<li>除根结点和叶子结点外，其它每个结点至少有有ceil(m / 2)个孩子；
</li>
<li>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；
</li>
<li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，实际上这些结点不存在，指向这些结点的指针都为null)；
</li>
<li>每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，
P2，&#x2026;&#x2026;，Kn，Pn)。其中：
<ul class="org-ul">
<li>Ki (i=1&#x2026;n)为关键字，且关键字按顺序排序K(i-1)&lt; Ki。
</li>
<li>Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。
</li>
<li>关键字的个数n必须满足： ceil(m / 2)-1 &lt;= n &lt;= m-1。
</li>
</ul>
</li>
</ol>


<div class="figure">
<p><img src="./Files/b-tree.gif" alt="b-tree.gif" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">B+tree</h3>
<div class="outline-text-3" id="text-4-2">
<p>
B+-tree：是应文件系统所需而产生的一种B-tree的变形树。一棵m阶的B+-tree和m阶的B-tree的差异在于：       
</p>
<ol class="org-ol">
<li>有n棵子树的结点中含有n个关键字； (B-tree是n棵子树有n-1个关键字)
</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (B-tree的叶子节点并没有包括全部需要查找的信息)
</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (B-tree的非终节点也包含需要查找的有效信息)
</li>
</ol>


<div class="figure">
<p><img src="./Files/b+tree.gif" alt="b+tree.gif" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">B*tree</h3>
<div class="outline-text-3" id="text-4-3">
<p>
B*-tree是B+-tree的变体，在B+-tree的非根和非叶子结点再增加指向兄弟的指针；B*-tree定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为
2/3（代替B+树的1/2）。如下图所示
</p>


<div class="figure">
<p><img src="./Files/b*tree.gif" alt="b*tree.gif" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">More</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li><a href="http://cis.stvincent.edu/html/tutorials/swd/btree/btree.html">Software Design Using C++(include source codes</a>
</li>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-Trees动画</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/B-tree">B-tree wiki</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/B+_tree">B+ tree wiki</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">lmdb中的使用</h3>
<div class="outline-text-3" id="text-4-5">
<p>
lmdb代码主要分为page管理和cursor操作两块实现b-tree结构.
</p>
</div>
<ul class="org-ul"><li><a id="sec-4-5-1" name="sec-4-5-1"></a>page管理<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup><br  /><div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li><code>mdb_page_malloc</code>: 为新页面分配内存,从操作系统中申请1个或者n个页面，一般为一个页面，n个页面为overflow页面
</li>
<li><code>mdb_page_alloc</code>: 分配页面分配一个或n个页面，若分配n个，则n个页面是连续页面。若事务中可用脏空间没有了，则分配失败，可用脏空间是指存储脏页ID的数组大小. LMDB中所有可用的脏页同样被维护成一颗B-Tree， <code>FREE_DBI</code> 中记录了最后一次放入页面的事务ID，每次分配时都从freedb中寻找足够大重用空间，一般分配一个页面能满足，连续页面，可能需要尝试多次，因此多个页面一般是overflow 页面，必须是连续页面才能满足要求。
</li>
<li><code>mdb_page_new</code>: 新建页面首先调用 <code>mdb_page_alloc</code> 分配页面，然后初始化页面，新建一个页面时，认为这个页面是一个全新的页面，因此需要其整个空间可用，初始化设置将体现这点。
</li>
<li><code>mdb_page_free</code>: 释放单个页面,将它放入可重用页面列表。
</li>
<li><code>mdb_page_copy</code>: 复制页面将页面内容从一个页面复制到另外一个页面，此功能主要用于COW.
</li>
<li><code>mdb_page_split</code>: 页面分裂实现了B-Tree的操作过程，考虑了仅有一个节点时、append模式、
braches/leaf/leaf2等不同页面的处理过程，基本流程就是根据一定的算法确定分裂点，根据B-Tree的定义，在分裂时，不一定需要保证平分，只需要保证页面节点保持半满即可。分裂点确定之后，就进行数据的移动并插入导致分裂的数据以及修改指针以维持B-Tree结构，同时再决定是否会导致上层分裂以及
root分裂，若会则进行递归处理。
</li>
<li><code>mdb_page_merge</code>: 页面合并同样是实现了上述因为节点删除导致的merge过程。基本过程是，将合并的目标页面置为脏页，然后根据上述理论情况进行节点的一个个复制，或者对于内部节点而言进行页面指针调整以及进行上下节点的移动，对于本页完成之后进行平衡操作，其中平衡操作可能会又导致merge操作，直到B-Tree重新满足定义为止。
</li>
<li><code>mdb_page_spill</code>: 将脏页写回磁盘，这是为了嵌套长事务进行的设计，有些嵌套长事务会使用大量的页，为了避免耗光内存，可以将脏页写回磁盘，写回磁盘如同commit一样，因为多个进程、线程之间将只会存在一个写事务，因此在未提交之间前写回磁盘没有任何问题。而且只要能有空间，页面就不会刷入磁盘。在执行时，先计算是否空间足够，不够的将id存入idl数组，然后刷入磁盘，再根据环境变量决定是否保留p<sub>dirty标记。</sub>
</li>
<li><code>mdb_page_unspill</code>: 将spill的页面重新读回,
这就不需要进行touch，直接设置dirty标志就可以了。lmdb支持嵌套事务，因此在查找页面是否属于已经被spilled的页面需要查找整个嵌套路径，从叶子到跟,找到之后确认midl列表（脏空间）是否有足够空间，没有的提示事务空间已满，否则加载页面并设置脏页标记。
</li>
<li><code>mdb_page_dirty</code>: 设置脏页标记，并将脏页加入到事务中的脏页列表当中。
</li>
<li><code>mdb_page_flush</code>: 用在事务提交时，当清除页面脏页标记后，将数据更新到磁盘(通过写文件方式).
</li>
<li><code>mdb_page_touch</code>: 实现COW的技术，复制一个页面，并将更新过B-Tree指针关系的页面插入到B-Tree当中，这样意味着在修改时是在复制的页面上进行修改，别的事务在本事务没有提交之前看到还是以前的数据，提交之后的新事物看到的才是修改之后的数据。
</li>
<li><code>mdb_page_search_root</code>: 从B-Tree根节点检索，根据key的值，从根节点开始遍历子树获取每一层对应的page，在page之内检索key，再根据B-Tree查找方法确定下一层子节点的page，层层遍历，从而最终确定key的位置或者判断
B-Tree中没有对应的key。同时将页面存放到cursor页堆栈中。这样cursor将可以重用对应的页面，为后续进行更新等操作提供便利。
</li>
<li><code>mdb_page_search/mdb_page_search_lowest</code> 都将调用
<code>mdb_page_search_root</code> 以完成检索
<ul class="org-ul">
<li><code>mdb_page_search</code> ,除了完成检索为的附加工作是确保所使用的B-Tree在本事务可见范围内是最新版本，同时在需要时将页面置为脏页。
</li>
<li><code>mdb_page_search_lowest</code>: 从当前分支页开始，检索第一个符合条件的值。
</li>
</ul>
</li>
<li><code>mdb_page_get</code> 获取页面，本来根据MMAP原则，读取对应的页面非常简单，计算下地址即可，但lmdb中，考虑到事务可能使用大量的页面，事务可用空间满时，将一部分页面spill/flush到磁盘中，因此需要在get时判断是否在
spill列表中，在的话从中获取，否则直接计算获取。
</li>
<li><code>mdb_page_list</code> 显示页面中的所有key，是个工具方法。 
</li>
</ul>
</div>
</li>

<li><a id="sec-4-5-2" name="sec-4-5-2"></a>cursor操作<br  /><div class="outline-text-4" id="text-4-5-2">
<p>
cursor操作实现了B-Tree节点操作，cursor指向当前需要进行操作的B-Tree节点，然后依据提供的操作方式（insert、del）进行数据操作，然后进行一系列复杂的操作流程以维持B-Tree结构。
</p>
<ul class="org-ul">
<li>游标遍历(
<code>mdb_cursor_sibling,mdb_cursor_next,mdb_cursor_prev,mdb_cursor_first
  ,mdb_cursor_last</code> )
<ul class="org-ul">
<li><code>mdb_cursor_first</code>: 将游标定位至B-Tree的最小叶子节点（第一个），而非根据key查询时得到第一个结果位置。若支持重复数据，还要特殊处理，移动到重复数据第一个。
</li>
<li><code>mdb_cursor_last</code>:与first类似，只不过定位至最大叶子节点（最后一个）
</li>
<li><code>mdb_cursor_next</code>: 游标移动至下一个节点
</li>
<li><code>mdb_cursor_prev</code>: 游标移动至前一个节点
</li>
<li><code>mdb_cursor_sibling</code>: 将游标移动至兄弟节点，可以是前一个页面或者下一个页面。若当前页有key，则行为与next、prev类似，否则移动到下一个页面的对应key位置。
</li>
</ul>
</li>
<li>增删改查( <code>mdb_cursor_get ,mdb_cursor_set ,mdb_cursor_del
  ,mdb_cursor_del0 ，mdb_cursor_put ,mdb_cursor_count</code> )
<ul class="org-ul">
<li><code>mdb_cursor_get</code> ：根据游标位置和条件获取值，最常用：MDB<sub>GET</sub><sub>CURRENT，</sub>
获取游标所指节点的值，基本思路是看页面中索引是否已经大于key个数，大于则说明游标已经需要指向下一页，对于取当前值的不重复key来说，这不可能，因此获取失败。
</li>
<li><code>mdb_cursor_set</code> ：将游标设置（定位）到指定key位置，假如已经在正确页面，只需要判断key是否在页面key的范围之内，判断最大、最小值可以确定。然后根据相应标志，如同get中所说，进行判断以及读取或设置某些变量。否则话进行页面查找先定位key所在页面（ <code>mdb_page_search</code> ),然后定位页面中位置(<code>mdb_node_search</code>),然后再设置相关变量。
</li>
<li><code>mdb_cursor_count</code> ：返回游标代表的结果数，唯一key返回一，重复key
返回重复个数。
</li>
<li><code>mdb_cursor_put</code> :将key、value对存放到数据库中，默认是新增加，若key已经存在则是更新，基本流程是：判断前提cursor、key非空，确认各种标志是否合法，比如多个value，但是数据库不支持重复key这种情形就不合法，标志合适之后，判断是否为空树，非空时将cursor指向正确的位置，比如
append模式指向数据库最大节点之后，正常指向应该插入的位置。然后
touch所有页面使所有页面可写。若为leaf2类型页面，说明key、value完全重复，增加key就OK了，然后再判断value值是否太大，太大则转换为子树进行存储。转化为subdb/subpage时，首先根据各种标志设置各种变量，包括申请新页等，然后其余的就是根据各种标志完成上述理论描述的节点插入动作，将值放置对应位置、进行分页等，需要时进行unspill，放置到
overflow页面等，若一次插入多条数据还需要多次重复进行一次一条的插入。
</li>
<li><code>mdb_cursor_del,mdb_cursor_del0</code> :删除指定key、value。首先是根据各种标志设置各种变量，其次设置页面为脏页，其次若删除之后，
subdb/subpage,overflowpage 等受到影响，则需要将对应页面回收到
free-list，比如subdb删除最后一个节点时，需要删除整棵子树。真正的
key删除在del0中，它从页面中删除对应的key，删除完成后对整个B-Tree进行rebalance,然后修正所有指向当前删除页的同一事务内的其他cursor，通知其他cursor此页面已经被删除。
</li>
</ul>
</li>
<li>打开、关闭、重用、初始化
<ul class="org-ul">
<li><code>mdb_cursor_touch</code>:将数据库以及在cursor堆栈中的所有页面设置为脏页。这样可能会有少量页面实际不需要设置为脏页实际设置为脏页的情形，但这样为实现COW提供最大的便利，只需要修改root页面指针即可，否则需要跟踪很多页面。 
</li>
<li><code>mdb_cursor_open</code> ：打开游标，首先判断标志是否合法，合法就申请内存并调用init初始化 
</li>
<li><code>mdb_cursor_renew</code> ：重用游标，当本游标已经不再使用，可以renew重用。 
</li>
<li><code>mdb_cursor_close</code> ：关闭游标，从事务的cursor列表中删除，释放内存。
</li>
<li><code>mdb_cursor_copy</code> ：复制游标，将所有内容从一个复制到新游标。
</li>
<li><code>mdb_cursor_shadow</code> ：备份cursor对应事务的游标
</li>
<li><code>mdb_cursor_init</code> ：设置各种变量，若数据库状态为 <code>DB_STALE</code> ,则需获取最新的root节点。
</li>
</ul>
</li>
<li>页面操作
<ul class="org-ul">
<li><code>mdb_cursor_pop</code> ：从cursor堆栈中弹出一个页面 
</li>
<li><code>mdb_cursor_push</code>: 将一个页面压入堆栈，一般会将整个search路径上的所有页面压入堆栈。
</li>
</ul>
</li>
<li>状态
<code>mdb_cursor_chk</code> ：检查cursor是否正确 
<code>mdb_cursor_txn</code> : 获取cursor对应事务 
<code>mdb_cursor_dbi</code> ：获取cursor对应数据库 
</li>
</ul>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">COW and MVCC</h2>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">事务控制</h2>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">核心代码流程</h2>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">LMDB 核心数据结构</h2>
<div class="outline-text-2" id="text-8">
<ol class="org-ol">
<li><code>MDB_env</code>
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MDB_env</span> {
        <span style="color: #98fb98;">HANDLE</span>          <span style="color: #eedd82;">me_fd</span>;          <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; The main data file */</span>
        <span style="color: #98fb98;">HANDLE</span>          <span style="color: #eedd82;">me_lfd</span>;         <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; The lock file */</span>
        <span style="color: #98fb98;">HANDLE</span>          <span style="color: #eedd82;">me_mfd</span>;                 <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; just for writing the meta pages */</span>
        <span style="color: #98fb98;">uint32_t</span>        <span style="color: #eedd82;">me_flags</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; @ref mdb_env */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>    <span style="color: #eedd82;">me_psize</span>;       <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; DB page size, inited from me_os_psize */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>    <span style="color: #eedd82;">me_os_psize</span>;    <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; OS page size, from #GET_PAGESIZE */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>    <span style="color: #eedd82;">me_maxreaders</span>;  <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; size of the reader table */</span>
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Max #MDB_txninfo.%mti_numreaders of interest to #mdb_env_close() */</span>
        <span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">int</span>    <span style="color: #eedd82;">me_close_readers</span>;
        <span style="color: #98fb98;">MDB_dbi</span>         <span style="color: #eedd82;">me_numdbs</span>;              <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; number of DBs opened */</span>
        <span style="color: #98fb98;">MDB_dbi</span>         <span style="color: #eedd82;">me_maxdbs</span>;              <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; size of the DB table */</span>
        <span style="color: #98fb98;">MDB_PID_T</span>       <span style="color: #eedd82;">me_pid</span>;         <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; process ID of this env */</span>
        <span style="color: #98fb98;">char</span>            *<span style="color: #eedd82;">me_path</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; path to the DB files */</span>
        <span style="color: #98fb98;">char</span>            *<span style="color: #eedd82;">me_map</span>;                <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; the memory map of the data file */</span>
        <span style="color: #98fb98;">MDB_txninfo</span>     *<span style="color: #eedd82;">me_txns</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; the memory map of the lock file or NULL */</span>
        MDB_meta        *me_metas[NUM_METAS];   <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; pointers to the two meta pages */</span>
        <span style="color: #98fb98;">void</span>            *<span style="color: #eedd82;">me_pbuf</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; scratch area for DUPSORT put() */</span>
        <span style="color: #98fb98;">MDB_txn</span>         *<span style="color: #eedd82;">me_txn</span>;                <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; current write transaction */</span>
        <span style="color: #98fb98;">MDB_txn</span>         *<span style="color: #eedd82;">me_txn0</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; prealloc'd write transaction */</span>
        <span style="color: #98fb98;">mdb_size_t</span>      <span style="color: #eedd82;">me_mapsize</span>;             <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; size of the data memory map */</span>
        <span style="color: #98fb98;">off_t</span>           <span style="color: #eedd82;">me_size</span>;                <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; current file size */</span>
        <span style="color: #98fb98;">pgno_t</span>          <span style="color: #eedd82;">me_maxpg</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; me_mapsize / me_psize */</span>
        <span style="color: #98fb98;">MDB_dbx</span>         *<span style="color: #eedd82;">me_dbxs</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; array of static DB info */</span>
        <span style="color: #98fb98;">uint16_t</span>        *<span style="color: #eedd82;">me_dbflags</span>;    <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; array of flags from MDB_db.md_flags */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>    *<span style="color: #eedd82;">me_dbiseqs</span>;    <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; array of dbi sequence numbers */</span>
        <span style="color: #98fb98;">pthread_key_t</span>   <span style="color: #eedd82;">me_txkey</span>;       <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; thread-key for readers */</span>
        <span style="color: #98fb98;">txnid_t</span>         <span style="color: #eedd82;">me_pgoldest</span>;    <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; ID of oldest reader last time we looked */</span>
        <span style="color: #98fb98;">MDB_pgstate</span>     <span style="color: #eedd82;">me_pgstate</span>;             <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; state of old pages from freeDB */</span>
<span style="color: #b0c4de;">#       define</span>          <span style="color: #eedd82;">me_pglast</span>       me_pgstate.mf_pglast
<span style="color: #b0c4de;">#       define</span>          <span style="color: #eedd82;">me_pghead</span>       me_pgstate.mf_pghead
        <span style="color: #98fb98;">MDB_page</span>        *<span style="color: #eedd82;">me_dpages</span>;             <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; list of malloc'd blocks for re-use */</span>
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">IDL of pages that became unused in a write txn */</span>
        <span style="color: #98fb98;">MDB_IDL</span>         <span style="color: #eedd82;">me_free_pgs</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">ID2L of pages written during a write txn. Length MDB_IDL_UM_SIZE. */</span>
        <span style="color: #98fb98;">MDB_ID2L</span>        <span style="color: #eedd82;">me_dirty_list</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Max number of freelist items that can fit in a single overflow page */</span>
        <span style="color: #98fb98;">int</span>                     <span style="color: #eedd82;">me_maxfree_1pg</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Max size of a node on a page */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>    <span style="color: #eedd82;">me_nodemax</span>;
<span style="color: #b0c4de;">#if</span> !(MDB_MAXKEYSIZE)
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>    <span style="color: #eedd82;">me_maxkey</span>;      <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; max size of a key */</span>
<span style="color: #b0c4de;">#endif</span>
        <span style="color: #98fb98;">int</span>             <span style="color: #eedd82;">me_live_reader</span>;         <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; have liveness lock in reader table */</span>
<span style="color: #b0c4de;">#       define</span>          <span style="color: #eedd82;">me_rmutex</span>       me_txns-&gt;mti_rmutex <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; Shared reader lock */</span>
<span style="color: #b0c4de;">#       define</span>          <span style="color: #eedd82;">me_wmutex</span>       me_txns-&gt;mti_wmutex <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; Shared writer lock */</span>
        <span style="color: #98fb98;">void</span>            *<span style="color: #eedd82;">me_userctx</span>;     <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; User-settable context */</span>
        <span style="color: #98fb98;">MDB_assert_func</span> *<span style="color: #eedd82;">me_assert_func</span>; <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; Callback for assertion failures */</span>
};
</pre>
</div>

<ul class="org-ul">
<li><code>me_rmutext</code> ， <code>me_wmutex</code> : 锁表互斥所，lmdb可以支持多线程、多进程。多进程之间的同步访问通过系统级的互斥来达到。其mutex本身存在于系统的共享内存当中而非进程本身的内存，因此在进行读写页面时，首先访问锁表看看对应的资源是否有别的进程、线程在进行，有的话需要根据事务规则要求进行排队等待。
</li>
<li><code>me_txn</code>, <code>me_txns</code>: 目前环境中使用的事务列表，一个env对象归属于一个进程，一个进程可能有多个线程使用同一个env，每个线程可以开启一个事务，因此在一个进程级的env对象需要维护txn列表以了解目前多少个线程及事务在进行工作。
</li>
<li>me<sub>flags</sub>: 标志,标志控制的数据库的许多行为，每次使用env之前必须设置，应用程序应该用一致的方式使用flags，否则数据库可能会出现不可预知的错误。
</li>
<li>me<sub>dbxs</sub>: 数据库对象
</li>
</ul>


<ol class="org-ol">
<li><code>MDB_envinfo</code>
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MDB_envinfo</span> {
        <span style="color: #98fb98;">void</span>    *<span style="color: #eedd82;">me_mapaddr</span>;                    <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; Address of map, if fixed */</span>
        <span style="color: #98fb98;">mdb_size_t</span>      <span style="color: #eedd82;">me_mapsize</span>;                             <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; Size of the data memory map */</span>
        <span style="color: #98fb98;">mdb_size_t</span>      <span style="color: #eedd82;">me_last_pgno</span>;                   <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; ID of the last used page */</span>
        <span style="color: #98fb98;">mdb_size_t</span>      <span style="color: #eedd82;">me_last_txnid</span>;                  <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; ID of the last committed transaction */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">me_maxreaders</span>;             <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; max reader slots in the environment */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">me_numreaders</span>;             <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; max reader slots used in the environment */</span>
} <span style="color: #98fb98;">MDB_envinfo</span>;
</pre>
</div>

<ol class="org-ol">
<li><code>MDB_meta</code>
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++">        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Meta page content.</span>
<span style="color: #ff7f24;">         *      A meta page is the start point for accessing a database snapshot.</span>
<span style="color: #ff7f24;">         *      Pages 0-1 are meta pages. Transaction N writes meta page #(N % 2).</span>
<span style="color: #ff7f24;">         */</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MDB_meta</span> {
                <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Stamp identifying this as an LMDB file. It must be set</span>
<span style="color: #ff7f24;">                 *      to #MDB_MAGIC. */</span>
        <span style="color: #98fb98;">uint32_t</span>        <span style="color: #eedd82;">mm_magic</span>;
                <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Version number of this file. Must be set to #MDB_DATA_VERSION. */</span>
        <span style="color: #98fb98;">uint32_t</span>        <span style="color: #eedd82;">mm_version</span>;
        <span style="color: #98fb98;">void</span>            *<span style="color: #eedd82;">mm_address</span>;            <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; address for fixed mapping */</span>
        <span style="color: #98fb98;">pgno_t</span>          <span style="color: #eedd82;">mm_mapsize</span>;                     <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; size of mmap region */</span>
        <span style="color: #98fb98;">MDB_db</span>          <span style="color: #eedd82;">mm_dbs</span>[CORE_DBS];       <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; first is free space, 2nd is main db */</span>
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">The size of pages used in this DB */</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">mm_psize</span>        mm_dbs[FREE_DBI].md_pad
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Any persistent environment flags. @ref mdb_env */</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">mm_flags</span>        mm_dbs[FREE_DBI].md_flags
        <span style="color: #98fb98;">pgno_t</span>          <span style="color: #eedd82;">mm_last_pg</span>;                     <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; last used page in file */</span>
        <span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">txnid_t</span>        <span style="color: #eedd82;">mm_txnid</span>;       <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; txnid that committed this page */</span>
} <span style="color: #98fb98;">MDB_meta</span>;
</pre>
</div>

<ul class="org-ul">
<li>meta页面循环使用，即id为1，修改页面1，id为2，修改页面0.
</li>
<li><code>mm_dbs[CORE_DBS]</code> 数据库B+Tree根，同时保存两个: <code>FREE_DBI</code> 和
<code>MAIN_DBI</code>.
</li>

<li><code>MDB_page</code>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MDB_page</span> {
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">mp_pgno</span> mp_p.p_pgno
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">mp_next</span> mp_p.p_next
        <span style="color: #00ffff;">union</span> {
                <span style="color: #98fb98;">pgno_t</span>          <span style="color: #eedd82;">p_pgno</span>; <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; page number */</span>
                <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MDB_page</span> *<span style="color: #eedd82;">p_next</span>; <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; for in-memory list of freed pages */</span>
        } <span style="color: #eedd82;">mp_p</span>;
        <span style="color: #98fb98;">uint16_t</span>        <span style="color: #eedd82;">mp_pad</span>;
        <span style="color: #98fb98;">uint16_t</span>        <span style="color: #eedd82;">mp_flags</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; @ref mdb_page */</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">mp_lower</span>        mp_pb.pb.pb_lower
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">mp_upper</span>        mp_pb.pb.pb_upper
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">mp_pages</span>        mp_pb.pb_pages
        <span style="color: #00ffff;">union</span> {
                <span style="color: #00ffff;">struct</span> {
                        <span style="color: #98fb98;">indx_t</span>          <span style="color: #eedd82;">pb_lower</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; lower bound of free space */</span>
                        <span style="color: #98fb98;">indx_t</span>          <span style="color: #eedd82;">pb_upper</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; upper bound of free space */</span>
                } <span style="color: #eedd82;">pb</span>;
                <span style="color: #98fb98;">uint32_t</span>        <span style="color: #eedd82;">pb_pages</span>;       <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; number of overflow pages */</span>
        } <span style="color: #eedd82;">mp_pb</span>;
        <span style="color: #98fb98;">indx_t</span>          <span style="color: #eedd82;">mp_ptrs</span>[1];             <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; dynamic size */</span>
} <span style="color: #98fb98;">MDB_page</span>;
</pre>
</div>
<ul class="org-ul">
<li>page描述了不同页面的头。不管是树中的root、还是branch、leaf页面，都是用它描述。
</li>
<li>对于overflow页面来说，只有第一页使用头进行描述，其后的连续页面不使用，仅仅使用指针将页面关联起来.
</li>
<li><code>mp_flags</code>: 代表是什么类型的页面
</li>
<li><code>mp_pb</code>: overflow页数或者当前页的可用空间
</li>

<li><code>MDB_node</code>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MDB_node</span> {
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">lo and hi are used for data size on leaf nodes and for</span>
<span style="color: #ff7f24;">         * child pgno on branch nodes. On 64 bit platforms, flags</span>
<span style="color: #ff7f24;">         * is also used for pgno. (Branch nodes have no flags).</span>
<span style="color: #ff7f24;">         * They are in host byte order in case that lets some</span>
<span style="color: #ff7f24;">         * accesses be optimized into a 32-bit word access.</span>
<span style="color: #ff7f24;">         */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span>  <span style="color: #eedd82;">mn_lo</span>, <span style="color: #eedd82;">mn_hi</span>;   <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; part of data size or pgno */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span>  <span style="color: #eedd82;">mn_flags</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; @ref mdb_node */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span>  <span style="color: #eedd82;">mn_ksize</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; key size */</span>
        <span style="color: #98fb98;">char</span>            <span style="color: #eedd82;">mn_data</span>[1];                     <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; key and data are appended here */</span>
} <span style="color: #98fb98;">MDB_node</span>;
</pre>
</div>
<ul class="org-ul">
<li>node代表key/value对的描述，是对branch、leaf页中的数据的描述
</li>
<li><code>mn_flags</code>: 标志：是否重复、子数据库、overflow等
</li>
<li><code>mn_hi.lo</code>: 数据大小或者页码
</li>
<li><code>mn_data</code>: 数据指针
</li>

<li><code>MDB_db</code>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Information about a single database in the environment. */</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MDB_db</span> {
        <span style="color: #98fb98;">uint32_t</span>        <span style="color: #eedd82;">md_pad</span>;         <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; also ksize for LEAF2 pages */</span>
        <span style="color: #98fb98;">uint16_t</span>        <span style="color: #eedd82;">md_flags</span>;       <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; @ref mdb_dbi_open */</span>
        <span style="color: #98fb98;">uint16_t</span>        <span style="color: #eedd82;">md_depth</span>;       <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; depth of this tree */</span>
        <span style="color: #98fb98;">pgno_t</span>          <span style="color: #eedd82;">md_branch_pages</span>;        <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; number of internal pages */</span>
        <span style="color: #98fb98;">pgno_t</span>          <span style="color: #eedd82;">md_leaf_pages</span>;          <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; number of leaf pages */</span>
        <span style="color: #98fb98;">pgno_t</span>          <span style="color: #eedd82;">md_overflow_pages</span>;      <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; number of overflow pages */</span>
        <span style="color: #98fb98;">mdb_size_t</span>      <span style="color: #eedd82;">md_entries</span>;             <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; number of data items */</span>
        <span style="color: #98fb98;">pgno_t</span>          <span style="color: #eedd82;">md_root</span>;                <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; the root page of this tree */</span>
} <span style="color: #98fb98;">MDB_db</span>;
</pre>
</div>
<ul class="org-ul">
<li>mdb<sub>db描述了一颗单独的b</sub>+tree树，主要包含了一些相关的信息和根节点页码
</li>

<li><code>MDB_txn</code>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MDB_txn</span> {
        <span style="color: #98fb98;">MDB_txn</span>         *<span style="color: #eedd82;">mt_parent</span>;             <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; parent of a nested txn */</span>
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Nested txn under this txn, set together with flag #MDB_TXN_HAS_CHILD */</span>
        <span style="color: #98fb98;">MDB_txn</span>         *<span style="color: #eedd82;">mt_child</span>;
        <span style="color: #98fb98;">pgno_t</span>          <span style="color: #eedd82;">mt_next_pgno</span>;   <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; next unallocated page */</span>
        <span style="color: #98fb98;">txnid_t</span>         <span style="color: #eedd82;">mt_txnid</span>;
        <span style="color: #98fb98;">MDB_env</span>         *<span style="color: #eedd82;">mt_env</span>;                <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; the DB environment */</span>
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">The list of pages that became unused during this transaction.</span>
<span style="color: #ff7f24;">         */</span>
        <span style="color: #98fb98;">MDB_IDL</span>         <span style="color: #eedd82;">mt_free_pgs</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">The list of loose pages that became unused and may be reused</span>
<span style="color: #ff7f24;">         *      in this transaction, linked through #NEXT_LOOSE_PAGE(page).</span>
<span style="color: #ff7f24;">         */</span>
        <span style="color: #98fb98;">MDB_page</span>        *<span style="color: #eedd82;">mt_loose_pgs</span>;
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">#Number of loose pages (#mt_loose_pgs) */</span>
        <span style="color: #98fb98;">int</span>                     <span style="color: #eedd82;">mt_loose_count</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">The sorted list of dirty pages we temporarily wrote to disk</span>
<span style="color: #ff7f24;">         *      because the dirty list was full. page numbers in here are</span>
<span style="color: #ff7f24;">         *      shifted left by 1, deleted slots have the LSB set.</span>
<span style="color: #ff7f24;">         */</span>
        <span style="color: #98fb98;">MDB_IDL</span>         <span style="color: #eedd82;">mt_spill_pgs</span>;
        <span style="color: #00ffff;">union</span> {
                <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">For write txns: Modified pages. Sorted when not MDB_WRITEMAP. */</span>
                <span style="color: #98fb98;">MDB_ID2L</span>        <span style="color: #eedd82;">dirty_list</span>;
                <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">For read txns: This thread/txn's reader table slot, or NULL. */</span>
                <span style="color: #98fb98;">MDB_reader</span>      *<span style="color: #eedd82;">reader</span>;
        } <span style="color: #eedd82;">mt_u</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Array of records for each DB known in the environment. */</span>
        <span style="color: #98fb98;">MDB_dbx</span>         *<span style="color: #eedd82;">mt_dbxs</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Array of MDB_db records for each known DB */</span>
        <span style="color: #98fb98;">MDB_db</span>          *<span style="color: #eedd82;">mt_dbs</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Array of sequence numbers for each DB handle */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>    *<span style="color: #eedd82;">mt_dbiseqs</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">In write txns, array of cursors for each DB */</span>
        <span style="color: #98fb98;">MDB_cursor</span>      **<span style="color: #eedd82;">mt_cursors</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Array of flags for each DB */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span>   *<span style="color: #eedd82;">mt_dbflags</span>;
        <span style="color: #ff7f24;">/**     </span><span style="color: #ff7f24;">Number of DB records in use, or 0 when the txn is finished.</span>
<span style="color: #ff7f24;">         *      This number only ever increments until the txn finishes; we</span>
<span style="color: #ff7f24;">         *      don't decrement it when individual DB handles are closed.</span>
<span style="color: #ff7f24;">         */</span>
        <span style="color: #98fb98;">MDB_dbi</span>         <span style="color: #eedd82;">mt_numdbs</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>    <span style="color: #eedd82;">mt_flags</span>;               <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; @ref mdb_txn */</span>
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">#dirty_list room: Array size - \#dirty pages visible to this txn.</span>
<span style="color: #ff7f24;">         *      Includes ancestor txns' dirty pages not hidden by other txns'</span>
<span style="color: #ff7f24;">         *      dirty/spilled pages. Thus commit(nested txn) has room to merge</span>
<span style="color: #ff7f24;">         *      dirty_list into mt_parent after freeing hidden mt_parent pages.</span>
<span style="color: #ff7f24;">         */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>    <span style="color: #eedd82;">mt_dirty_room</span>;
};
</pre>
</div>
<ul class="org-ul">
<li><code>mdb_txn</code> 描述了数据库的事务结构,mdb中的事务支持嵌套事务。支持完全ACID
属性，但是只支持serializable事务隔离级别,通过同一个env对应的数据库只允许一个事务写来控制。
</li>
<li><code>mt_child,parent</code> ：事务嵌套父子关系
</li>
<li><code>mt_cursor</code> : 写事务中每个数据库中已经打开的游标。
</li>

<li><code>MDB_cursor</code>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MDB_cursor</span> {
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Next cursor on this DB in this txn */</span>
        <span style="color: #98fb98;">MDB_cursor</span>      *<span style="color: #eedd82;">mc_next</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Backup of the original cursor if this cursor is a shadow */</span>
        <span style="color: #98fb98;">MDB_cursor</span>      *<span style="color: #eedd82;">mc_backup</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">Context used for databases with #MDB_DUPSORT, otherwise NULL */</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MDB_xcursor</span>      *<span style="color: #eedd82;">mc_xcursor</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">The transaction that owns this cursor */</span>
        <span style="color: #98fb98;">MDB_txn</span>         *<span style="color: #eedd82;">mc_txn</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">The database handle this cursor operates on */</span>
        <span style="color: #98fb98;">MDB_dbi</span>         <span style="color: #eedd82;">mc_dbi</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">The database record for this cursor */</span>
        <span style="color: #98fb98;">MDB_db</span>          *<span style="color: #eedd82;">mc_db</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">The database auxiliary record for this cursor */</span>
        <span style="color: #98fb98;">MDB_dbx</span>         *<span style="color: #eedd82;">mc_dbx</span>;
        <span style="color: #ff7f24;">/** </span><span style="color: #ff7f24;">The @ref mt_dbflag for this database */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span>   *<span style="color: #eedd82;">mc_dbflag</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span>  <span style="color: #eedd82;">mc_snum</span>;        <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; number of pushed pages */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span>  <span style="color: #eedd82;">mc_top</span>;         <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; index of top page, normally mc_snum-1 */</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>    <span style="color: #eedd82;">mc_flags</span>;       <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; @ref mdb_cursor */</span>
        MDB_page        *mc_pg[CURSOR_STACK];   <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; stack of pushed pages */</span>
        <span style="color: #98fb98;">indx_t</span>          <span style="color: #eedd82;">mc_ki</span>[CURSOR_STACK];    <span style="color: #ff7f24;">/**</span><span style="color: #ff7f24;">&lt; stack of page indices */</span>
};
</pre>
</div>
<ul class="org-ul">
<li>游标对象是进行所有数据库操作的对象，读写都是基于游标进行。进行读写操作时，首先需要根据条件确定页面位置，从而获得一个游标，应用程序根据游标对象操作数据库。
</li>
<li><code>mc_next</code>: 同一个事务中关于同一个db的游标组成一个列表。next指向下一个游标
</li>
<li><code>mc_top</code>: 最上层页面id
</li>
<li><code>mc_xcursor</code>: 用于key可重复b+tree。
</li>
<li><code>mc_pg</code>: cursor打开的页面组成一个堆栈
</li>
<li><code>mc_ki</code>:  打开页面的索引的堆栈
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">cc</h2>
<div class="outline-text-2" id="text-9">
<div class="org-src-container">

<pre class="src src-c++"></pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://blog.csdn.net/joejames/article/details/37958017">http://blog.csdn.net/joejames/article/details/37958017</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="http://blog.csdn.net/hbhhww/article/details/8206846">http://blog.csdn.net/hbhhww/article/details/8206846</a>
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
<a href="http://gridmix.blog.51cto.com/4764051/1698055">http://gridmix.blog.51cto.com/4764051/1698055</a>
</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2016-04-26 Tue 22:39</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
