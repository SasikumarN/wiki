<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Analyze Linux kernel crashes on the MIPS platform</title>
<!-- 2017-01-24 Tue 21:56 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Analyze Linux kernel crashes on the MIPS platform</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Introduction</a></li>
<li><a href="#sec-2">Tools</a></li>
<li><a href="#sec-3">Format of a crash report</a></li>
<li><a href="#sec-4">Analysis</a>
<ul>
<li><a href="#sec-4-1">Simple crash to learn the basics</a></li>
<li><a href="#sec-4-2">Crash in a binary kernel module</a></li>
<li><a href="#sec-4-3">Suspected memory corruption</a></li>
</ul>
</li>
<li><a href="#sec-5">Extra Details</a>
<ul>
<li><a href="#sec-5-1">objdump</a></li>
<li><a href="#sec-5-2">Calling conventions</a></li>
<li><a href="#sec-5-3">Virtual Memory Layout on MIPS</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Introduction<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup></h2>
<div class="outline-text-2" id="text-1">
<p>
The aim of this post is to illustrate the analysis of Linux kernel
crashes by studying a few real-life examples. The examples are coming
from a MIPS platform, but the general approach is applicable to other
architectures.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Tools</h2>
<div class="outline-text-2" id="text-2">
<p>
Any general purpose disassembler is sufficient. We'll use objdump with
'-d' option here.
</p>

<p>
If a binary was built with debugging information, objdump -S can
display source code intermixed with disassembly <a href="#objdump">1</a>. Also, <a href="http://www.linuxcommand.org/man_pages/addr2line1.html">addr2line</a>
can be used to match addresses with source code file names and lines.
</p>

<p>
In order to interpret disassembly, we need to have the <a href="http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html">MIPS
Instruction Reference</a> and the <a href="https://en.wikipedia.org/wiki/MIPS_architecture#Compiler_register_usage">Compiler Register Usage information</a> at
hand <a href="#calling_convent">2</a>, so please keep these pages open while reading further material.
</p>

<p>
If you are not familiar with how the virtual memory space is divided
on MIPS, please refer to 'Virtual Memory Layout' <a href="#virtual_mem">3</a> in the last
section.
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Format of a crash report</h2>
<div class="outline-text-2" id="text-3">
<p>
Here is an example of a crash report:
</p>
<div class="org-src-container">

<pre class="src src-sh">CPU 0 Unable to handle kernel paging request at virtual address 00000000, <span style="color: #eedd82;">epc</span> == 8023afd0, <span style="color: #eedd82;">ra</span> == 8023b024
Oops[#1]:
Cpu 0
$ 0 : 00000000 1000fc00 8555fc54 00000000
$ 4 : 00000000 00000000 0000000b 00000001
$ 8 : 00000008 800445f4 00000000 00000000
$<span style="color: #eedd82;">12</span> : 0000004f 0000004e 00000041 00000001
$<span style="color: #eedd82;">16</span> : 00000000 8555fc54 0000000b 8555fc54
$<span style="color: #eedd82;">20</span> : c01eded0 8555fbd0 80240000 7f7ff0c4
$<span style="color: #eedd82;">24</span> : 00000002 c01d6edc
$<span style="color: #eedd82;">28</span> : 8555e000 8555fab0 7f7ff0a0 8023b024
Hi : 00000000
Lo : 3b9aca00
epc : 8023afd0 strlen+0x0/0x28
    Tainted: PF
ra : 8023b024 strlcpy+0x2c/0x7c
Status: 1000fc04 IEp
Cause : 00000008
BadVA : 00000000
PrId : 0000c401 (Fusiv MIPS1)
Modules linked<span style="color: #00ffff;"> in</span>: xt_CLASSIFY [ skipped proprietary (aka evil) modules ] ip6_tunnel tunnel6
Process controllerd (pid: 751, <span style="color: #eedd82;">threadinfo</span>=8555e000, <span style="color: #eedd82;">task</span>=8783add8, <span style="color: #eedd82;">tls</span>=00000000)
Stack : 1000fc01 7f7ff0d0 8008f4a4 7f7ff268 8555fc5f 8555fc54 8023aff8 80044500
    c01d6cc8 c01d6ab8 000000a4 7f7ff0c4 00000000 80050000 00000000 c026ca78
    c026ca78 8555fb18 8555fbd0 7f7ff0d0 7f7ff174 7f7ff0d0 7f7ff0c0 86458400
    000000a4 c01d4440 80631224 8026d168 87008838 8026ca84 00000000 00000001
    00000006 00000001 80631224 806312c0 1000fc01 fffffffe 805e5778 805e0000
...
Call Trace:
[&lt;8023afd0&gt;] strlen+0x0/0x28
[&lt;8023b024&gt;] strlcpy+0x2c/0x7c
[&lt;c01d6cc8&gt;] contoller_get_info+0x2c4/0x37c [controller_lkm]
[&lt;c01d4440&gt;] controller_init+0x3e0/0xa64 [controller_lkm]

Code: 00000000  03e00008  01031023 &lt;80820000&gt; 0808ebfa  00801821 24630001  80620000  00000000
</pre>
</div>

<p>
Let's review the parts one by one.
</p>
<div class="org-src-container">

<pre class="src src-sh">CPU 0 Unable to handle kernel paging request at virtual address 00000000, <span style="color: #eedd82;">epc</span> == 8023afd0, <span style="color: #eedd82;">ra</span> == 8023b024
Oops[#1]:
</pre>
</div>
<p>
A header indicates a particular reason for this crash.
</p>

<p>
On CPU #0 a load or store instruction at address epc accessed a
virtual address <code>0x00000000</code>. There was no valid virtual to physical
address translation available - hence, the crash. In the middle of the
report the same virtual address is shown as:
</p>
<div class="org-src-container">

<pre class="src src-sh">BadVA : 00000000
</pre>
</div>

<p>
<code>BadVA</code> is a <b>register</b> of the MIPS Coprocessor 0 that describes a
memory address at which address exception occurred.
</p>
<div class="org-src-container">

<pre class="src src-sh">Unable to handle kernel paging request
</pre>
</div>
<p>
is by far one of the most common reasons for crashes. You may also
encounter:
</p>
<div class="org-src-container">

<pre class="src src-sh">Kernel bug detected
</pre>
</div>

<p>
It is triggered by one of the sanity checks in the kernel code, such
as <code>BUG()</code> or <code>BUG_ON(condition)</code>. This mechanism does what <code>assert()</code> does
for user-space applications.
</p>

<p>
Other reasons can be found by running <code>grep -rn die_if_kernel
arch/mips/</code> in a Linux kernel tree.
</p>

<p>
Further, the content of the registers is displayed.
</p>
<div class="org-src-container">

<pre class="src src-sh">$ 0   : 00000000 1000fc00 8555fc54 00000000
$ 4   : 00000000 00000000 0000000b 00000001
[ ... ]
$<span style="color: #eedd82;">24</span>   : 00000002 c01d6edc
$<span style="color: #eedd82;">28</span>   : 8555e000 8555fab0 7f7ff0a0 8023b024
Hi    : 00000000
Lo    : 3b9aca00
[ ... ]
Status: 1000fc04    IEp
Cause : 00000008
</pre>
</div>

<p>
Registers <code>$0-31</code> are general purpose <a href="https://en.wikipedia.org/wiki/MIPS_instruction_set#Compiler_register_usage">MIPS registers</a>. To simplify
reading, each of them has a mnemonic name in assembler code. Now it's
time to take a quick look at <a href="https://en.wikipedia.org/wiki/MIPS_instruction_set#Compiler_register_usage">Compiler Register Usage</a>. For example,
a0-3 correspond to <code>$4-7</code>, which are used in the <a href="https://en.wikipedia.org/wiki/Calling_convention#MIPS">o32 calling convention</a>
to pass the first 4 arguments to a function. <code>o32</code> is the most commonly
used calling convention on 32bit MIPS <a href="#calling_convent">2</a> and our examples here relate
to it.
</p>

<p>
An ideal case is to have a complete dump of the memory used by the
kernel. That would allow us to restore the environment - to see the
content of local variables, various kernel data structures, etc. <a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/kdump/kdump.txt?id=f4ba394c1b02e7fc2179fda8d3941a5b3b65efb6">Kdump</a>
can do this (no MIPS support at the moment). Nevertheless, in many
cases the content of the registers alone reveals enough information to
understand a problem.
</p>

<p>
The content of <a href="http://www.doc.ic.ac.uk/lab/secondyear/spim/node10.html">Status and Cause registers</a> may be very useful in some cases, but we won't consider them here.
</p>
<div class="org-src-container">

<pre class="src src-sh">epc   : 8023afd0 strlen+0x0/0x28
ra    : 8023b024 strlcpy+0x2c/0x7c
</pre>
</div>

<p>
<code>epc</code> shows the address of the instruction that caused a crash. <code>ra ($31)</code>
contains the <b>return address</b> from the last function called prior to a
crash. In practice, <code>ra</code> usually points either to a caller of the
function where <code>epc</code> belongs to or to the same function as <code>epc</code>. An
invalid address in <code>ra</code> can indicate stack corruption (at least for
non-leaf functions).
</p>

<p>
Names of the functions where <code>epc</code> and <code>ra</code> belong to are displayed if the
kernel was built with <code>CONFIG_KALLSYMS</code> enabled. In any case, these
names can be located with <code>objdump</code>.
</p>

<p>
The <code>+0x0/0x28</code> notation stands for <code>+offset/size</code>, where <code>offset</code> is the
offset of the instruction within a function it belongs to, and <code>size</code> is
the size of this function.
</p>

<p>
In most cases, <code>ra</code> points to the 2nd instruction that follows an
instruction representing a function call (usually <code>jal</code> or <code>jalr</code>). For
example,
</p>
<div class="org-src-container">

<pre class="src src-sh">801f9bb8 &lt;pci_bus_read_config_byte&gt;:
  [...]
  801f9c14:       02202821        move    a1,s1
  801f9c18:       0040f809        jalr    v0
  801f9c1c:       24070001        li      a3,1
  801f9c20:       00408021        move    s0,v0
  801f9c24:       8fa20018        lw      v0,24(sp)
</pre>
</div>
<p>
A function call is at <code>0x801f9c18</code>. Control gets back to
<code>pci_bus_read_config_byte</code> at <code>0x801f9c20</code>. <code>jalr</code> saves this address into
<code>ra</code> before jumping to an address <code>v0</code> - <b>the start of a called
function</b>.
</p>

<p>
The instruction at <code>0x801f9c1c</code> is located in the <b>delay slot</b> of <code>jalr</code> and
is executed before any instruction in the called function. Delay slots
of <code>jalr</code> are often used to initialize one of the function arguments. If
the called function above has at least 4 arguments, its 4th argument
will be <code>1</code>.
</p>

<p>
Branch instructions, like <code>bltz</code> (branch on less than zero), are another
example of instructions with delay slots.
</p>

<p>
We mentioned earlier that both <code>epc</code> and <code>ra</code> may point to the same
function. To illustrate this case, let's suppose that a crash occurs
at <code>0x801f9c24</code> in the above disassembly. Provided that a function call
at <code>0x801f9c18</code> took place, <code>ra</code> would point to <code>0x801f9c20</code> inside the same
function as <code>epc</code>.
</p>
<div class="org-src-container">

<pre class="src src-sh">Modules linked<span style="color: #00ffff;"> in</span>: xt_CLASSIFY [ ... ] ip6_tunnel tunnel6
</pre>
</div>
<p>
This is a list of loaded kernel modules.
</p>
<div class="org-src-container">

<pre class="src src-sh">Process controllerd (pid: 751, <span style="color: #eedd82;">threadinfo</span>=8555e000, <span style="color: #eedd82;">task</span>=8783add8, <span style="color: #eedd82;">tls</span>=00000000)
</pre>
</div>
<p>
This is information about a process that was running at the moment of a crash.
</p>

<p>
In an ideal world where kernels and, especially, kernel modules behave
well, user-space actions can never trigger a kernel crash. No matter
what these actions are. Kernel-mode tasks have full privileges to
cause havoc though.
</p>

<p>
A user-space task appears here in one of the following cases:
</p>
<ul class="org-ul">
<li>it has triggered a kernel action (usually via a system call like
<code>ioctl()</code>) that, due to a kernel bug or memory corruption, results in
a crash.
</li>
<li>a crash has occurred in the interrupt context. Unless your kernel
supports threaded interrupt handlers (i.e. interrupts are handled by
dedicated threads) or separate interrupt stacks, the kernel-space
stack of a current task is used by the interrupt handling code. The
displayed task is usually unrelated in this case.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">Stack : 1000fc01 7f7ff0d0 8008f4a4 7f7ff268 8555fc5f 8555fc54 8023aff8 80044500
        [ ... ]
        00000006 00000001 80631224 806312c0 1000fc01 fffffffe 805e5778 805e0000
       ...
</pre>
</div>
<p>
This is a partial dump of the kernel-space stack of the current task,
which we have discussed in the previous section.
</p>

<div class="org-src-container">

<pre class="src src-sh">Call Trace:
  [&lt;8023afd0&gt;] strlen+0x0/0x28
  [&lt;8023b024&gt;] strlcpy+0x2c/0x7c
  [&lt;c01d6cc8&gt;] controller_get_info+0x2c4/0x37c [controller_lkm]
  [&lt;c01d4440&gt;] controller_init+0x3e0/0xa64 [controller_lkm]
  [ ... ]
</pre>
</div>
<p>
As the name suggests, this is a <b>call trace</b>.
</p>

<p>
It does not always represent a genuine call trace though. When <code>epc</code>
points to an invalid address on MIPS or <code>raw_show_trace</code> is enabled in
the kernel command line, the so-called raw call trace is displayed. It
contains all the values from stack that look like valid return
addresses. So there can be 'ghost' traces of previously run and
completely unrelated functions. For curious readers, the
implementation of both methods is in <code>show_backtrace()</code> and
<code>show_raw_backtrace()</code> in <code>arch/mips/kernel/traps.c</code>.
</p>
<div class="org-src-container">

<pre class="src src-sh">Code: 00000000  03e00008  01031023 &lt;80820000&gt; 0808ebfa  00801821 24630001  80620000  00000000
</pre>
</div>

<p>
Finally, this last section displays a sequence of instructions (binary
representation) at and around <code>epc</code>, with the instruction at <code>epc</code> being
indicated by &lt;&gt; symbols.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Analysis</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Simple crash to learn the basics</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Let's now analyze the crash that was used as an example in the
previous section.
</p>
<div class="org-src-container">

<pre class="src src-sh">CPU 0 Unable to handle kernel paging request at virtual address 00000000, <span style="color: #eedd82;">epc</span> == 8023afd0, <span style="color: #eedd82;">ra</span> == 8023b024
[...]
epc   : 8023afd0 strlen+0x0/0x28
ra    : 8023b024 strlcpy+0x2c/0x7c
</pre>
</div>

<p>
The kernel was built with <code>CONFIG_KALLSYMS</code> enabled, and that allows us
to see the names of functions where the instruction at <code>epc</code> and <code>ra</code>
belong to. If it was not the case, we may note that both <code>epc</code> and <code>ra</code>
belong to <code>kseg0</code> <a href="#virtual_mem">3</a>, so we may expect to find them inside the kernel
image (<code>vmlinux</code>).
</p>

<p>
A quick sanity check for ra (recall that property of <code>ra</code> we mentioned
above):
</p>

<div class="org-src-container">

<pre class="src src-sh">8023aff8 &lt;strlcpy&gt;:
 [...]
 8023b018:       afbf0020        sw      ra,32(sp)
 8023b01c:       0c08ebf4        jal     8023afd0 &lt;strlen&gt;
 8023b020:       00a08021        move    s0,a1
 8023b024:       00408821        move    s1,v0                  &lt;=== <span style="color: #ffa07a;">'ra'</span> points to this location
 [...]
</pre>
</div>

<p>
<code>ra</code> is indeed one instruction away (delay slot) from <code>jal</code>. It's also
clear that a function being called is <code>strlen()</code>. In cases when the
address of a called function is not known at build time (kernel
modules), disassembly may look as follows:
</p>
<div class="org-src-container">

<pre class="src src-sh">b6d38:        3c020000        lui     v0,0x0
b6d3c:        24420000        addiu   v0,v0,0
b6d40:        0040f809        jalr    v0
</pre>
</div>
<p>
The first 2 instructions are changed by the loader at run time. In
such cases, don't get confused when disassembly and the Code: sequence
of a crash dump display different instructions at the same address.
Usually, there is a remote resemblance though. For instance, the
instructions above might have been changed as follows:
</p>
<div class="org-src-container">

<pre class="src src-sh">b6d38:        3c02804a        lui     v0,0x804a
b6d3c:        2442346c        addiu   v0,v0,13420
</pre>
</div>
<p>
This basically corresponds to <code>v0 = 0x804a346c</code>.
</p>

<p>
For <code>epc</code>,
</p>
<div class="org-src-container">

<pre class="src src-sh">8023afd0 &lt;strlen&gt;:
8023afd0:       80820000        lb      v0,0(a0)               &lt;=== <span style="color: #ffa07a;">'epc'</span> is here
8023afd4:       0808ebfa        j       8023afe8 &lt;strlen+0x18&gt;

8023afd8:       00801821        move    v1,a0
8023afdc:       24630001        addiu   v1,v1,1
[...]
</pre>
</div>
<p>
we may make the following observations:
</p>
<ul class="org-ul">
<li>it's indeed the first instruction (<code>offset 0x0</code>) of <code>strlen()</code>;
</li>
<li><code>a0 ($4)</code> is indeed 0. The instruction at <code>epc</code> loads a byte from
address <code>MEM[a0 + 0]</code> and <code>BadVA</code> is reported to be 0. Hence, <code>a0</code> should
have been 0 too.
<div class="org-src-container">

<pre class="src src-sh">$ 4   : 00000000 [...]
</pre>
</div>
</li>
<li>The instructions from disassembly match the ones shown in the Code:
sequence.
<div class="org-src-container">

<pre class="src src-sh">Code: [...] &lt;80820000&gt; 0808ebfa  00801821 24630001  80620000  00000000
</pre>
</div>
</li>
</ul>
<p>
These checks can be also applied as sanity checks to ensure you have
got the right image for disassembly.
</p>

<p>
Now, <code>a0</code> is supposed to hold the 1st (and only) argument of <code>strlen()</code>
<a href="https://en.wikipedia.org/wiki/MIPS_instruction_set#Compiler_register_usage">Compiler Register Usage</a>. Given that <code>epc</code> points to the 1st
instruction, <code>a0</code> has not yet been reused for anything else inside
<code>strlen()</code>. This can be verified by analyzing an instructions flow. The
current working hypothesis is that <code>strlen(s)</code> has been called with 
<code>s == NULL</code>.
</p>

<p>
Let's see if we can figure out where this <code>s == NULL</code> is coming from by
examining the caller of <code>strlen - strlcpy()</code>. But before doing so, we
should consider a few more aspects common to all functions.
</p>

<p>
At the beginning of most of the functions, there is a sequence of
instruction called "prologue". For example,
</p>
<div class="org-src-container">

<pre class="src src-sh">800a28d0 &lt;vfs_write&gt;:
800a28d0:       27bdffd0        addiu   sp,sp,-48
800a28d4:       afb30024        sw      s3,36(sp)
800a28d8:       afb20020        sw      s2,32(sp)
800a28dc:       afb1001c        sw      s1,28(sp)
800a28e0:       afb00018        sw      s0,24(sp)
800a28e4:       afbf0028        sw      ra,40(sp)
[...]
</pre>
</div>
<p>
The first instruction creates a stack frame by reserving space on the
stack. As per <a href="https://en.wikipedia.org/wiki/Calling_convention#MIPS">o32</a> calling convention, it's a job of a called function
to preserve non-temporaries registers (like <code>$s-registers</code>) if they are
to be reused. This is what those <code>sw $reg, off(sp)</code> instructions are
concerned with - saving to-be-reused-registers to the stack. Same
applies to <code>ra</code> for non-leaf functions (those calling other functions).
Obviously, local variables also reside on this stack frame.
</p>

<p>
An "epilogue" sequence does the opposite actions.
</p>
<div class="org-src-container">

<pre class="src src-sh">800a2908:       8fbf0028        lw      ra,40(sp)
800a290c:       8fb30024        lw      s3,36(sp)
800a2910:       8fb20020        lw      s2,32(sp)
800a2914:       8fb1001c        lw      s1,28(sp)
800a2918:       8fb00018        lw      s0,24(sp)
800a291c:       03e00008        jr      ra
800a2920:       27bd0030        addiu   sp,sp,48
</pre>
</div>
<p>
The content of reused registers is restored. The stack frame is
deleted - usually, by the last instruction in a delay slot of <code>jr</code>.
Finally, control is given back to the caller by <code>jr ra</code>.
</p>

<p>
Stack corruptions may overwrite a value corresponding to <code>ra</code>, resulting
in the control being given to unexpected places (unless this is a
result of a deliberate security attack). This is likely to result in
"<code>Unable to handle kernel paging request</code>", "<code>Unaligned access</code>" , or
"<code>Invalid instruction</code>". Quite often in such cases <code>epc</code> is equal to <code>ra</code>
(or close to it) or to both <code>ra</code> and <code>BadVA</code>.
</p>

<p>
"Epilogue" is not necessarily placed at the very end of a function.
Moreover, a function may have more than one "epilogue".
</p>

<p>
One more thing before we get back to the analysis. Function calls look
as follows:
</p>
<div class="org-src-container">

<pre class="src src-sh">800a2aa0:       00c03821        move    a3,a2
800a2aa4:       00002021        move    a0,zero
800a2aa8:       02202821        move    a1,s1
800a2aac:       0c028848        jal     800a2120 &lt;rw_verify_area&gt;
800a2ab0:       02603021        move    a2,s3
</pre>
</div>
<p>
this sequence corresponds to <code>rw_verify_area(a0, a1, a2, a3)</code> with <code>a0</code>
being 0 (zero is register <code>$0</code>). The instructions initializing <code>a0-a3</code> do
not have to be placed immediately next to the <code>jal</code> instruction, but
usually they are in some proximity.
</p>

<p>
The return value of a function, if any, is stored in <code>v0 ($2)</code>.
</p>

<p>
Let's get back to our analysis.
</p>
<div class="org-src-container">

<pre class="src src-sh">8023aff8 &lt;strlcpy&gt;:
 8023aff8:       27bdffd8        addiu   sp,sp,-40
 8023affc:       afb3001c        sw      s3,28(sp)
 8023b000:       00809821        move    s3,a0
 8023b004:       00a02021        move    a0,a1                    &lt;=== the argument for strlen()
 8023b008:       afb20018        sw      s2,24(sp)
 8023b00c:       afb10014        sw      s1,20(sp)
 8023b010:       afb00010        sw      s0,16(sp)
 8023b014:       00c09021        move    s2,a2
 8023b018:       afbf0020        sw      ra,32(sp)
 8023b01c:       0c08ebf4        jal     8023afd0 &lt;strlen&gt;        &lt;=== the call is here
 8023b020:       00a08021        move    s0,a1
 8023b024:       00408821        move    s1,v0                    &lt;=== <span style="color: #ffa07a;">'ra'</span> points here
 [...]
</pre>
</div>

<p>
<code>strlen()</code> accepts a single argument that is passed via <code>a0</code>. A few
instructions above the actual call (see remarks) - at <code>0x8023b004</code>, we
can see that <code>a0</code> is being loaded with the content of <code>a1</code>. After
examining the remaining instructions it becomes clear that <code>a1</code> still
holds its initial value that corresponds to the 2nd argument of
<code>strlcpy(dst, src, len)</code>.
</p>

<p>
Now we can update our working hypothesis. It looks like <code>strlcpy()</code> has
been called with its 2nd argument, <code>src</code>, being <code>NULL</code>.
</p>

<p>
Real-life shortcut: we may simply examine the source code of <code>strlcpy()</code>
and notice that there is a single call to <code>strlen()</code>. This is in
accordance with our hypothesis indeed.
</p>
<div class="org-src-container">

<pre class="src src-sh">size_t strlcpy(char *dest, const char *src, size_t size)
{
        size_t <span style="color: #eedd82;">ret</span> = strlen(src);
[...]
</pre>
</div>

<p>
What's next? We can do the same analysis for <code>contoller_get_info()</code> that
has supposedly called <code>strlcpy()</code>.
</p>
<div class="org-src-container">

<pre class="src src-sh">Call Trace:
[&lt;8023afd0&gt;] strlen+0x0/0x28
[&lt;8023b024&gt;] strlcpy+0x2c/0x7c
[&lt;c01d6cc8&gt;] controller_get_info+0x2c4/0x37c [controller_lkm]
[...]
</pre>
</div>

<p>
Recall the remarks above regarding the validity of call traces. Basic
sanity checks won't take much time. At the very least, check that
<code>0xc01d6cc8</code> could have been a valid ra (one instruction away from
<code>jalr/jal</code>). If it is the case, verify the code of (in this example)
<code>controller_get_info()</code> to confirm that it does call <code>strlcpy()</code>. Having
disassembly intermixed with source code is helpful here.
</p>

<p>
In any case, there is obviously a limit as to how far "in the past" we
would be able to look by analyzing a crash report even if we had a
complete memory dump. Nevertheless, the results of this analysis - if
not sufficient to reveal a root cause - are usually very helpful in
further debugging. As to this particular example, we would still need
to analyze <code>controller_get_info()</code> to understand why <code>strlcpy()</code> might
have been called with <code>src == NULL</code>.
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Crash in a binary kernel module</h3>
<div class="outline-text-3" id="text-4-2">
<p>
This crash occurred in a kernel module for which no source code is
available.
</p>
<div class="org-src-container">

<pre class="src src-sh">CPU 1 Unable to handle kernel paging request at virtual address 00000000, <span style="color: #eedd82;">epc</span> == c1c52470, <span style="color: #eedd82;">ra</span> == c1c63d64
  [...]
  $ 0   : 00000000 10008d00 c1c523f0 00000000
  $ 4   : 00000000 c1f18f5c 0000008c ffff00fe
  $ 8   : 80008fe1 15941794 8e038b00 fefe7dfd
  $<span style="color: #eedd82;">12</span>   : faf9fdfe 7dfffe7f fb7eff7d 7b7e7e7c
  $<span style="color: #eedd82;">16</span>   : 00000000 00000800 c1e2d178 c1e2cf98
  $<span style="color: #eedd82;">20</span>   : 842ffe08 c1e2d1b4 00000050 c1c51fc0
  $<span style="color: #eedd82;">24</span>   : 00000000 00000000
  $<span style="color: #eedd82;">28</span>   : 842fc000 842ffdf0 00000000 c1c63d64
  [...]
  epc   : c1c52470 fast_memcpy+0x80/0x1cc [binary_blob_module]
      Tainted: P
  ra    : c1c63d64 net_egress+0x80/0x2b78 [binary_blob_module]
  [...]
</pre>
</div>

<p>
The load address of a kernel module is not known at build time, so we
see relative addresses in the disassembly of <code>binary_blob_module</code>. We
can use '<code>+0x80/0x1cc</code>' to locate the instruction at <code>epc</code>:
</p>
<div class="org-src-container">

<pre class="src src-sh">a53f0 &lt;fast_memcpy&gt;: 
 [...]
 a5468:       98ab000f        lwr     t3,15(a1)
 a546c:       98af001f        lwr     t7,31(a1)
 a5470:       a8880000        swl     t0,0(a0)      &lt;== <span style="color: #ffa07a;">'epc'</span> points here at offset 0x80
</pre>
</div>

<p>
The instruction at <code>epc</code> accesses <code>MEM[a0 + 0]</code>, so a0 should have been 0
to result in a memory access at <b>virtual address</b> <code>0x00000000</code>. We can
confirm this by verifying the content of the <code>a0 ($4)</code> register:
</p>
<div class="org-src-container">

<pre class="src src-sh">$ 4   : 00000000 [...]
</pre>
</div>

<p>
Next step is to examine the flow of instructions to trace the source
of the value in <code>a0</code>. A full listing is not provided here, but what it
revealed is that <code>a0</code> is used read-only. At <code>epc</code> it still holds the 1st
input argument of the function. Moreover, there are no explicit
validity checks prior to its use. Thus, the 1st argument is expected
to be a valid address.
</p>

<p>
The name of function, <code>fast_memcpy()</code>, suggests its memcpy-like nature,
so the 1st argument is likely to be dst (of course, this can be
verified by a careful analysis of disassembly).
</p>

<p>
Let's examine the caller, <code>net_egress()</code>.
</p>
<div class="org-src-container">

<pre class="src src-sh">b6ce4 &lt;net_egress&gt;:
 [...]
 b6d38:       3c020000        lui     v0,0x0           (1)
 b6d3c:       24420000        addiu   v0,v0,0          (2)
 b6d40:       0040f809        jalr    v0               (3)
 b6d44:       97a4001a        lhu     a0,26(sp)        (4)
 b6d48:       97a6001a        lhu     a2,26(sp)        (5)
 b6d4c:       00408021        move    s0,v0            (6)
 b6d50:       00402021        move    a0,v0            (7)
 b6d54:       3c020000        lui     v0,0x0           (8)
 b6d58:       24420000        addiu   v0,v0,0          (9)
 b6d5c:       0040f809        jalr    v0               (10)
 b6d60:       8fa5001c        lw      a1,28(sp)        (11)
 b6d64:       02202021        move    a0,s1             &lt;== <span style="color: #ffa07a;">'ra'</span> points here at offset 0x80
 [...]
</pre>
</div>

<p>
There are 2 function calls here. The first one, at line (3), seems to
have a single argument which gets initialized at line (4). Let's refer
to this called function as <code>unknown_function</code>. The second one, at line
(10), takes 3 arguments that are initialized at lines (7), (5), and
(11) respectively. Supposedly, this is a call of <code>fast_memcpy()</code> where
the crash occurred.
</p>

<p>
Can we say something specific about those arguments?
</p>
<ul class="org-ul">
<li>the 1st argument, <code>a0</code>, of <code>fast_memcpy()</code> gets initialized with the
return value, <code>v0</code>, of <code>unknown_function()</code> at line (7);
</li>
<li>this return value is passed as is, i.e. there are no validity check;
</li>
<li>the 1st argument of <code>unknown_function()</code> and the 3rd one of
<code>fast_memcpy()</code> get initilized with the same value loaded from 26(sp)
at lines (4) and (5).
</li>
</ul>

<p>
These observations suggest that the source code may look as follows:
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #eedd82;">dst</span> = unknown_function(len);
<span style="color: #87cefa;">fast_memcpy</span>(dst, src, len);
</pre>
</div>
<p>
In this particular case, <code>unknown_function()</code> returned <code>NULL</code> - hence,
the crash.
</p>

<p>
Further, a question regarding the nature of that <code>unknown_function()</code>,
accompanied by the analysis of the crash, can be sent to a supplier of
<code>binary_blob_module</code>. By submitting a more detailed report and asking
concrete questions for hard-to-reproduce problems, we can somewhat
decrease the chances of having a (sometimes) default reply such as
"please try reproducing it on our reference software and/or hardware".
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Suspected memory corruption</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Finally, let's consider a case where memory corruption is suspected.
</p>
<div class="org-src-container">

<pre class="src src-sh">CPU 0 Unable to handle kernel paging request at virtual address 0004349c, <span style="color: #eedd82;">epc</span> == 0004349c, <span style="color: #eedd82;">ra</span> == 80012224
  Oops[#1]:
  Cpu 0
  $ 0   : 00000000 7f99bcc0 00000069 2abc7ea0
  $ 4   : 00000000 7f99bd20 7f99be60 00000001
  $ 8   : 00000000 80000008 0004349c fffffff4
  $<span style="color: #eedd82;">12</span>   : 7f99bd08 00000001 00000000 00000000
  $<span style="color: #eedd82;">16</span>   : 2ab01000 2ab01000 7f99bdc8 00000000
  $<span style="color: #eedd82;">20</span>   : 2aafc6a8 00410000 7f99bde0 7f99be60
  $<span style="color: #eedd82;">24</span>   : 00000000 2abc7e80
  $<span style="color: #eedd82;">28</span>   : 85248000 85249f30 0040484c 80012224
  Hi    : 0000ba1a
  Lo    : ff98c506
  epc   : 0004349c 0x4349c
      Tainted: PF       W
  ra    : 80012224 stack_done+0x20/0x3c
  Status: 1100ff03    KERNEL EXL IE
  Cause : 10800008
  BadVA : 0004349c
  PrId  : 00019554 (MIPS 34Kc)
  [...]
  Process screen_plugin (pid: 799, <span style="color: #eedd82;">threadinfo</span>=85248000, <span style="color: #eedd82;">task</span>=87140038, <span style="color: #eedd82;">tls</span>=00000000)
  Stack : 2ab85040 00000000 00000001 00000000 00000000 00000000 00000000 7f99bcc0
          [...]
          00000001 00000000 2ac2d530 7f99bce8 7f99bd18 2aae83d4 0100ff13 00028675
  Call Trace:
  Code: (Bad address<span style="color: #00ffff;"> in</span> epc)
</pre>
</div>
<p>
Note that <code>epc == BadVA</code>. A CPU has tried to fetch an instruction at
<code>0x0004349c</code>, but this is not a valid kernel-space address.
</p>

<p>
Let's examine the code at <code>ra</code>:
</p>
<div class="org-src-container">

<pre class="src src-sh">ra    : 80012224 stack_done+0x20/0x3c

  80012140 &lt;handle_sys&gt;:
  [...]
  800121e0:       000240c0        sll     t0,v0,0x3
  800121e4:       3c098001        lui     t1,0x8001
  800121e8:       25292460        addiu   t1,t1,9312
  800121ec:       01284821        addu    t1,t1,t0
  800121f0:       8d2a0000        lw      t2,0(t1)
  800121f4:       1140005e        beqz    t2,80012370 &lt;illegal_syscall&gt;
  800121f8:       8d2b0004        lw      t3,4(t1)
  800121fc:       05610040        bgez    t3,80012300 &lt;stackargs&gt;
  80012200:       afa70080        sw      a3,128(sp)
  80012204 &lt;stack_done&gt;:
  80012204:       8f880008        lw      t0,8(gp)
  80012208:       3c098000        lui     t1,0x8000
  8001220c:       35290008        ori     t1,t1,0x8
  80012210:       01094024        and     t0,t0,t1
  80012214:       15000016        bnez    t0,80012270 &lt;syscall_trace_entry&gt;

  80012218:       00000000        nop
  8001221c:       0140f809        jalr    t2
  80012220:       00000000        nop
  80012224:       2408fb92        li      t0,-1134             &lt;=== <span style="color: #ffa07a;">'ra'</span> points here
</pre>
</div>

<p>
<code>ra</code> is the valid return address for a function call at <code>0x8001221c</code>. The
address of that function is taken from <code>t2 ($10)</code>, which indeed contains
<code>0x0004349c</code>:
</p>
<div class="org-src-container">

<pre class="src src-sh">$ 8   : 00000000 80000008 0004349c fffffff4
</pre>
</div>
<p>
So what we have is a call through a function pointer that contains a
bogus (corrupted?) value.
</p>

<p>
Let's try to figure out where <code>t2</code> is coming from:
</p>
<div class="org-src-container">

<pre class="src src-sh">800121e0:       000240c0        sll     t0,v0,0x3
 800121e4:       3c098001        lui     t1,0x8001
 800121e8:       25292460        addiu   t1,t1,9312
 800121ec:       01284821        addu    t1,t1,t0
 800121f0:       8d2a0000        lw      t2,0(t1)
 800121f4:       1140005e        beqz    t2,80012370 &lt;illegal_syscall&gt;
</pre>
</div>

<p>
The instruction at <code>0x800121f0</code> corresponds to '<code>t2 = *t1</code>' and is
followed by an instruction that compares <code>t2</code> to 0. In case of <code>t2</code> being
0, control is given to <code>illegal_syscall</code>.
</p>

<p>
Well, some knowledge of the kernel internals would be helpful here. In
any case, the appearance of names such as <code>illegal_syscall</code>, <code>handle_sys</code>,
and <code>syscall_trace_entry</code> suggest that the code in question has
something to do with the handling of system calls. The relevant code
can indeed be found in <code>arch/mips/kernel/scall32-o32.S</code>.
</p>

<p>
Can we guess what <b>syscall</b> it was?
</p>
<div class="org-src-container">

<pre class="src src-sh">800121e4:       3c098001        lui     t1,0x8001
800121e8:       25292460        addiu   t1,t1,9312
</pre>
</div>
<p>
<code>t1 = 0x80019312;</code>
</p>

<p>
<a href="https://linux.die.net/man/1/nm">nm</a> shows that this value corresponds to <code>sys_call_table</code>, which is an
array that contains addresses of all the system calls.
</p>
<div class="org-src-container">

<pre class="src src-sh">800121ec:       01284821        addu    t1,t1,t0
</pre>
</div>
<p>
<code>t1 = t1 + t0;</code>
</p>

<p>
<code>t0</code> is the offset in the table, which is being calculated as follows:
</p>
<div class="org-src-container">

<pre class="src src-sh">800121e0:       000240c0        sll     t0,v0,0x3
</pre>
</div>
<p>
<code>t0 = v0 * 8;</code>
</p>

<p>
and the value of <code>v0 ($2)</code> is <code>0x69</code> (105 decimal):
</p>
<div class="org-src-container">

<pre class="src src-sh">$ 0   : 00000000 7f99bcc0 00000069 2abc7ea0
</pre>
</div>
<p>
The analysis of the source code of <code>handle_sys</code> (it's written in
assembler) reveals that <code>v0</code> represents a syscall number.
</p>

<p>
The syscall numbers are defined in <code>arch/mips/include/asm/unistd.h</code>. The
one we are interested in corresponds to <code>sys_getitimer()</code>:
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">define __NR_getitimer                  (__NR_Linux + 105)</span>
</pre>
</div>
<p>
<code>sys_call_table</code> is not modified at run time. Also, it was not the first
and only call to <code>sys_gettimer()</code> - the system has been functioning
properly for days prior to this crash. So where do we go from here?
</p>

<p>
Memory corruptions often result in seemingly unrelated crashes: both
in kernel and user-space. What common though is that all these crashes
may look "weird". That is, the careful analysis does not reveal any
obvious problems with the code and, moreover, suggests possible
external influence, be it stack/memory corruption or hardware issues.
Having multiple crashes in different parts of the core kernel code is
usually a good indicator too.
</p>

<p>
Of course, it's always possible to overlook something. So the larger a
set of crashes from which a conclusion is drawn, the better.
</p>

<p>
The strategy then is to <b>look for common patterns</b>.
</p>

<p>
In this particular case, there was another crash in the same location
(among a dozen of crashes in yet other areas) where the syscall number
and <code>epc</code> were <code>0x68</code> and <code>0x000430d8</code> correspondingly.
</p>
<div class="org-src-container">

<pre class="src src-sh">syscall 0x69 (sys_getitimer) and epc: 0x0004349c
syscall 0x68 (sys_setitimer) and epc: 0x000430d8
</pre>
</div>

<p>
These 2 slots are neighboring in <code>sys_call_table</code>. Maybe it's just a
coincidence but is worth taking into account. Now, what's about the
content of <code>epc</code>? Do we actually know how the correct values would look
like? We can look them up with <code>nm</code> or from disassembly:
</p>
<div class="org-src-container">

<pre class="src src-sh">8004349c &lt;sys_getitimer&gt;:
800430d8 &lt;sys_setitimer&gt;:
</pre>
</div>

<p>
Is there another pattern? Yes, the only difference between good and
bad values is in the high bit <code>0x80000000</code>.
</p>

<p>
This missing-high-bit theory had explanatory power when applied
to some of the other "weird" crashes for which it was possible to
infer the good value. How could this bit be cleared? In the end, it
has been found that DDR timing settings were not properly set in the
bootloader. 
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Extra Details</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">objdump</h3>
<div class="outline-text-3" id="text-5-1">
<p>
<a id="objdump" name="objdump"></a>
'objdump -d' alone may be sufficient in many cases (not to mention all
the fun of matching disassembly and source code on your own).
Alternatively, you can reproduce the original binary (if possible)
with debugging information enabled and then use'-dS'. Be careful
though to double-check that the addresses you are interested in
correspond to the same instructions in both original and new
disassembly files. If it's not the case, code shifts/changes should be
taken into account.
</p>

<p>
use objdump check the codes location in the kernel:
</p>
<ol class="org-ol">
<li><code>arm-none-eabi-objdump -Dz -S vmlinux &gt;linux.dump</code> (not vmlinux in
<code>arch/arm/boor/compressed/</code>)
</li>
<li>the -S option needs gcc to use -g option, edit the Makefile in the
root of linux kernel folder to add -g:   
<div class="org-src-container">

<pre class="src src-sh">KBUILD_CFLAGS   := -g -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs <span style="color: #ffa07a;">\</span>
  -fno-strict-aliasing -fno-common <span style="color: #ffa07a;">\</span>
  -Werror-implicit-function-declaration <span style="color: #ffa07a;">\</span>
  -Wno-format-security <span style="color: #ffa07a;">\</span>
  -fno-delete-null-pointer-checks
</pre>
</div>
</li>
<li>find the codes location in the file <code>linux.dump</code>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Calling conventions</h3>
<div class="outline-text-3" id="text-5-2">
<p>
<a id="calling_convent" name="calling_convent"></a>
Be sure to verify the options used by your toolchain, if in doubt. For
gcc, '-mabi=type' options are used. For example, '-mabi=32'
corresponds to <code>o32</code>.
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Virtual Memory Layout on MIPS</h3>
<div class="outline-text-3" id="text-5-3">
<p>
<a id="virtual_mem" name="virtual_mem"></a>
Please refer to <a href="http://www.johnloomis.org/microchip/pic32/memory/memory.html">MIPS Address Space</a> for a general review.
</p>

<p>
Regarding the use in Linux:
</p>

<ol class="org-ol">
<li><code>kuseg range [0x00000000, 0x80000000)</code> is user-space addresses.
A private address space of user-space processes resides in this
range. From kernel-space this area can be safely accessed only by
means of special-purpose functions, like <code>copy_to_user()</code> and
<code>copy_from_user()</code>. Direct accesses are always a bug, even though,
given the nature of MIPS's MMU, such accesses may appear to be
working properly under certain circumstances.
</li>

<li><code>kseg0 range [0x80000000, 0xa0000000)</code> is kernel-space addresses
used by the kernel code and data (vmlinux).
Dynamic allocations via general purpose allocators, such as
<code>kmalloc()</code> and <code>__get_free_pages()</code> (but not from the <code>ZONE_HIGHMEM</code>
zone) return addresses in this range.
</li>

<li><code>kseg2 range [0xc0000000, 0xffffffff)</code> is kernel-space addresses
used by the code and data of kernel modules.
<code>vmalloc()</code> and <code>vmap()</code> allocations return addresses in this range.
</li>
</ol>

<p>
For <code>kuseg</code> and <code>kseg2</code>, the translation of virtual addresses into
physical ones is done via MMU. Conversely, <code>kseg0</code> addresses don't
require MMU translations; the translation is done simply by stripping
off the top-bit. For example, <code>0x80100000</code> corresponds to <code>0x00100000</code> (1
MB) in RAM.
</p>

<p>
<code>kseg0</code> ranges are both virtually and physically contiguous, while <code>kuseg</code>
and <code>kseg2</code> are only virtually contiguous.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://stablebits.blogspot.hk/?view=classic">http://stablebits.blogspot.hk/?view=classic</a>
</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2017-01-24 Tue 21:56</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
