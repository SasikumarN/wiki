<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Red Hat Enterprise MRG Realtime Tuning Guid Notes</title>
<!-- 2016-01-28 Thu 21:51 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript">
    function rpl(expr,a,b) {
      var i=0
      while (i!=-1) {
         i=expr.indexOf(a,i);
         if (i>=0) {
            expr=expr.substring(0,i)+b+expr.substring(i+a.length);
            i+=b.length;
         }
      }
      return expr
    }

    function show_org_source(){
       document.location.href = rpl(document.location.href,"html","org.html");
    }
</script>
</head>
<body>
<div id="content">
<h1 class="title">Red Hat Enterprise MRG Realtime Tuning Guid Notes</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Homepage</a></li>
<li><a href="#sec-2">Preface</a></li>
<li><a href="#sec-3">⁠Chapter 1. Before you start tuning your MRG Realtime system</a>
<ul>
<li><a href="#sec-3-1">Things to remember while you are tuning your MRG Realtime kernel</a></li>
<li><a href="#sec-3-2">How Tuning Improves Performance</a></li>
<li><a href="#sec-3-3">MRG Realtime Scheduling Policies</a></li>
</ul>
</li>
<li><a href="#sec-4">⁠Chapter 2. General System Tuning</a>
<ul>
<li><a href="#sec-4-1">2.1. Using the Tuna interface</a></li>
<li><a href="#sec-4-2">2.2. Setting persistent tuning parameters</a></li>
<li><a href="#sec-4-3">2.3. Setting BIOS parameters</a></li>
<li><a href="#sec-4-4">⁠2.4. Interrupt and process binding</a></li>
<li><a href="#sec-4-5">⁠2.5. File system determinism tips</a></li>
<li><a href="#sec-4-6">2.6. Using hardware clocks for system timestamping</a></li>
<li><a href="#sec-4-7">⁠2.7. Avoid running extra applications</a></li>
<li><a href="#sec-4-8">⁠2.8. Swapping and out of memory tips</a></li>
<li><a href="#sec-4-9">⁠2.9. Network determinism tips</a></li>
<li><a href="#sec-4-10">⁠2.10. syslog tuning tips</a></li>
<li><a href="#sec-4-11">⁠2.11. The PC card daemon</a></li>
<li><a href="#sec-4-12">⁠2.12. Reduce TCP performance spikes</a></li>
<li><a href="#sec-4-13">⁠2.13. Reducing the TCP delayed ack timeout</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 3. Realtime-Specific Tuning</a>
<ul>
<li><a href="#sec-5-1">⁠3.4. Infiniband</a></li>
<li><a href="#sec-5-2">⁠3.6. Non-Uniform Memory Access</a></li>
<li><a href="#sec-5-3">⁠3.8. Using the ftrace utility for tracing latencies</a></li>
<li><a href="#sec-5-4">⁠3.9. Latency tracing using trace-cmd</a></li>
<li><a href="#sec-5-5">⁠3.10. Using sched<sub>nr</sub><sub>migrate</sub> to limit SCHED<sub>OTHER</sub> task migration</a></li>
</ul>
</li>
<li><a href="#sec-6">Chapter 4. Application Tuning and Deployment</a>
<ul>
<li><a href="#sec-6-1">⁠4.1. Signal processing in Realtime applications</a></li>
<li><a href="#sec-6-2">⁠4.2. Using sched<sub>yield</sub> and other synchronization mechanisms</a></li>
<li><a href="#sec-6-3">⁠4.4. <code>TCP_NODELAY</code> and small buffer writes</a></li>
<li><a href="#sec-6-4">⁠4.6. Loading dynamic libraries</a></li>
<li><a href="#sec-6-5">⁠4.7. Using _COARSE POSIX clocks for application timestamping</a></li>
<li><a href="#sec-6-6">⁠4.8. About Perf</a></li>
</ul>
</li>
<li><a href="#sec-7">⁠Appendix A. Event Tracing</a></li>
<li><a href="#sec-8">⁠Appendix B. Function Tracer</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Homepage</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_MRG/2/html/Realtime_Tuning_Guide/index.html">Red Hat Enterprise MRG Realtime Tuning Guid</a>
</li>
<li>MRG Realtime Installation Guide
</li>
<li><a href="https://rt.wiki.kernel.org/index.php/HOWTO:_Build_an_RT-application">HOWTO: Build an RT-application</a>
</li>
<li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_MRG/1.3/html/Realtime_Reference_Guide/">Red Hat Enterprise MRG 1.3 Realtime Reference Guide</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Preface</h2>
<div class="outline-text-2" id="text-2">
<p>
Red Hat Enterprise MRG is a high performance distributed computing
platform consisting of three components:
</p>

<ul class="org-ul">
<li>Messaging — Cross platform, high performance, reliable messaging
using the Advanced Message Queuing Protocol (AMQP) standard.
</li>
<li>Realtime — Consistent low-latency and predictable response times for
applications that require microsecond latency.
</li>
<li>Grid — Distributed High Throughput (HTC) and High Performance
Computing (HPC).
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">⁠Chapter 1. Before you start tuning your MRG Realtime system</h2>
<div class="outline-text-2" id="text-3">
<p>
Kernel system tuning offers the vast majority of the improvement in
 determinism. For example, in many workloads thorough system tuning
 improves consistency of results by around 90%. 
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Things to remember while you are tuning your MRG Realtime kernel</h3>
<div class="outline-text-3" id="text-3-1">
<ol class="org-ol">
<li>Be Patient
Realtime tuning is an iterative process; you will almost never be
able to tweak a few variables and know that the change is the best
that can be achieved. Be prepared to spend days or weeks narrowing
down the set of tunings that work best for your system.

<p>
Additionally, always make long test runs. Changing some tuning
parameters then doing a five minute test run is not a good
validation of a set of tunes. Make the length of your test runs
adjustable and run them for longer than a few minutes. Try to
narrow down to a few different tuning sets with test runs of a few
hours, then run those sets for many hours or days at a time, to try
and catch corner-cases of max latencies or resource exhaustion.
</p>
</li>

<li>Be Accurate
Build a measurement mechanism into your application, so that you
can accurately gauge how a particular set of tuning changes affect
the application's performance. Anecdotal evidence (e.g. "The mouse
moves more smoothly") is usually wrong and varies from person to
person. Do hard measurements and record them for later analysis.
</li>

<li>Be Methodical
It is very tempting to make multiple changes to tuning variables
between test runs, but doing so means that you do not have a way to
narrow down which tune affected your test results. Keep the tuning
changes between test runs as small as you can.
</li>

<li>Be Conservative
It is also tempting to make large changes when tuning, but it is
almost always better to make incremental changes. You will find
that working your way up from the lowest to highest priority values
will yield better results in the long run.
</li>

<li>Be Smart
Use the tools you have available. The Tuna graphical tuning tool
makes it easy to change processor affinities for threads and
interrupts, thread priorities and to isolate processors for
application use. The taskset and chrt command line utilities allow
you to do most of what Tuna does. If you run into performance
problems, the ftrace facility in the trace kernel can help locate
latency issues.
</li>

<li>Be Flexible
Rather than hard-coding values into your application, use external
tools to change policy, priority and affinity. This allows you to
try many different combinations and simplifies your logic. Once you
have found some settings that give good results, you can either add
them to your application, or set up some startup logic to implement
the settings when the application starts.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">How Tuning Improves Performance</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Most performance tuning is performed by manipulating processors
(CPUs). Processors are manipulated through:
</p>
<ul class="org-ul">
<li>Interrupts:
In software, an interrupt is an event that calls for a change in
execution.

<p>
Interrupts are serviced by a set of processors. By adjusting the
affinity setting of an interrupt we can determine on which processor
the interrupt will run.
</p>
</li>

<li>Threads:
Threads provide programs with the ability to run two or more tasks
simultaneously.

<p>
Threads, like interrupts, can be manipulated through the affinity
setting, which determines on which processor the thread will run.
</p>

<p>
It is also possible to set scheduling priority and scheduling
policies to further control threads.
</p>
</li>
</ul>

<p>
By manipulating interrupts and threads off and on to processors, you
are able to indirectly manipulate the processors. This gives you
greater control over scheduling and priorities and, subsequently,
latency and determinism.
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">MRG Realtime Scheduling Policies</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Linux uses three main scheduling policies:
</p>

<ul class="org-ul">
<li><code>SCHED_OTHER (sometimes called SCHED_NORMAL)</code>
This is the default thread policy and has dynamic priority
controlled by the kernel. The priority is changed based on thread
activity. Threads with this policy are considered to have a realtime
priority of 0 (zero).
</li>
<li><code>SCHED_FIFO (First in, first out)</code>
A realtime policy with a priority range of from 1 - 99, with 1 being
the lowest and 99 the highest. <code>SCHED_FIFO</code> threads always have a
higher priority than <code>SCHED_OTHER</code> threads (for example, a <code>SCHED_FIFO</code>
thread with a priority of 1 will have a higher priority than any
<code>SCHED_OTHER</code> thread). Any thread created as a <code>SCHED_OTHER</code> thread has
a fixed priority and will run until it is blocked or preempted by a
higher priority thread.
</li>
<li><code>SCHED_RR (Round-Robin)</code>
<code>SCHED_RR</code> is an optimization of <code>SCHED_FIFO</code>. Threads with the same
priority have a quantum and are round-robin scheduled among all
equal priority SCHED<sub>RR</sub> threads. This policy is rarely used.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">⁠Chapter 2. General System Tuning</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">2.1. Using the Tuna interface</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_MRG/1.3/html/Tuna_User_Guide/">Tuna User Guide</a>
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">2.2. Setting persistent tuning parameters</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Once you have decided what tuning configuration works for your system,
persist those parameters. The method you choose depends on the type of
parameter you are setting.
</p>

<ul class="org-ul">
<li>Editing the /etc/sysctl.conf file
<ol class="org-ol">
<li>Remove the <code>/proc/sys/</code> prefix from the command and replace the
central / character with a . character.
</li>
<li>Insert the new entry into the /etc/sysctl.conf file with the
required parameter.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Enable gettimeofday(2)</span>
kernel.vsyscall64 = 2
</pre>
</div>
</li>
<li>Run # sysctl -p to refresh with the new configuration.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sysctl -p</span>
...[output truncated]...
kernel.vsyscall64 = 2
</pre>
</div>
</li>
</ol>
</li>
<li>Editing the /etc/rc.d/rc.local file 
Adjust the command as per the “Editing the /etc/sysctl.conf file”
instructions.
</li>
</ul>
<p class="warning">
Use this alternative only as a last resort.
</p>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">2.3. Setting BIOS parameters</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>Power Management
Anything that tries to save power by either changing the system
clock frequency or by putting the CPU into various sleep states can
affect how quickly the system responds to external events.

<p>
For best response times, disable power management options in the
BIOS.
</p>
</li>
<li>Error Detection and Correction (EDAC) units
EDAC units are devices used to detect and correct errors signaled
from Error Correcting Code (ECC) memory. Usually EDAC options range
from no ECC checking to a periodic scan of all memory nodes for
errors. The higher the EDAC level, the more time is spent in BIOS,
and the more likely that crucial event deadlines will be missed.

<p>
Turn EDAC off if possible. Otherwise, switch to the lowest
functional level.
</p>
</li>
<li>System Management Interrupts (SMI)
SMIs are a facility used by hardware vendors ensure the system is
operating correctly. The SMI interrupt is usually not serviced by
the running operating system, but by code in the BIOS. SMIs are
typically used for thermal management, remote console management
(IPMI), EDAC checks, and various other housekeeping tasks.

<p>
If the BIOS contains SMI options, check with the vendor and any
relevant documentation to check to what extent it is safe to disable
them.
</p>
<p class="warning">
While it is possible to completely disable SMIs, it is strongly
recommended that you do not do this. Removing the ability for your
system to generate and service SMIs can result in catastrophic
hardware failure.
</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">⁠2.4. Interrupt and process binding</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Realtime environments need to minimize or eliminate latency when
responding to various events. Ideally, interrupts (IRQs) and user
processes can be isolated from one another on different dedicated
CPUs.
</p>

<p>
Interrupts are generally shared evenly between CPUs. This can delay
interrupt processing through having to write new data and instruction
caches, and often creates conflicts with other processing occurring on
the CPU. In order to overcome this problem, time-critical interrupts
and processes can be dedicated to a CPU (or a range of CPUs). In this
way, the code and data structures needed to process this interrupt
will have the highest possible likelihood to be in the processor data
and instruction caches. The dedicated process can then run as quickly
as possible, while all other non-time-critical processes run on the
remainder of the CPUs.
</p>
</div>
<ul class="org-ul"><li><a id="sec-4-4-1" name="sec-4-4-1"></a>Procedure 2.3. Disabling the irqbalance daemon<br  /><div class="outline-text-4" id="text-4-4-1">
<p>
This daemon is enabled by default and periodically forces interrupts
to be handled by CPUs in an even, fair manner. However in realtime
deployments, applications are typically dedicated and bound to
specific CPUs, so the <b>irqbalance</b> daemon is not required.
</p>

<ol class="org-ol">
<li>Check the status of the irqbalance daemon.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">service irqbalance status</span>
<span style="color: #87cefa;">irqbalance</span> (pid PID) is running...
</pre>
</div>
</li>
<li>If the irqbalance daemon is running, stop it using the service
command.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">service irqbalance stop</span>
Stopping irqbalance:             [  OK  ]
</pre>
</div>
</li>
<li>Use chkconfig to ensure that irqbalance does not restart on boot.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">chkconfig irqbalance off</span>
</pre>
</div>
</li>
</ol>
</div>
</li>
<li><a id="sec-4-4-2" name="sec-4-4-2"></a>Procedure 2.4. Excluding CPUs from IRQ Balancing<br  /><div class="outline-text-4" id="text-4-4-2">
<p>
he <code>/etc/sysconfig/irqbalance</code> configuration file contains a setting
that allows CPUs to be excluded from consideration by the IRQ balacing
service. This parameter is named <code>IRQBALANCE_BANNED_CPUS</code> and is a
64-bit hexadecimal bit mask, where each bit of the mask represents a
CPU core.
</p>

<ol class="org-ol">
<li>Open /etc/sysconfig/irqbalance in your preferred text editor and
find the section of the file titled IRQBALANCE<sub>BANNED</sub><sub>CPUS</sub>.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">IRQBALANCE_BANNED_CPUS</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">64 bit bitmask which allows you to indicate which cpu's should</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">be skipped when reblancing irqs. Cpu numbers which have their</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">corresponding bits set to one in this mask will not have any</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">irq's assigned to them on rebalance</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">IRQBALANCE_BANNED_CPUS=</span>
</pre>
</div>
</li>
<li>Exclude CPUs 8 to 15 by uncommenting the variable
<code>IRQBALANCE_BANNED_CPUS</code> and setting its value this way:
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #eedd82;">IRQBALANCE_BANNED_CPUS</span>=0000ff00
</pre>
</div>
<p>
This will cause the irqbalance process to ignore the CPUs that have
bits set in the bitmask; in this case, bits 8 through 15.
</p>
</li>
<li>If you are running a system with up to 64 CPU cores, separate each
group of eight hexadecimal digits with a comma:
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #eedd82;">IRQBALANCE_BANNED_CPUS</span>=00000001,0000ff00
</pre>
</div>
<p>
The above mask excludes CPUs 8 to 15 as well as CPU 33 from IRQ
balancing.
</p>
</li>
</ol>
</div>
</li>
<li><a id="sec-4-4-3" name="sec-4-4-3"></a>Procedure 2.5. Manually Assigning CPU Affinity to Individual IRQs<br  /><div class="outline-text-4" id="text-4-4-3">
<ol class="org-ol">
<li>Check which IRQ is in use by each device by viewing the
<code>/proc/interrupts</code> file:
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /proc/interrupts</span>
</pre>
</div>
<p>
This file contains a list of IRQs. Each line shows the IRQ number,
the number of interrupts that happened in each CPU, followed by the
IRQ type and a description:
</p>
<div class="org-src-container">

<pre class="src src-sh">CPU0             CPU1
0:   26575949         11         IO-APIC-edge  timer
1:         14          7         IO-APIC-edge  i8042
...[output truncated]...
</pre>
</div>
</li>
<li>To instruct an IRQ to run on only one processor, echo the CPU mask
(as a hexadecimal number) to <code>/proc/interrupts</code>. In this example, we
are instructing the interrupt with IRQ number 142 to run on CPU 0
only:
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 1 &gt; /proc/irq/142/smp_affinity</span>
</pre>
</div>
</li>
<li>This change will only take effect once an interrupt has occurred. 
</li>
</ol>
</div>
</li>
<li><a id="sec-4-4-4" name="sec-4-4-4"></a>Procedure 2.6. Binding Processes to CPUs using the taskset utility<br  /><div class="outline-text-4" id="text-4-4-4">
<p>
The <b>taskset</b> utility uses the process ID (PID) of a task to view or set
the affinity, or can be used to launch a command with a chosen CPU
affinity.
</p>
<ol class="org-ol">
<li>To set the affinity of a process that is not currently running, use
taskset and specify the CPU mask and the process. In this example,
<code>my_embedded_process</code> is being instructed to use only CPU 3
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">taskset 8 /usr/local/bin/my_embedded_process</span>
</pre>
</div>
</li>
<li>It is also possible to specify more than one CPU in the bitmask. In
this example, <code>my_embedded_process</code> is being instructed to execute on
processors 4, 5, 6, and 7
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">taskset 0xF0 /usr/local/bin/my_embedded_process</span>
</pre>
</div>
</li>
<li>It is also possible to set the CPU affinity for processes that are
already running by using the -p (&#x2013;pid) option with the CPU mask
and the PID of the process you wish to change. In this example, the
process with a PID of 7013 is being instructed to run only on
CPU 0.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">taskset -p 1 7013</span>
</pre>
</div>
</li>
</ol>

<p class="warning">
The taskset utility works on a Non-Uniform Memory Access (NUMA)
system, but it does not allow the user to bind threads to CPUs and the
closest NUMA memory node. On such systems, taskset is not the
preferred tool, and the numactl utility should be used instead for its
advanced capabilities.
</p>
</div>
</li>
<li><a id="sec-4-4-5" name="sec-4-4-5"></a>Related Manual<br  /><div class="outline-text-4" id="text-4-4-5">
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #87cefa;">chrt</span>(1)
<span style="color: #87cefa;">taskset</span>(1)
<span style="color: #87cefa;">nice</span>(1)
<span style="color: #87cefa;">renice</span>(1)
<span style="color: #87cefa;">sched_setscheduler</span>(2) <span style="color: #00ffff;">for</span> a description of the Linux scheduling scheme.
</pre>
</div>
</div>
</li></ul>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">⁠2.5. File system determinism tips</h3>
<div class="outline-text-3" id="text-4-5">
<p>
The order in which journal changes arrive are sometimes not in the
order that they are actually written to disk. The kernel I/O system
has the option of reordering the journal changes, usually to try and
make best use of available storage space. Journal activity can
introduce latency through re-ordering journal changes and committing
data and metadata.
</p>

<p>
The default filesystem used by Linux distributions including Red Hat
Enterprise Linux 6 is a journaling file system called ext4. An
earlier, mostly compatible implementation of the file system called
ext2 does not use journaling. Unless your organization specifically
requires journaling, consider using ext2. In many of our best
benchmark results, we utilize the ext2 file system and consider it one
of the top initial tuning recommendations.
</p>
</div>
<ul class="org-ul"><li><a id="sec-4-5-1" name="sec-4-5-1"></a>Procedure 2.7. Disabling atime<br  /><div class="outline-text-4" id="text-4-5-1">
<ol class="org-ol">
<li>Open the <code>/etc/fstab</code>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #eedd82;">LABEL</span>=/       /       ext4    defaults        1 1
...[output truncated]...
</pre>
</div>
</li>
<li>Edit the options sections to include the terms noatime and
<code>nodiratime</code>. <code>noatime</code> prevents access timestamps being updated when a
file is read and <code>nodiratime</code> will stop directory inode access times
being updated.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #eedd82;">LABEL</span>=/       /       ext4    noatime,nodiratime        1 1
</pre>
</div>
</li>
</ol>
</div>
</li>
<li><a id="sec-4-5-2" name="sec-4-5-2"></a>Related Manual Pages<br  /><div class="outline-text-4" id="text-4-5-2">
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #87cefa;">mkfs.ext2</span>(8)
<span style="color: #87cefa;">mkfs.ext4</span>(8)
<span style="color: #87cefa;">mount</span>(8) - for information on atime, nodiratime and noatime
<span style="color: #87cefa;">chattr</span>(1)
</pre>
</div>
</div>
</li></ul>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">2.6. Using hardware clocks for system timestamping</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Multiprocessor systems such as NUMA or SMP have multiple instances of
hardware clocks. During boot time the kernel discovers the available
clock sources and selects one to use. For the list of the available
clock sources in your system, view the
<code>/sys/devices/system/clocksource/clocksource0/available_clocksource</code>
file:
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /sys/devices/system/clocksource/clocksource0/available_clocksource </span>
tsc hpet acpi_pm
</pre>
</div>

<p>
In the example above, the TSC, HPET and <code>ACPI_PM</code> clock sources are
available.
</p>

<p>
The clock source currently in use can be inspected by reading the
<code>/sys/devices/system/clocksource/clocksource0/current_clocksource</code>
file:
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /sys/devices/system/clocksource/clocksource0/current_clocksource</span>
tsc
</pre>
</div>
</div>

<ul class="org-ul"><li><a id="sec-4-6-1" name="sec-4-6-1"></a>Changing clock sources<br  /><div class="outline-text-4" id="text-4-6-1">
<p>
Requirements for crucial applications vary on each system. Therefore,
the best clock for each application, and consequently each system,
also varies. Some applications depend on clock resolution, and a clock
that delivers reliable nanoseconds readings can be more suitable.
Applications that read the clock too often can benefit from a clock
with a smaller reading cost (the time between a read request and the
result).
</p>

<p>
To do so, select a clock source from the list presented in the
<code>/sys/devices/system/clocksource/clocksource0/available_clocksource</code>
file and write the clock's name into the
<code>/sys/devices/system/clocksource/clocksource0/current_clocksource</code> file.
For example, the following command sets HPET as the clock source in
use:
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo hpet &gt; /sys/devices/system/clocksource/clocksource0/current_clocksource</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-4-6-2" name="sec-4-6-2"></a>Configuring additional boot parameters for the TSC clock<br  /><div class="outline-text-4" id="text-4-6-2">
<p>
While there is no single clock which is ideal for all systems, TSC is
generally the preferred clock source. To optimize the reliability of
the TSC clock, you can configure additional parameters when booting
the kernel, for example:
</p>

<ul class="org-ul">
<li><code>idle=poll</code>: Forces the clock to avoid entering the idle state.
</li>
<li><code>processor.max_cstate=1</code>: Prevents the clock from entering deeper
C-states (energy saving mode), so it does not become out of sync.
</li>
</ul>
</div>
</li>
<li><a id="sec-4-6-3" name="sec-4-6-3"></a>Controlling power management transitions<br  /><div class="outline-text-4" id="text-4-6-3">
<p>
Modern processors actively transition to higher power saving states
(C-states) from lower states. Unfortunately, transitioning from a high
power saving state back to a running state can consume more time than
is optimal for a Realtime application. To prevent these transitions,
an application can use the Power Management Quality of Service (PM
QoS) interface.
</p>

<p>
When an application holds the <code>/dev/cpu_dma_latency</code> file open, the PM
QoS interface prevents the processor from entering deep sleep states
and causing unexpected latencies when exiting deep sleep states. When
the file is closed, the system returns to a power-saving state.
</p>

<ol class="org-ol">
<li>Open the <code>/dev/cpu_dma_latency</code> file. 
</li>
<li>Write a 32-bit number to it. This number represents a maximum
response time in microseconds. For the fastest possible response
time, use 0.
</li>
</ol>

<p>
An example <code>/dev/cpu_dma_latency</code> file is as follows:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pm_qos_fd</span> = -1;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">start_low_latency</span>(<span style="color: #98fb98;">void</span>)
{
        <span style="color: #98fb98;">s32_t</span> <span style="color: #eedd82;">target</span> = 0;

        <span style="color: #00ffff;">if</span> (<span style="color: #98fb98;">pm_qos_fd</span> &amp;<span style="color: #eedd82;">gt</span>;= 0)
                <span style="color: #00ffff;">return</span>;
        pm_qos_fd = open(<span style="color: #ffa07a;">"/dev/cpu_dma_latency"</span>, O_RDWR);
        <span style="color: #00ffff;">if</span> (<span style="color: #98fb98;">pm_qos_fd</span> &amp;<span style="color: #eedd82;">lt</span>; 0) {
           fprintf(stderr, <span style="color: #ffa07a;">"Failed to open PM QOS file: %s"</span>,
                   strerror(errno));
           exit(errno);
        }
        write(pm_qos_fd, &amp;target, <span style="color: #00ffff;">sizeof</span>(target));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">stop_low_latency</span>(<span style="color: #98fb98;">void</span>)
{
        <span style="color: #00ffff;">if</span> (<span style="color: #98fb98;">pm_qos_fd</span> &amp;<span style="color: #eedd82;">gt</span>;= 0)
           close(pm_qos_fd);
}
</pre>
</div>

<p>
The application will first <code>call start_low_latency()</code>, perform the
required latency-sensitive processing, then call <code>stop_low_latency()</code>.
</p>
</div>
</li></ul>
</div>
<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7">⁠2.7. Avoid running extra applications</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>Graphical desktop
open the /etc/inittab file, change <code>id:5:initdefault:</code> into
<code>id:3:initdefault:</code>. By default, the runlevel is 5 - full
multi-user mode, using the graphical interface. By changing the
number in the string to 3, the default runlevel will be full
multi-user mode, but without the graphical interface.
</li>
<li>Mail Transfer Agents (MTA, such as Sendmail or Postfix)
</li>
<li>Remote Procedure Calls (RPCs)
</li>
<li>Network File System (NFS)
</li>
<li>Mouse Services
Remove the hardware and uninstall gpm.
</li>
<li>Automated tasks
</li>
<li>Check for automated cron or at jobs that could impact performance.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8">⁠2.8. Swapping and out of memory tips</h3>
<div class="outline-text-3" id="text-4-8">
<p>
Swapping pages out to disk can introduce latency in any environment.
To ensure low latency, the best strategy is to have enough memory in
your systems so that swapping is not necessary. Use <code>vmstat</code> to monitor
memory usage and watch the <code>si (swap in)</code> and <code>so (swap out)</code> fields. It
is optimal that they remain on zero as much as possible.
</p>
</div>

<ul class="org-ul"><li><a id="sec-4-8-1" name="sec-4-8-1"></a>Procedure 2.8. Out of Memory (OOM)<br  /><div class="outline-text-4" id="text-4-8-1">
<p>
Out of Memory (OOM) refers to a computing state where all available
memory, including swap space, has been allocated. Normally this will
cause the system to panic and stop functioning as expected. There is a
switch that controls OOM behavior in <code>/proc/sys/vm/panic_on_oom</code>. When
set to 1 the kernel will panic on OOM. The default setting is <code>0</code> which
instructs the kernel to call a function named <code>oom_killer</code> on an OOM. 
</p>

<ol class="org-ol">
<li>The easiest way to change this is to echo the new value to
<code>/proc/sys/vm/panic_on_oom</code>.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /proc/sys/vm/panic_on_oom</span>
0

<span style="color: #ff7f24;">#  </span><span style="color: #ff7f24;">echo 1 &gt; /proc/sys/vm/panic_on_oom</span>

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /proc/sys/vm/panic_on_oom</span>
1
</pre>
</div>
</li>
<li>It is also possible to prioritize which processes get killed by
adjusting the oom<sub>killer</sub> score. In <code>/proc/PID/</code> there are two tools
labeled <code>oom_adj</code> and <code>oom_score</code>. Valid scores for oom<sub>adj</sub>= are in the
range -16 to +15. This value is used to calculate the 'badness' of
the process using an algorithm that also takes into account how
long the process has been running, among other factors. <code>oom_killer</code>
will kill processes with the highest scores first.

<p>
This example adjusts the <code>oom_score</code> of a process with a PID of 12465
to make it less likely that <code>oom_killer</code> will kill it.
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /proc/12465/oom_score </span>
79872

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo -5 &gt; /proc/12465/oom_adj</span>

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /proc/12465/oom_score</span>
78
</pre>
</div>
</li>
<li>There is also a special value of -17, which disables <code>oom_killer</code> for
that process. 
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /proc/12465/oom_score</span>
78

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo -17 &gt; /proc/12465/oom_adj</span>

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /proc/12465/oom_score</span>
0
</pre>
</div>
</li>
</ol>
</div>
</li></ul>
</div>
<div id="outline-container-sec-4-9" class="outline-3">
<h3 id="sec-4-9">⁠2.9. Network determinism tips</h3>
<div class="outline-text-3" id="text-4-9">
</div><ul class="org-ul"><li><a id="sec-4-9-1" name="sec-4-9-1"></a>Transmission Control Protocol (TCP)<br  /><div class="outline-text-4" id="text-4-9-1">
<p>
TCP can have a large effect on latency. TCP adds latency in order to
obtain efficiency, control congestion, and to ensure reliable
delivery. When tuning, consider the following points:
</p>

<ul class="org-ul">
<li>Do you need ordered delivery?
</li>
<li>Do you need to guard against packet loss?
Transmitting packets more than once can cause delays.
</li>
<li>If you must use TCP, consider disabling the Nagle buffering
algorithm by using <code>TCP_NODELAY</code> on your socket. The Nagle algorithm
collects small outgoing packets to send all at once, and can have a
detrimental effect on latency.
</li>
</ul>
</div>
</li>
<li><a id="sec-4-9-2" name="sec-4-9-2"></a>Network Tuning<br  /><div class="outline-text-4" id="text-4-9-2">
<p>
There are numerous tools for tuning the network.
</p>
</div>
</li>
<li><a id="sec-4-9-3" name="sec-4-9-3"></a>Interrupt Coalescing<br  /><div class="outline-text-4" id="text-4-9-3">
<p>
To reduce network traffic, packets can be collected and a single
interrupt generated.
</p>

<p>
Use the <code>-C (--coalesce)</code> option with the <b>ethtool</b> command to enable.
</p>
</div>
</li>
<li><a id="sec-4-9-4" name="sec-4-9-4"></a>Congestion<br  /><div class="outline-text-4" id="text-4-9-4">
<p>
Often, I/O switches can be subject to back-pressure, where network
data builds up as a result of full buffers.
</p>

<p>
Use the <code>-A (--pause)</code> option with the <b>ethtool</b> command to change pause
parameters and avoid network congestion.
</p>
</div>
</li>
<li><a id="sec-4-9-5" name="sec-4-9-5"></a>Infiniband (IB)<br  /><div class="outline-text-4" id="text-4-9-5">
<p>
Infiniband is a type of communications architecture often used to
increase bandwidth and provide quality of service and failover. It can
also be used to improve latency through Remote Direct Memory Access
(RDMA) capabilities.
</p>
</div>
</li>
<li><a id="sec-4-9-6" name="sec-4-9-6"></a>Network Protocol Statistics<br  /><div class="outline-text-4" id="text-4-9-6">
<p>
Use the <code>-s (--statistics)</code> option with the <b>netstat</b> command to monitor
network traffic.
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-4-10" class="outline-3">
<h3 id="sec-4-10">⁠2.10. syslog tuning tips</h3>
<div class="outline-text-3" id="text-4-10">
<p>
syslog can forward log messages from any number of programs over a
network. The less often this occurs, the larger the pending
transaction is likely to be. If the transaction is very large an I/O
spike can occur. To prevent this, keep the interval reasonably small.
</p>

<p>
The system logging daemon, called <code>syslogd</code>, is used to collect messages
from a number of different programs. It also collects information
reported by the kernel from the kernel logging daemon <code>klogd</code>.
Typically, syslogd will log to a local file, but it can also be
configured to log over a network to a remote logging server.
</p>
</div>
</div>

<div id="outline-container-sec-4-11" class="outline-3">
<h3 id="sec-4-11">⁠2.11. The PC card daemon</h3>
<div class="outline-text-3" id="text-4-11">
<p>
The pcscd daemon is used to manage connections to PC and SC smart card
readers. Although pcscd is usually a low priority task, it can often
use more CPU than any other daemon.
</p>
</div>

<ul class="org-ul"><li><a id="sec-4-11-1" name="sec-4-11-1"></a>Procedure 2.10. Disabling the pcscd Daemon<br  /><div class="outline-text-4" id="text-4-11-1">
<ol class="org-ol">
<li>Check the status of the pcscd daemon.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">service pcscd status</span>
<span style="color: #87cefa;">pcscd</span> (pid PID) is running...
</pre>
</div>
</li>
<li>If the <code>pcscd</code> daemon is running, stop it using the <code>service</code> command.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">service pcscd stop</span>
Stopping PC/SC smart card daemon (pcscd):            [  OK  ]
</pre>
</div>
</li>
<li>Use <code>chkconfig</code> to ensure that <code>pcscd</code> does not restart on boot.
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">chkconfig pcscd off</span>
</pre>
</div>
</li>
</ol>
</div>
</li></ul>
</div>
<div id="outline-container-sec-4-12" class="outline-3">
<h3 id="sec-4-12">⁠2.12. Reduce TCP performance spikes</h3>
<div class="outline-text-3" id="text-4-12">
<p>
Turn timestamps off to reduce performance spikes related to timestamp
generation. The <code>sysctl</code> command controls the values of TCP related
entries, setting the timestamps kernel parameter found at
<code>/proc/sys/net/ipv4/tcp_timestamps</code>.
</p>
<ul class="org-ul">
<li>Turn timestamps off with the following command:
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sysctl -w net.ipv4.tcp_timestamps=0</span>
net.ipv4.tcp_timestamps = 0
</pre>
</div>
</li>
<li>Turn timestamps on with the following command:
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sysctl -w net.ipv4.tcp_timestamps=1</span>
net.ipv4.tcp_timestamps = 1
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-13" class="outline-3">
<h3 id="sec-4-13">⁠2.13. Reducing the TCP delayed ack timeout</h3>
<div class="outline-text-3" id="text-4-13">
<p>
On Red Hat Enterprise Linux, there are two modes used by TCP to
acknowledge data reception:
</p>
<ul class="org-ul">
<li>Quick ACK
<ol class="org-ol">
<li>This mode is used at the start of a TCP connection so that the
congestion window can grow quickly.
</li>
<li>To change the default TCP ACK timeout value, write the desired
value in milliseconds to the <code>/proc/sys/net/ipv4/tcp_ato_min</code> file:
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 4 &gt; /proc/sys/net/ipv4/tcp_ato_min</span>
</pre>
</div>
</li>
</ol>
</li>
<li>Delayed ACK
<ol class="org-ol">
<li>After the connection is established, TCP assumes this mode, in
which ACKs for multiple received packets can be sent in a single
packet.
</li>
<li>To change the default TCP Delayed ACK value, write the desired
value in milliseconds to the <code>/proc/sys/net/ipv4/tcp_delack_min</code>
file:
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 4 &gt; /proc/sys/net/ipv4/tcp_delack_min</span>
</pre>
</div>
</li>
</ol>
</li>
</ul>

<p>
TCP switches between the two modes depending on the current
congestion.
</p>

<p>
Some applications that send small network packets could experience
latencies due to the TCP quick and delayed acknowledgment timeouts,
which previously were 40 ms by default. That means small packets from
an application that seldom sends information through the network could
experience a delay up to 40 ms to receive the acknowledgment that a
packet has been received by the other side. To minimize this issue,
both <code>tcp_ato_min</code> and <code>tcp_delack_min</code> timeouts are now 4 ms by default.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 3. Realtime-Specific Tuning</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">⁠3.4. Infiniband</h3>
<div class="outline-text-3" id="text-5-1">
<p>
<a href="http://people.redhat.com/dledford/infiniband_get_started.html">Getting Started with InfiniBand</a>
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">⁠3.6. Non-Uniform Memory Access</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Non-Uniform Memory Access (NUMA) is a design used to allocate memory
resources to a specific CPU. This can improve access time and results
in fewer memory locks. Although this appears as though it would be
useful for reducing latency, NUMA systems have been known to interact
badly with realtime applications, as they can cause unexpected event
latencies.
</p>

<p>
For more information about the NUMA API, see Andi Kleen's whitepaper
<a href="http://www.halobates.de/numaapi3.pdf">An NUMA API for Linux</a>.
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">⁠3.8. Using the ftrace utility for tracing latencies</h3>
<div class="outline-text-3" id="text-5-3">
<p>
One of the diagnostic facilities provided with the MRG Realtime kernel
is <b>ftrace</b>, which is used by developers to analyze and debug latency
and performance issues that occur outside of user-space. The ftrace
utility has a variety of options that allow you to use the utility in
a number of different ways. It can be used to trace context switches,
measure the time it takes for a high-priority task to wake up, the
length of time interrupts are disabled, or list all the kernel
functions executed during a given period.
</p>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">⁠3.9. Latency tracing using trace-cmd</h3>
<div class="outline-text-3" id="text-5-4">
<p>
<b>trace-cmd</b> is a MRG Realtime function that traces all kernel function
calls, and some special events. It records what is happening in the
system during a short period of time, providing information that can
be used to analyze system behavior.
</p>

<p>
install the trace-cmd:
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sudo apt-get install trace-cmd</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">or</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">yum install trace-cmd</span>
</pre>
</div>

<p>
The commands instruct trace-cmd to trace in specific ways.
</p>
<div class="org-src-container">

<pre class="src src-sh">Command Description
record  Record a trace into a trace.dat file.
start   Start tracing without recording into a file.
extract Extract a trace from the kernel.
stop    Stops the kernel from recording trace data.
reset   Disable all kernel tracing and clear the trace buffers.
report  Read out the trace stored<span style="color: #00ffff;"> in</span> a trace.dat file.
split   Parse a trace.dat file into smaller file(s).
listen  Listen on a network socket for trace clients.
list    List the available events, plugins or options.
</pre>
</div>

<p>
In this example, the trace-cmd utility will trace a single trace
point:
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">./trace-cmd record -e sched_wakeup ls /bin</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">⁠3.10. Using sched<sub>nr</sub><sub>migrate</sub> to limit SCHED<sub>OTHER</sub> task migration</h3>
<div class="outline-text-3" id="text-5-5">
<p>
If a <code>SCHED_OTHER</code> task spawns a large number of other tasks, they will
all run on the same CPU. The migration task or <code>softirq</code> will try to
balance these tasks so they can run on idle CPUs. The <code>sched_nr_migrate</code>
option can be set to specify the number of tasks that will move at a
time. Because realtime tasks have a different way to migrate, they are
not directly affected by this, however when <code>softirq</code> moves the tasks it
locks the run queue spinlock that is needed to disable interrupts. If
there are a large number of tasks that need to be moved, it will occur
while interrupts are disabled, so no timer events or wakeups will
happen simultaneously. This can cause severe latencies for realtime
tasks when the <code>sched_nr_migrate</code> is set to a large value.
</p>
</div>
<ul class="org-ul"><li><a id="sec-5-5-1" name="sec-5-5-1"></a>Procedure 3.4. Adjusting the value of the sched<sub>nr</sub><sub>migrate</sub> variable<br  /><div class="outline-text-4" id="text-5-5-1">
<ol class="org-ol">
<li>Increasing the <code>sched_nr_migrate</code> variable gives high performance
from <code>SCHED_OTHER</code> threads that spawn lots of tasks, at the expense
of realtime latencies. For low realtime task latency at the expense
of <code>SCHED_OTHER</code> task performance, the value must be lowered. The
default value is 8.
</li>
<li>To adjust the value of the sched<sub>nr</sub><sub>migrate</sub> variable, you can echo
the value directly to /proc/sys/kernel/sched<sub>nr</sub><sub>migrate</sub>:
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 2 &gt; /proc/sys/kernel/sched_nr_migrate</span>
</pre>
</div>
</li>
</ol>
</div>
</li></ul>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Chapter 4. Application Tuning and Deployment</h2>
<div class="outline-text-2" id="text-6">
<p>
For further reading on developing your own MRG Realtime applications,
start by reading the <a href="https://rt.wiki.kernel.org/index.php/HOWTO:_Build_an_RT-application">HOWTO: Build an RT-application</a>.
</p>
</div>

<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">⁠4.1. Signal processing in Realtime applications</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Traditional UNIX and POSIX signals have their uses, especially for
error handling, but they are not suitable for use in realtime
applications as an event delivery mechanism. The reason for this is
that the current Linux kernel signal handling code is quite complex,
due mainly to legacy behavior and the multitude of APIs that need to
be supported. This complexity means that the code paths that are taken
when delivering a signal are not always optimal, and quite long
latencies can be experienced by applications.
</p>

<p>
The original motivation behind UNIX™ signals was to multiplex one
thread of control (the process) between different "threads" of
execution. Signals behave somewhat like operating system interrupts -
when a signal is delivered to an application, the application's
context is saved and it starts executing a previously registered
signal handler. Once the signal handler has completed, the application
returns to executing where it was when the signal was delivered. This
can get complicated in practice.
</p>

<p>
Signals are too non-deterministic to trust them in a realtime
application. A better option is to use POSIX Threads (pthreads) to
distribute your workload and communicate between various components.
You can coordinate groups of threads using the pthreads mechanisms of
mutexes, condition variables and barriers and trust that the code
paths through these relatively new constructs are much cleaner than
the legacy handling code for signals.
</p>
</div>

<ul class="org-ul"><li><a id="sec-6-1-1" name="sec-6-1-1"></a>Further Reading<br  /><div class="outline-text-4" id="text-6-1-1">
<p>
<a href="https://www.akkadia.org/drepper/posix-signal-model.xml">Requirements of the POSIX Signal Model</a>
</p>
</div>
</li></ul>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">⁠4.2. Using sched<sub>yield</sub> and other synchronization mechanisms</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The <code>sched_yield</code> system call is used by a thread allowing other threads
a chance to run. Often when <code>sched_yield</code> is used, the thread can go to
the end of the run queues, taking a long time to be scheduled again,
or it can be rescheduled straight away, creating a busy loop on the
CPU. The scheduler is better able to determine when and if there are
actually other threads wanting to run. Avoid using <code>sched_yield</code> on any
RT task.
</p>

<p>
For more information, see Arnaldo Carvalho de Melo's paper on
<a href="http://vger.kernel.org/~acme/unbehaved.txt">Earthquaky kernel interfaces</a>.
</p>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">⁠4.4. <code>TCP_NODELAY</code> and small buffer writes</h3>
<div class="outline-text-3" id="text-6-3">
<p>
By default TCP uses Nagle's algorithm to collect small outgoing
packets to send all at once. This can have a detrimental effect on
latency.
</p>
</div>
<ul class="org-ul"><li><a id="sec-6-3-1" name="sec-6-3-1"></a>Procedure 4.3. Using <code>TCP_NODELAY</code> and <code>TCP_CORK</code> to improve network latency<br  /><div class="outline-text-4" id="text-6-3-1">
<ol class="org-ol">
<li>Applications that require lower latency on every packet sent must
be run on sockets with <code>TCP_NODELAY</code> enabled. It can be enabled
through the setsockopt command with the sockets API:
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">int one = 1;</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">setsockopt(descriptor, SOL_TCP, TCP_NODELAY, &amp;one, sizeof(one));</span>
</pre>
</div>
</li>
<li>For this to be used effectively, applications must avoid doing
small, logically related buffer writes. Because <code>TCP_NODELAY</code> is
enabled, these small writes will make TCP send these multiple
buffers as individual packets, which can result in poor overall
performance.

<p>
If applications have several buffers that are logically related, and
are to be sent as one packet, it is possible to build a contiguous
packet in memory and then send the logical packet to TCP on a
socket configured with <code>TCP_NODELAY</code>.
</p>
</li>
<li>Another option is to use <code>TCP_CORK</code>, which tells TCP to wait for the
application to remove the cork before sending any packets. This
command will cause the buffers it receives to be appended to the
existing buffers. This allows applications to build a packet in
kernel space, which can be required when using different libraries
that provides abstractions for layers. To enable <code>TCP_CORK</code>, set it
to a value of 1 using the <code>setsockopt</code> sockets API (this is known as
"corking the socket"):
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">int one = 1;</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">setsockopt(descriptor, SOL_TCP, TCP_CORK, &amp;one, sizeof(one));</span>
</pre>
</div>
</li>
<li>When the logical packet has been built in the kernel by the various
components in the application, tell TCP to remove the cork. TCP
will send the accumulated logical packet right away, without
waiting for any further packets from the application.

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">int zero = 0;</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">setsockopt(descriptor, SOL_TCP, TCP_CORK, &amp;zero, sizeof(zero));</span>
</pre>
</div>
</li>
</ol>
</div>
</li></ul>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">⁠4.6. Loading dynamic libraries</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Dynamic Libraries can be instructed to load at system startup by
setting the <code>LD_BIND_NOW</code> variable with ld.so, the dynamic
<code>linker/loader</code>.
</p>

<p>
The following is an example shell script. This script exports the
<code>LD_BIND_NOW</code> variable with a non-null value of 1, then runs a program
with a scheduler policy of FIFO and a priority of <code>1</code>.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">!/bin/</span><span style="color: #00ffff;">sh</span>

<span style="color: #eedd82;">LD_BIND_NOW</span>=1
<span style="color: #b0c4de;">export</span> LD_BIND_NOW

chrt --fifo 1 /opt/myapp/myapp-server &amp;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5">⁠4.7. Using _COARSE POSIX clocks for application timestamping</h3>
<div class="outline-text-3" id="text-6-5">
<p>
To illustrate that concept, imagine using a clock, inside a drawer, to
time events being observed. If every time one has to open the drawer,
get the clock and only then read the time, the cost of reading the
clock is too high and can lead to missing events or incorrectly
timestamping them.
</p>

<p>
Conversely, a clock on the wall would be faster to read, and
timestamping would produce less interference to the observed events.
Standing right in front of that wall clock would make it even faster
to obtain time readings.
</p>

<p>
The function used to read a given POSIX clock is <code>clock_gettime()</code>,
which is defined at <code>&lt;time.h&gt;</code>. <code>clock_gettime()</code> has a counterpart in the
kernel, in the form of a system call. When the user process calls
<code>clock_gettime()</code>, the corresponding C library (glibc) calls the
<code>sys_clock_gettime()</code> system call which performs the requested operation
and then returns the result to the user program.
</p>

<p>
However, this context switch from the user application to the kernel
has a cost. Even though this cost is very low, if the operation is
repeated thousands of times, the accumulated cost can have an impact
on the overall performance of the application. To avoid that context
switch to the kernel, thus making it faster to read the clock, support
for the <code>CLOCK_MONOTONIC_COARSE</code> and <code>CLOCK_REALTIME_COARSE</code> POSIX clocks
was created in the form of a VDSO library function.
</p>

<p>
Time readings performed by <code>clock_gettime()</code>, using one of the <code>_COARSE</code>
clock variants, do not require kernel intervention and are executed
entirely in user space, which yields a significant performance gain.
Time readings for <code>_COARSE</code> clocks have a millisecond (ms) resolution,
meaning that time intervals smaller than 1ms will not be recorded. The
<code>_COARSE</code> variants of the POSIX clocks are suitable for any application
that can accommodate millisecond clock resolution, and the benefits
are more evident on systems which use hardware clocks with high
reading costs.
</p>

<p>
Usually the only required change is to replace <code>CLOCK_MONOTONIC</code> with
 <code>CLOCK_MONOTONIC_COARSE</code> on the <code>clock_gettime()</code> calls in the source
 code, for example:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;time.h&gt;</span>
<span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rc</span>;
  <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span> <span style="color: #eedd82;">ts</span>;

  <span style="color: #00ffff;">for</span> (i=0; i&lt;10000000; i++) {
    rc = clock_gettime(CLOCK_MONOTONIC_COARSE, &amp;ts);
  }
}
</pre>
</div>

<p>
Programs using the <code>clock_gettime()</code> function must be linked with the <code>rt</code>
library by adding '-lrt' to the gcc command line.
</p>
<div class="org-src-container">

<pre class="src src-sh">cc clock_timing.c -o clock_timing -lrt
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6">⁠4.8. About Perf</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Perf is included in Linux kernels 2.6 and above as a performance
analysis tool. It presents a simple command line interface and
separates the CPU hardware difference in Linux performance
measurements. Perf is based on the <code>perf_events</code> interface exported by
the kernel.
</p>

<p>
One advantage of perf is that it is both kernel and architecture
neutral. The analysis data can be reviewed without requiring specific
system configuration.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">⁠Appendix A. Event Tracing</h2>
<div class="outline-text-2" id="text-7">
<div class="org-src-container">

<pre class="src src-sh">Event Tracing

                Documentation written by Theodore Ts<span style="color: #ffa07a;">'o</span>
<span style="color: #ffa07a;">                Updated by Li Zefan and Tom Zanussi</span>

<span style="color: #ffa07a;">1. Introduction</span>
<span style="color: #ffa07a;">===============</span>

<span style="color: #ffa07a;">Tracepoints (see Documentation/trace/tracepoints.txt) can be used</span>
<span style="color: #ffa07a;">without creating custom kernel modules to register probe functions</span>
<span style="color: #ffa07a;">using the event tracing infrastructure.</span>

<span style="color: #ffa07a;">Not all tracepoints can be traced using the event tracing system;</span>
<span style="color: #ffa07a;">the kernel developer must provide code snippets which define how the</span>
<span style="color: #ffa07a;">tracing information is saved into the tracing buffer, and how the</span>
<span style="color: #ffa07a;">tracing information should be printed.</span>

<span style="color: #ffa07a;">2. Using Event Tracing</span>
<span style="color: #ffa07a;">======================</span>

<span style="color: #ffa07a;">2.1 Via the '</span>set_event<span style="color: #ffa07a;">' interface</span>
<span style="color: #ffa07a;">---------------------------------</span>

<span style="color: #ffa07a;">The events which are available for tracing can be found in the file</span>
<span style="color: #ffa07a;">/sys/kernel/debug/tracing/available_events.</span>

<span style="color: #ffa07a;">To enable a particular event, such as '</span>sched_wakeup<span style="color: #ffa07a;">', simply echo it</span>
<span style="color: #ffa07a;">to /sys/kernel/debug/tracing/set_event. For example:</span>

<span style="color: #ffa07a;">        # echo sched_wakeup &gt;&gt; /sys/kernel/debug/tracing/set_event</span>

<span style="color: #ffa07a;">[ Note: '</span>&gt;&gt;<span style="color: #ffa07a;">' is necessary, otherwise it will firstly disable</span>
<span style="color: #ffa07a;">  all the events. ]</span>

<span style="color: #ffa07a;">To disable an event, echo the event name to the set_event file prefixed</span>
<span style="color: #ffa07a;">with an exclamation point:</span>

<span style="color: #ffa07a;">        # echo '</span>!sched_wakeup<span style="color: #ffa07a;">' &gt;&gt; /sys/kernel/debug/tracing/set_event</span>

<span style="color: #ffa07a;">To disable all events, echo an empty line to the set_event file:</span>

<span style="color: #ffa07a;">        # echo &gt; /sys/kernel/debug/tracing/set_event</span>

<span style="color: #ffa07a;">To enable all events, echo '</span>*:*<span style="color: #ffa07a;">' or '</span>*:<span style="color: #ffa07a;">' to the set_event file:</span>

<span style="color: #ffa07a;">        # echo *:* &gt; /sys/kernel/debug/tracing/set_event</span>

<span style="color: #ffa07a;">The events are organized into subsystems, such as ext4, irq, sched,</span>
<span style="color: #ffa07a;">etc., and a full event name looks like this: &lt;subsystem&gt;:&lt;event&gt;.  The</span>
<span style="color: #ffa07a;">subsystem name is optional, but it is displayed in the available_events</span>
<span style="color: #ffa07a;">file.  All of the events in a subsystem can be specified via the syntax</span>
<span style="color: #ffa07a;">"&lt;subsystem&gt;:*"; for example, to enable all irq events, you can use the</span>
<span style="color: #ffa07a;">command:</span>

<span style="color: #ffa07a;">        # echo '</span>irq:*<span style="color: #ffa07a;">' &gt; /sys/kernel/debug/tracing/set_event</span>

<span style="color: #ffa07a;">2.2 Via the '</span>enable<span style="color: #ffa07a;">' toggle</span>
<span style="color: #ffa07a;">---------------------------</span>

<span style="color: #ffa07a;">The events available are also listed in /sys/kernel/debug/tracing/events/ hierarchy</span>
<span style="color: #ffa07a;">of directories.</span>

<span style="color: #ffa07a;">To enable event '</span>sched_wakeup<span style="color: #ffa07a;">':</span>

<span style="color: #ffa07a;">        # echo 1 &gt; /sys/kernel/debug/tracing/events/sched/sched_wakeup/enable</span>

<span style="color: #ffa07a;">To disable it:</span>

<span style="color: #ffa07a;">        # echo 0 &gt; /sys/kernel/debug/tracing/events/sched/sched_wakeup/enable</span>

<span style="color: #ffa07a;">To enable all events in sched subsystem:</span>

<span style="color: #ffa07a;">        # echo 1 &gt; /sys/kernel/debug/tracing/events/sched/enable</span>

<span style="color: #ffa07a;">To enable all events:</span>

<span style="color: #ffa07a;">        # echo 1 &gt; /sys/kernel/debug/tracing/events/enable</span>

<span style="color: #ffa07a;">When reading one of these enable files, there are four results:</span>

<span style="color: #ffa07a;"> 0 - all events this file affects are disabled</span>
<span style="color: #ffa07a;"> 1 - all events this file affects are enabled</span>
<span style="color: #ffa07a;"> X - there is a mixture of events enabled and disabled</span>
<span style="color: #ffa07a;"> ? - this file does not affect any event</span>

<span style="color: #ffa07a;">2.3 Boot option</span>
<span style="color: #ffa07a;">---------------</span>

<span style="color: #ffa07a;">In order to facilitate early boot debugging, use boot option:</span>

<span style="color: #ffa07a;">        trace_event=[event-list]</span>

<span style="color: #ffa07a;">The format of this boot option is the same as described in section 2.1.</span>

<span style="color: #ffa07a;">3. Defining an event-enabled tracepoint</span>
<span style="color: #ffa07a;">=======================================</span>

<span style="color: #ffa07a;">See The example provided in samples/trace_events</span>

<span style="color: #ffa07a;">4. Event formats</span>
<span style="color: #ffa07a;">================</span>

<span style="color: #ffa07a;">Each trace event has a '</span>format<span style="color: #ffa07a;">' file associated with it that contains</span>
<span style="color: #ffa07a;">a description of each field in a logged event.  This information can</span>
<span style="color: #ffa07a;">be used to parse the binary trace stream, and is also the place to</span>
<span style="color: #ffa07a;">find the field names that can be used in event filters (see section 5).</span>

<span style="color: #ffa07a;">It also displays the format string that will be used to print the</span>
<span style="color: #ffa07a;">event in text mode, along with the event name and ID used for</span>
<span style="color: #ffa07a;">profiling.</span>

<span style="color: #ffa07a;">Every event has a set of '</span>common<span style="color: #ffa07a;">' fields associated with it; these are</span>
<span style="color: #ffa07a;">the fields prefixed with '</span>common_<span style="color: #ffa07a;">'.  The other fields vary between</span>
<span style="color: #ffa07a;">events and correspond to the fields defined in the TRACE_EVENT</span>
<span style="color: #ffa07a;">definition for that event.</span>

<span style="color: #ffa07a;">Each field in the format has the form:</span>

<span style="color: #ffa07a;">     field:field-type field-name; offset:N; size:N; signed:N;</span>

<span style="color: #ffa07a;">where offset is the offset of the field in the trace record and size</span>
<span style="color: #ffa07a;">is the size of the data item, in bytes, signed will be 0 or 1 denoting</span>
<span style="color: #ffa07a;">if the type of field is signed or not.</span>

<span style="color: #ffa07a;">For example, here'</span>s the information displayed for the <span style="color: #ffa07a;">'sched_wakeup'</span>
event:

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /sys/kernel/debug/tracing/events/sched/sched_wakeup/format</span>
name: sched_wakeup
ID: 62
format:
        field:unsigned short common_type;       offset:0;       size:2; signed:0;
        field:unsigned char common_flags;       offset:2;       size:1; signed:0;
        field:unsigned char common_preempt_count;       offset:3;       size:1; signed:0;
        field:int common_pid;   offset:4;       size:4; signed:1;
        field:int common_lock_depth;    offset:8;       size:4; signed:1;

        field:char comm[TASK_COMM_LEN]; offset:12;      size:16;        signed:1;
        field:pid_t pid;        offset:28;      size:4; signed:1;
        field:int prio; offset:32;      size:4; signed:1;
        field:int success;      offset:36;      size:4; signed:1;
        field:int target_cpu;   offset:40;      size:4; signed:1;

<span style="color: #b0c4de;">print</span> fmt: <span style="color: #ffa07a;">"comm=%s pid=%d prio=%d success=%d target_cpu=%03d"</span>, REC-&gt;comm, REC-&gt;pid, REC-&gt;prio, REC-&gt;success, REC-&gt;target_cpu

This event contains 10 fields, the first 5 common and the remaining 5
event-specific.  All the fields for this event are numeric, except for
<span style="color: #ffa07a;">'comm'</span> which is a string, a distinction important for event filtering.

5. Event filtering
==================

Trace events can be filtered<span style="color: #00ffff;"> in</span> the kernel by associating boolean
<span style="color: #ffa07a;">'filter expressions'</span> with them.  As soon as an event is logged into
the trace buffer, its fields are checked against the filter expression
associated with that event type.  An event with field values that
<span style="color: #ffa07a;">'match'</span> the filter will appear<span style="color: #00ffff;"> in</span> the trace output, and an event whose
values don<span style="color: #ffa07a;">'t match will be discarded.  An event with no filter</span>
<span style="color: #ffa07a;">associated with it matches everything, and is the default when no</span>
<span style="color: #ffa07a;">filter has been set for an event.</span>

<span style="color: #ffa07a;">5.1 Expression syntax</span>
<span style="color: #ffa07a;">---------------------</span>

<span style="color: #ffa07a;">A filter expression consists of one or more '</span>predicates<span style="color: #ffa07a;">' that can be</span>
<span style="color: #ffa07a;">combined using the logical operators '</span>&amp;&amp;<span style="color: #ffa07a;">' and '</span>||<span style="color: #ffa07a;">'.  A predicate is</span>
<span style="color: #ffa07a;">simply a clause that compares the value of a field contained within a</span>
<span style="color: #ffa07a;">logged event with a constant value and returns either 0 or 1 depending</span>
<span style="color: #ffa07a;">on whether the field value matched (1) or didn'</span>t match (0):

          field-name relational-operator value

Parentheses can be used to provide arbitrary logical groupings and
double-quotes can be used to prevent the shell from interpreting
operators as shell meta characters.

The field-names available for use<span style="color: #00ffff;"> in</span> filters can be found<span style="color: #00ffff;"> in</span> the
<span style="color: #ffa07a;">'format'</span> files for trace events (see section 4).

The relational-operators depend on the type of the field being tested:

The operators available for numeric fields are:

==, !=, &lt;, &lt;=, &gt;, &gt;=

And for string fields they are:

==, !=

Currently, only exact string matches are supported.

Currently, the maximum number of predicates<span style="color: #00ffff;"> in</span> a filter is 16.

5.2 Setting filters
-------------------

A filter for an individual event is set by writing a filter expression
to the <span style="color: #ffa07a;">'filter'</span> file for the given event.

For example:

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cd /sys/kernel/debug/tracing/events/sched/sched_wakeup</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo "common_preempt_count &gt; 4" &gt; filter</span>

A slightly more involved example:

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cd /sys/kernel/debug/tracing/events/signal/signal_generate</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo "((sig &gt;= 10 &amp;&amp; sig &lt; 15) || sig == 17) &amp;&amp; comm != bash" &gt; filter</span>

If there is an error<span style="color: #00ffff;"> in</span> the expression, you<span style="color: #ffa07a;">'ll get an '</span>Invalid
argument<span style="color: #ffa07a;">' error when setting it, and the erroneous string along with</span>
<span style="color: #ffa07a;">an error message can be seen by looking at the filter e.g.:</span>

<span style="color: #ffa07a;"># cd /sys/kernel/debug/tracing/events/signal/signal_generate</span>
<span style="color: #ffa07a;"># echo "((sig &gt;= 10 &amp;&amp; sig &lt; 15) || dsig == 17) &amp;&amp; comm != bash" &gt; filter</span>
<span style="color: #ffa07a;">-bash: echo: write error: Invalid argument</span>
<span style="color: #ffa07a;"># cat filter</span>
<span style="color: #ffa07a;">((sig &gt;= 10 &amp;&amp; sig &lt; 15) || dsig == 17) &amp;&amp; comm != bash</span>
<span style="color: #ffa07a;">^</span>
<span style="color: #ffa07a;">parse_error: Field not found</span>

<span style="color: #ffa07a;">Currently the caret ('</span>^<span style="color: #ffa07a;">') for an error always appears at the beginning of</span>
<span style="color: #ffa07a;">the filter string; the error message should still be useful though</span>
<span style="color: #ffa07a;">even without more accurate position info.</span>

<span style="color: #ffa07a;">5.3 Clearing filters</span>
<span style="color: #ffa07a;">--------------------</span>

<span style="color: #ffa07a;">To clear the filter for an event, write a '</span>0<span style="color: #ffa07a;">' to the event'</span>s filter
file.

To clear the filters for all events<span style="color: #00ffff;"> in</span> a subsystem, write a <span style="color: #ffa07a;">'0'</span> to the
subsystem<span style="color: #ffa07a;">'s filter file.</span>

<span style="color: #ffa07a;">5.3 Subsystem filters</span>
<span style="color: #ffa07a;">---------------------</span>

<span style="color: #ffa07a;">For convenience, filters for every event in a subsystem can be set or</span>
<span style="color: #ffa07a;">cleared as a group by writing a filter expression into the filter file</span>
<span style="color: #ffa07a;">at the root of the subsystem.  Note however, that if a filter for any</span>
<span style="color: #ffa07a;">event within the subsystem lacks a field specified in the subsystem</span>
<span style="color: #ffa07a;">filter, or if the filter can'</span>t be applied for any other reason, the
filter for that event will retain its previous setting.  This can
result<span style="color: #00ffff;"> in</span> an unintended mixture of filters which could lead to
<span style="color: #87cefa;">confusing</span> (to the user who might think different filters are<span style="color: #00ffff;"> in</span>
effect) trace output.  Only filters that reference just the common
fields can be guaranteed to propagate successfully to all events.

Here are a few subsystem filter examples that also illustrate the
above points:

Clear the filters on all events<span style="color: #00ffff;"> in</span> the sched subsytem:

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cd /sys/kernel/debug/tracing/events/sched</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 0 &gt; filter</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat sched_switch/filter</span>
none
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat sched_wakeup/filter</span>
none

Set a filter using only common fields for all events<span style="color: #00ffff;"> in</span> the sched
<span style="color: #87cefa;">subsytem</span> (all events end up with the same filter):

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cd /sys/kernel/debug/tracing/events/sched</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo common_pid == 0 &gt; filter</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat sched_switch/filter</span>
<span style="color: #eedd82;">common_pid</span> == 0
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat sched_wakeup/filter</span>
<span style="color: #eedd82;">common_pid</span> == 0

Attempt to set a filter using a non-common field for all events<span style="color: #00ffff;"> in</span> the
<span style="color: #b0c4de;">sched</span> subsytem (all events but those that have a prev_pid field retain
their old filters):

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cd /sys/kernel/debug/tracing/events/sched</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo prev_pid == 0 &gt; filter</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat sched_switch/filter</span>
<span style="color: #eedd82;">prev_pid</span> == 0
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat sched_wakeup/filter</span>
<span style="color: #eedd82;">common_pid</span> == 0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">⁠Appendix B. Function Tracer</h2>
<div class="outline-text-2" id="text-8">
<div class="org-src-container">

<pre class="src src-sh">ftrace - Linux kernel internal tracer

Introduction
------------

Ftrace is an internal tracer for the Linux kernel. It is designed to
follow the processing of what happens within the kernel as that is
normally a black box. It allows the user to trace kernel functions
that are called<span style="color: #00ffff;"> in</span> real time, as well as to see various events like
tasks scheduling, interrupts, disk activity and other services that
the kernel provides.

Ftrace was intorduced to Linux<span style="color: #00ffff;"> in</span> the 2.6.27 kernel, and has increased
<span style="color: #00ffff;">in</span> functionality ever since. It is not meant to trace what is happening
inside user applications, but can be used to trace within system calls
that user applications make.


The Debug File System
---------------------

The user interface for ftrace is a series of files within the debug
file system that is usually mounted at /sys/kernel/debug. The ftrace
files are<span style="color: #00ffff;"> in</span> the tracing directory that can be accessed at
/sys/kernel/debug/tracing.

Note, there is also a user interface tool called trace-cmd. See later
<span style="color: #00ffff;">in</span> this document for more information about that tool.

In order to mount the debug filesystem, perform the following:

 mount -t debugfs nodev /sys/kernel/debug

Then you can change directory into the ftrace tracing location:

 <span style="color: #b0c4de;">cd</span> /sys/kernel/debug/tracing

Note, all these files can only be modified by root user, as enabling
tracing can have an impact on the performance of the system.


Ftrace files
------------

The main files within this directory are:

 trace - the file that shows the output of a ftrace trace. This is
       really a snapshot of the trace<span style="color: #00ffff;"> in</span> time, as it stops tracing as
       this file is read, and it does not consume the events read.
       That is, if the user disabled tracing and read this file, it
       will always report the same thing every time its read.

       Also, to clear the trace buffer, simply write into this file.

          &gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo &gt; trace</span>

       This will erase the entire contents of the trace buffer.

 trace_pipe - like <span style="color: #ffa07a;">"trace"</span> but is used to read the trace live. It is
       a producer / consumer trace, where each read will consume the
       event that is read. But this can be used to see an active trace
       without stopping the trace as it is read.

 available_tracers - a list of ftrace tracers that have been compiled
       into the kernel.

 current_tracer   - enables or disables a ftrace tracer

 events - a directory that contains events to trace and can be used
       to enable or disable events as well as set filters for the events

 tracing_on - disable and enable recording to the ftrace buffer.
       Note, disabling tracing via the tracing_on file does not disable
       the actual tracing that is happening inside the kernel. It only
       disables writing to the buffer. The work to do the trace still
       happens, but the data does not go anywhere.

There are several other files, but we will get to them as they come
up with functionalities of the tracers.


Tracers and Events
------------------

Tracers have specific functionality within the kernel, where as events
are just some kind of data that is recorded into the ftrace buffer.
To understand this more, we need to take a look at the tracers themselves
and the events as well.

nop
---

The default tracer is called <span style="color: #ffa07a;">"nop"</span>. It is just a nop tracer, and does not
provide any tracing facility itself. But, as events may interleave into
any tracer, the <span style="color: #ffa07a;">"nop"</span> tracer is what is used if you are only interested
<span style="color: #00ffff;">in</span> tracing events.

When the <span style="color: #ffa07a;">"nop"</span> tracer is active and the trace buffer is empty, the <span style="color: #ffa07a;">"trace"</span>
file shows the following:

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat trace</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">tracer: nop</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">entries-in-buffer/entries-written: 0/0   #P:8</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;">#                              </span><span style="color: #ff7f24;">_-------=&gt; irqs-off          </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">/  _------=&gt; need-resched      </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|/  _-----=&gt; need-resched_lazy </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||/  _----=&gt; hardirq/softirq   </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|||/  _---=&gt; preempt-depth     </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||||/  _--=&gt; preempt-lazy-depth</span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|||||| /     delay</span>
<span style="color: #ff7f24;">#           </span><span style="color: #ff7f24;">TASK-PID   CPU#  |||||||    TIMESTAMP  FUNCTION</span>
<span style="color: #ff7f24;">#              </span><span style="color: #ff7f24;">| |       |   |||||||       |         |</span>


It starts with what tracer is active and then gives a default header.

Now to enable an event, you must write an ASCII <span style="color: #ffa07a;">'1'</span> into the <span style="color: #ffa07a;">"enable"</span>
file for the particular event.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 1 &gt; events/sched/sched_switch/enable</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat trace</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">tracer: nop</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">entries-in-buffer/entries-written: 463/463   #P:8</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;">#                              </span><span style="color: #ff7f24;">_-------=&gt; irqs-off          </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">/  _------=&gt; need-resched      </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|/  _-----=&gt; need-resched_lazy </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||/  _----=&gt; hardirq/softirq   </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|||/  _---=&gt; preempt-depth     </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||||/  _--=&gt; preempt-lazy-depth</span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|||||| /     delay</span>
<span style="color: #ff7f24;">#           </span><span style="color: #ff7f24;">TASK-PID   CPU#  |||||||    TIMESTAMP  FUNCTION</span>
<span style="color: #ff7f24;">#              </span><span style="color: #ff7f24;">| |       |   |||||||       |         |</span>
            bash-1367  [007] d...... 11927.750484: sched_switch: <span style="color: #eedd82;">prev_comm</span>=bash <span style="color: #eedd82;">prev_pid</span>=1367 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">S</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=kworker/7:1 <span style="color: #eedd82;">next_pid</span>=121 <span style="color: #eedd82;">next_prio</span>=120
     kworker/7:1-121   [007] d...... 11927.750514: sched_switch: <span style="color: #eedd82;">prev_comm</span>=kworker/7:1 <span style="color: #eedd82;">prev_pid</span>=121 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">S</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=swapper/7 <span style="color: #eedd82;">next_pid</span>=0 <span style="color: #eedd82;">next_prio</span>=120
          &lt;idle&gt;-0     [000] d...... 11927.750531: sched_switch: <span style="color: #eedd82;">prev_comm</span>=swapper/0 <span style="color: #eedd82;">prev_pid</span>=0 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">R</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=sshd <span style="color: #eedd82;">next_pid</span>=1365 <span style="color: #eedd82;">next_prio</span>=120
          &lt;idle&gt;-0     [007] d...... 11927.750555: sched_switch: <span style="color: #eedd82;">prev_comm</span>=swapper/7 <span style="color: #eedd82;">prev_pid</span>=0 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">R</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=kworker/7:1 <span style="color: #eedd82;">next_pid</span>=121 <span style="color: #eedd82;">next_prio</span>=120
     kworker/7:1-121   [007] d...... 11927.750575: sched_switch: <span style="color: #eedd82;">prev_comm</span>=kworker/7:1 <span style="color: #eedd82;">prev_pid</span>=121 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">S</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=swapper/7 <span style="color: #eedd82;">next_pid</span>=0 <span style="color: #eedd82;">next_prio</span>=120
            sshd-1365  [000] d...... 11927.750673: sched_switch: <span style="color: #eedd82;">prev_comm</span>=sshd <span style="color: #eedd82;">prev_pid</span>=1365 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">S</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=swapper/0 <span style="color: #eedd82;">next_pid</span>=0 <span style="color: #eedd82;">next_prio</span>=120
          &lt;idle&gt;-0     [001] d...... 11927.752568: sched_switch: <span style="color: #eedd82;">prev_comm</span>=swapper/1 <span style="color: #eedd82;">prev_pid</span>=0 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">R</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=kworker/1:1 <span style="color: #eedd82;">next_pid</span>=57 <span style="color: #eedd82;">next_prio</span>=120
          &lt;idle&gt;-0     [002] d...... 11927.752589: sched_switch: <span style="color: #eedd82;">prev_comm</span>=swapper/2 <span style="color: #eedd82;">prev_pid</span>=0 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">R</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=rcu_sched <span style="color: #eedd82;">next_pid</span>=10 <span style="color: #eedd82;">next_prio</span>=120
     kworker/1:1-57    [001] d...... 11927.752590: sched_switch: <span style="color: #eedd82;">prev_comm</span>=kworker/1:1 <span style="color: #eedd82;">prev_pid</span>=57 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">S</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=swapper/1 <span style="color: #eedd82;">next_pid</span>=0 <span style="color: #eedd82;">next_prio</span>=120
       rcu_sched-10    [002] d...... 11927.752610: sched_switch: <span style="color: #eedd82;">prev_comm</span>=rcu_sched <span style="color: #eedd82;">prev_pid</span>=10 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">S</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=swapper/2 <span style="color: #eedd82;">next_pid</span>=0 <span style="color: #eedd82;">next_prio</span>=120
          &lt;idle&gt;-0     [007] d...... 11927.753548: sched_switch: <span style="color: #eedd82;">prev_comm</span>=swapper/7 <span style="color: #eedd82;">prev_pid</span>=0 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">R</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=rcu_sched <span style="color: #eedd82;">next_pid</span>=10 <span style="color: #eedd82;">next_prio</span>=120
       rcu_sched-10    [007] d...... 11927.753568: sched_switch: <span style="color: #eedd82;">prev_comm</span>=rcu_sched <span style="color: #eedd82;">prev_pid</span>=10 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">S</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=swapper/7 <span style="color: #eedd82;">next_pid</span>=0 <span style="color: #eedd82;">next_prio</span>=120
          &lt;idle&gt;-0     [007] d...... 11927.755538: sched_switch: <span style="color: #eedd82;">prev_comm</span>=swapper/7 <span style="color: #eedd82;">prev_pid</span>=0 <span style="color: #eedd82;">prev_prio</span>=120 <span style="color: #eedd82;">prev_state</span>=<span style="color: #eedd82;">R</span> ==&gt; <span style="color: #eedd82;">next_comm</span>=kworker/7:1 <span style="color: #eedd82;">next_pid</span>=121 <span style="color: #eedd82;">next_prio</span>=120


As you can see there is quite a lot of information that is displayed
by simply enabling the sched_switch event.

Events
------

The events are broken up into <span style="color: #ffa07a;">"systems"</span>. Each system of events has its
own directory under the <span style="color: #ffa07a;">"events"</span> directory located<span style="color: #00ffff;"> in</span> the ftrace <span style="color: #ffa07a;">"tracing"</span>
directory<span style="color: #00ffff;"> in</span> the debug file system.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ls -F events</span>
block/       header_event  lock/     printk/        skb/       vsyscall/
compaction/  header_page   mce/      random/        sock/      workqueue/
drm/         i915/         migrate/  raw_syscalls/  sunrpc/    writeback/
<span style="color: #b0c4de;">enable</span>       irq/          module/   rcu/           syscalls/
ext4/        jbd2/         napi/     rpm/           task/
ftrace/      kmem/         net/      sched/         timer/
hda/         kvm/          oom/      scsi/          udp/
hda_intel/   kvmmmu/       power/    signal/        vmscan/

Each of these directories represent a system or group of events. Notice that
there<span style="color: #ffa07a;">'s three files in this directory:</span>

<span style="color: #ffa07a;">enable</span>
<span style="color: #ffa07a;">header_event</span>
<span style="color: #ffa07a;">header_page</span>

<span style="color: #ffa07a;">The only one you should be concerned about is the "enable" file, as that</span>
<span style="color: #ffa07a;">will enable all events when an ASCII '</span>1<span style="color: #ffa07a;">' is written into it and disable</span>
<span style="color: #ffa07a;">all events when an ASCII '</span>0<span style="color: #ffa07a;">' is written into it.</span>

<span style="color: #ffa07a;">The header_event and header_page provides information necessary for</span>
<span style="color: #ffa07a;">the trace-cmd tool.</span>

<span style="color: #ffa07a;">Each of these directories shows the events that are within that system:</span>

<span style="color: #ffa07a;">&gt;# ls -F events/sched</span>
<span style="color: #ffa07a;">enable                   sched_process_exit/  sched_stat_sleep/</span>
<span style="color: #ffa07a;">filter                   sched_process_fork/  sched_stat_wait/</span>
<span style="color: #ffa07a;">sched_kthread_stop/      sched_process_free/  sched_switch/</span>
<span style="color: #ffa07a;">sched_kthread_stop_ret/  sched_process_wait/  sched_wait_task/</span>
<span style="color: #ffa07a;">sched_migrate_task/      sched_stat_blocked/  sched_wakeup/</span>
<span style="color: #ffa07a;">sched_pi_setprio/        sched_stat_iowait/   sched_wakeup_new/</span>
<span style="color: #ffa07a;">sched_process_exec/      sched_stat_runtime/</span>


<span style="color: #ffa07a;">Each directory here represents a single event. Notice that there'</span>s two
files<span style="color: #00ffff;"> in</span> the system directory:

<span style="color: #b0c4de;">enable</span>
filter

The <span style="color: #ffa07a;">"enable"</span> file here can enable or disable all events within the system
when an ASCII <span style="color: #ffa07a;">'1'</span> or <span style="color: #ffa07a;">'0'</span>, respectively, is written to this file.

The <span style="color: #ffa07a;">"filter"</span> file will be described shortly.


Within the individual event directories exist control files:

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ls -F events/sched/sched_wakeup/</span>
<span style="color: #b0c4de;">enable</span>  filter  format  id


We already used the <span style="color: #ffa07a;">"enable"</span> file. Now to explain the other files.

The <span style="color: #ffa07a;">"format"</span> file shows the fields that are written when the event
is enabled, as well as the fields that can be used for the filter.

The <span style="color: #ffa07a;">"id"</span> file is used by the perf tool and is not something that needs
to be delt with here.


&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat events/sched/sched_wakeup/format</span>
name: sched_wakeup
ID: 249
format:
        field:unsigned short common_type;        offset:0;        size:2;        signed:0;
        field:unsigned char common_flags;        offset:2;        size:1;        signed:0;
        field:unsigned char common_preempt_count;        offset:3;        size:1;        signed:0;
        field:int common_pid;        offset:4;        size:4;        signed:1;
        field:unsigned short common_migrate_disable;        offset:8;        size:2;        signed:0;
        field:unsigned short common_padding;        offset:10;        size:2;        signed:0;

        field:char comm[16];        offset:16;        size:16;        signed:1;
        fieldid_t pid;        offset:32;        size:4;        signed:1;
        field:int prio;        offset:36;        size:4;        signed:1;
        field:int success;        offset:40;        size:4;        signed:1;
        field:int target_cpu;        offset:44;        size:4;        signed:1;

<span style="color: #b0c4de;">print</span> fmt: <span style="color: #ffa07a;">"comm=%s pid=%d prio=%d success=%d target_cpu=%03d"</span>, REC-&gt;comm, REC-&gt;pid, REC-&gt;prio, REC-&gt;success, REC-&gt;target_cpu


This file is also used by perf and trace-cmd to tell how to read the
raw binary output from the tracing buffers for the event. But what you
need to know is the field names, as they are used by the filtering.

The first set of fields before the blank line are the common fields that
exist for all events. The specific fields for the event come after the
blank line and here it starts with <span style="color: #ffa07a;">"comm"</span>.


Filtering events
----------------

There are times when you may not want to trace all events, but only
events where one of the event<span style="color: #ffa07a;">'s fields contains a certain value.</span>
<span style="color: #ffa07a;">The "filter" file allows for this.</span>

<span style="color: #ffa07a;">The filter provides the following predicates:</span>

<span style="color: #ffa07a;">For numerical fields:</span>

<span style="color: #ffa07a;"> ==, !=, &lt;, &lt;=, &gt;, &gt;=</span>


<span style="color: #ffa07a;">For string fields:</span>

<span style="color: #ffa07a;"> ==, !=, ~</span>


<span style="color: #ffa07a;">Logical &amp;&amp; and || as well as parenthesis are also acceptable.</span>

<span style="color: #ffa07a;">The syntax is</span>

<span style="color: #ffa07a;"> &lt;filter&gt; = FIELD &lt;pred-num&gt; | FIELD &lt;pred-string&gt; |</span>
<span style="color: #ffa07a;">    '</span>(<span style="color: #ffa07a;">' &lt;filter&gt; '</span>)<span style="color: #ffa07a;">' | &lt;filter&gt; '</span>&amp;&amp;<span style="color: #ffa07a;">' &lt;filter&gt; | &lt;filter&gt; '</span>||<span style="color: #ffa07a;">' &lt;filter&gt;</span>

<span style="color: #ffa07a;"> &lt;pred-num&gt; = &lt;num-op&gt; &lt;number&gt;</span>

<span style="color: #ffa07a;"> &lt;pred-string&gt; = &lt;string-op&gt; &lt;string&gt;</span>

<span style="color: #ffa07a;"> &lt;num-op&gt; = '</span>==<span style="color: #ffa07a;">' | '</span>!=<span style="color: #ffa07a;">' | '</span>&lt;<span style="color: #ffa07a;">' | '</span>&lt;=<span style="color: #ffa07a;">' | '</span>&gt;<span style="color: #ffa07a;">' | '</span>&gt;=<span style="color: #ffa07a;">'</span>

<span style="color: #ffa07a;"> &lt;string-op&gt; = '</span>==<span style="color: #ffa07a;">' | '</span>!=<span style="color: #ffa07a;">' | '</span>~<span style="color: #ffa07a;">'</span>

<span style="color: #ffa07a;"> &lt;number&gt; = &lt;digits&gt; | '</span>0x<span style="color: #ffa07a;">'&lt;hex-number&gt; </span>

<span style="color: #ffa07a;"> &lt;digits&gt; = [0-9] | &lt;digits&gt;&lt;digits&gt;</span>

<span style="color: #ffa07a;"> &lt;hex-number&gt; = [0-9] | [a-f] | [A-F] | &lt;hex-number&gt;&lt;hex-number&gt;</span>

<span style="color: #ffa07a;"> &lt;string&gt; = '"' VALUE '"'</span>

<span style="color: #ffa07a;">The glob expression '</span>~<span style="color: #ffa07a;">' is a very simple glob. it can only be:</span>

<span style="color: #ffa07a;"> &lt;glob&gt; = VALUE | '</span>*<span style="color: #ffa07a;">' VALUE | VALUE '</span>*<span style="color: #ffa07a;">' | '</span>*<span style="color: #ffa07a;">' VALUE '</span>*<span style="color: #ffa07a;">'</span>

<span style="color: #ffa07a;">That is, anything more complex will not be valid. Such as:</span>

<span style="color: #ffa07a;">  VALUE '</span>*<span style="color: #ffa07a;">' VALUE</span>


<span style="color: #ffa07a;">What the glob does is to match a string with wild cards at the beginning</span>
<span style="color: #ffa07a;">or end or both, of a value:</span>

<span style="color: #ffa07a;">  comm ~ "kwork*"</span>


<span style="color: #ffa07a;">Example:</span>

<span style="color: #ffa07a;">To trace all schedule switches to a real time task:</span>

<span style="color: #ffa07a;">&gt;# echo '</span>next_prio &lt; 100<span style="color: #ffa07a;">' &gt; events/sched/sched_switch/filter</span>
<span style="color: #ffa07a;">&gt;# cat events/sched/sched_switch/filter</span>
<span style="color: #ffa07a;">next_prio &lt; 100</span>
<span style="color: #ffa07a;">&gt;# cat trace</span>
<span style="color: #ffa07a;"># tracer: nop</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;"># entries-in-buffer/entries-written: 11/11   #P:8</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;">#                              _-------=&gt; irqs-off          </span>
<span style="color: #ffa07a;">#                            /  _------=&gt; need-resched      </span>
<span style="color: #ffa07a;">#                            |/  _-----=&gt; need-resched_lazy </span>
<span style="color: #ffa07a;">#                            ||/  _----=&gt; hardirq/softirq   </span>
<span style="color: #ffa07a;">#                            |||/  _---=&gt; preempt-depth     </span>
<span style="color: #ffa07a;">#                            ||||/  _--=&gt; preempt-lazy-depth</span>
<span style="color: #ffa07a;">#                            ||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ffa07a;">#                            |||||| /     delay</span>
<span style="color: #ffa07a;">#           TASK-PID   CPU#  |||||||    TIMESTAMP  FUNCTION</span>
<span style="color: #ffa07a;">#              | |       |   |||||||       |         |</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [001] d...... 14331.192687: sched_switch: prev_comm=swapper/1 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=rtkit-daemon next_pid=992 next_prio=0</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [001] d...... 14333.737030: sched_switch: prev_comm=swapper/1 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=watchdog/1 next_pid=12 next_prio=0</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [000] d...... 14333.738023: sched_switch: prev_comm=swapper/0 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=watchdog/0 next_pid=11 next_prio=0</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [002] d...... 14333.751985: sched_switch: prev_comm=swapper/2 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=watchdog/2 next_pid=17 next_prio=0</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [003] d...... 14333.765947: sched_switch: prev_comm=swapper/3 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=watchdog/3 next_pid=22 next_prio=0</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [004] d...... 14333.779933: sched_switch: prev_comm=swapper/4 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=watchdog/4 next_pid=27 next_prio=0</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [005] d...... 14333.794114: sched_switch: prev_comm=swapper/5 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=watchdog/5 next_pid=32 next_prio=0</span>



<span style="color: #ffa07a;">Task priorities</span>
<span style="color: #ffa07a;">---------------</span>

<span style="color: #ffa07a;">This is a good time to explain task priorities, as the tracer reports them</span>
<span style="color: #ffa07a;">differently than the way user processes see priorities. A task has priority</span>
<span style="color: #ffa07a;">policies that are SCHED_OTHER, SCHED_FIFO and SCHED_RR. By default</span>
<span style="color: #ffa07a;">tasks are assigned SCHED_OTHER which runs under the kernels Completely</span>
<span style="color: #ffa07a;">Fail Scheduler (CFS), where as SCHED_FIFO and SCHED_RR runs under</span>
<span style="color: #ffa07a;">the real-time scheduler. The real-time scheduler has 99 different priorities</span>
<span style="color: #ffa07a;">ranging from 1 - 99, where 99 is the highest priority and 1 is the lowest.</span>
<span style="color: #ffa07a;">This is set by sched_setscheduler(2).</span>

<span style="color: #ffa07a;">If you noticed above, to show real time tasks, the filter used</span>
<span style="color: #ffa07a;">"next_prio &lt; 100". Ftrace reports the internal kernel version of priorities</span>
<span style="color: #ffa07a;">for tasks and not the priority that a task sees. This can be a little</span>
<span style="color: #ffa07a;">confusing. For user real-time priorities of 1 through 99 are mapped</span>
<span style="color: #ffa07a;">internally as 98 to 0, where 0 is the highest priority and 98 is the lowest</span>
<span style="color: #ffa07a;">of the real time priorities. All non real-time tasks show a priority of 120,</span>
<span style="color: #ffa07a;">as CFS does not use the priority to determine which tasks to run, although</span>
<span style="color: #ffa07a;">it does use a nice value, but that'</span>s not represented by the prio field
reported<span style="color: #00ffff;"> in</span> the traces.



Tracers
-------

Depending on how the kernel was configured, not all tracers may be available
<span style="color: #00ffff;">for</span> a given kernel.For the MRG kernels, the trace and debug kernels have
different tracers than the production kernel does. This is because some
of the tracers have a noticeable overhead when the tracer is configured
into the kernel but not active. Those tracers are only enabled for
the trace and debug kernels.


To see what tracers are available for the kernel, cat out the contents
of <span style="color: #ffa07a;">"available_tracers"</span>:

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat available_tracers </span>
function_graph wakeup_rt wakeup preemptirqsoff preemptoff irqsoff <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">nop</span>


The <span style="color: #ffa07a;">"nop"</span> tracer has already been discussed and is available<span style="color: #00ffff;"> in</span> all
kernels.


The <span style="color: #ffa07a;">"function"</span> tracer
---------------------

The most popular tracer aside from the <span style="color: #ffa07a;">"nop"</span> tracer is the <span style="color: #ffa07a;">"function"</span>
tracer. This tracer traces the <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">calls</span> within the kernel.
Depending on how many functions are tracer or which specific functions,
it can cause a very noticeable overhead when tracing is active.

Note, due to a clever trick with code modification, the <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">tracer</span>
induces very little overhead when not active. This is because the
hooks<span style="color: #00ffff;"> in</span> the <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">calls</span> to be traced are converted into nops on
boot, and are only converted back to hooks into the tracer when activated.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo function &gt; current_tracer</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat trace</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">tracer: function</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">entries-in-buffer/entries-written: 319338/253106705   #P:8</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;">#                              </span><span style="color: #ff7f24;">_-------=&gt; irqs-off          </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">/  _------=&gt; need-resched      </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|/  _-----=&gt; need-resched_lazy </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||/  _----=&gt; hardirq/softirq   </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|||/  _---=&gt; preempt-depth     </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||||/  _--=&gt; preempt-lazy-depth</span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|||||| /     delay</span>
<span style="color: #ff7f24;">#           </span><span style="color: #ff7f24;">TASK-PID   CPU#  |||||||    TIMESTAMP  FUNCTION</span>
<span style="color: #ff7f24;">#              </span><span style="color: #ff7f24;">| |       |   |||||||       |         |</span>
     kworker/5:1-58    [005] ....... 32462.200700: smp_call_function_single &lt;-cpufreq_get_measured_perf
     kworker/5:1-58    [005] d...... 32462.200700: read_measured_perf_ctrs &lt;-smp_call_function_single
     kworker/5:1-58    [005] ....... 32462.200701: cpufreq_cpu_put &lt;-__cpufreq_driver_getavg
     kworker/5:1-58    [005] ....... 32462.200702: module_put &lt;-cpufreq_cpu_put
     kworker/5:1-58    [005] ....... 32462.200702: od_check_cpu &lt;-dbs_check_cpu
     kworker/5:1-58    [005] ....... 32462.200702: usecs_to_jiffies &lt;-od_dbs_timer
     kworker/5:1-58    [005] ....... 32462.200703: schedule_delayed_work_on &lt;-od_dbs_timer
     kworker/5:1-58    [005] ....... 32462.200703: queue_delayed_work_on &lt;-schedule_delayed_work_on
     kworker/5:1-58    [005] d...... 32462.200704: __queue_delayed_work &lt;-queue_delayed_work_on
     kworker/5:1-58    [005] d...... 32462.200704: get_work_gcwq &lt;-__queue_delayed_work
     kworker/5:1-58    [005] d...... 32462.200704: get_cwq &lt;-__queue_delayed_work
     kworker/5:1-58    [005] d...... 32462.200705: add_timer_on &lt;-__queue_delayed_work
     kworker/5:1-58    [005] d...... 32462.200705: _raw_spin_lock_irqsave &lt;-add_timer_on
     kworker/5:1-58    [005] d...... 32462.200705: internal_add_timer &lt;-add_timer_on


Filtering on functions
----------------------

As tracing all functions can be induce a substantial overhead, as well
as adding a lot of noise to the trace (you may not be interested<span style="color: #00ffff;"> in</span> every
<span style="color: #00ffff;">function</span> <span style="color: #87cefa;">call</span>), ftrace provides a way to limit what functions can be
traced. There are two files for this purpose:

 set_ftrace_filter

 set_ftrace_notrace


For a list of functions that can be traced, as well as added to these files:

 available_filter_functions


By writing a name of a <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">into</span> the <span style="color: #ffa07a;">"set_ftrace_filter"</span> file, the
<span style="color: #00ffff;">function</span> <span style="color: #87cefa;">tracer</span> will only trace that function.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo schedule_delayed_work &gt; set_ftrace_filter</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat set_ftrace_filter</span>
schedule_delayed_work
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat trace</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">tracer: function</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">entries-in-buffer/entries-written: 8/8   #P:8</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;">#                              </span><span style="color: #ff7f24;">_-------=&gt; irqs-off          </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">/  _------=&gt; need-resched      </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|/  _-----=&gt; need-resched_lazy </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||/  _----=&gt; hardirq/softirq   </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|||/  _---=&gt; preempt-depth     </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||||/  _--=&gt; preempt-lazy-depth</span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|||||| /     delay</span>
<span style="color: #ff7f24;">#           </span><span style="color: #ff7f24;">TASK-PID   CPU#  |||||||    TIMESTAMP  FUNCTION</span>
<span style="color: #ff7f24;">#              </span><span style="color: #ff7f24;">| |       |   |||||||       |         |</span>
     kworker/0:2-1586  [000] ....... 32820.361913: schedule_delayed_work &lt;-vmstat_update
     kworker/2:1-62    [002] ....... 32820.370891: schedule_delayed_work &lt;-vmstat_update
     kworker/3:2-5004  [003] ....... 32820.373881: schedule_delayed_work &lt;-vmstat_update
     kworker/0:2-1586  [000] ....... 32820.448658: schedule_delayed_work &lt;-do_cache_clean
     kworker/4:1-61    [004] ....... 32820.537541: schedule_delayed_work &lt;-vmstat_update
     kworker/4:1-61    [004] ....... 32820.537546: schedule_delayed_work &lt;-sync_cmos_clock
     kworker/7:1-121   [007] ....... 32820.897372: schedule_delayed_work &lt;-vmstat_update
     kworker/1:1-57    [001] ....... 32820.898361: schedule_delayed_work &lt;-vmstat_update


Note, modifications to these files follows shell concatenation rules:

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat set_ftrace_filter</span>
schedule_delayed_work
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo do_IRQ &gt; set_ftrace_filter</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat set_ftrace_filter</span>
do_IRQ

Notice that writing with <span style="color: #ffa07a;">'&gt;'</span> into set_ftrace_filter cleared what was
currently<span style="color: #00ffff;"> in</span> the file and replaced it with the new contents. Just
writing into the file will clear it:

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat set_ftrace_filter</span>
do_IRQ
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo &gt; set_ftrace_filter</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat set_ftrace_filter</span>
<span style="color: #ff7f24;">#### </span><span style="color: #ff7f24;">all functions enabled ####</span>

To append to the list, use the shell append operation <span style="color: #ffa07a;">'&gt;&gt;'</span>:

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat set_ftrace_filter</span>
do_IRQ
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo schedule_delayed_work &gt;&gt; set_ftrace_filter</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat set_ftrace_filter</span>
schedule_delayed_work
do_IRQ


Note, the order of functions displayed has nothing to do with how they
were added. Their order is dependent upon how the functions are layed
out<span style="color: #00ffff;"> in</span> the kernel internal <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">list</span> table.


Globs
-----

Functions can be added to these files with the same type of glob
expressions described<span style="color: #00ffff;"> in</span> the event filtering section. The format is
identical:

 &lt;glob&gt; = VALUE | <span style="color: #ffa07a;">'*'</span> VALUE | VALUE <span style="color: #ffa07a;">'*'</span> | <span style="color: #ffa07a;">'*'</span> VALUE <span style="color: #ffa07a;">'*'</span>


If you want to trace all functions that start with <span style="color: #ffa07a;">"sched"</span>:

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 'sched*' &gt; set_ftrace_filter</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat set_ftrace_filter</span>
schedule_delayed_work_on
schedule_delayed_work
schedule_work_on
schedule_work
schedule_on_each_cpu
sched_feat_open
sched_feat_show
[...]
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo function &gt; current_tracer</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat trace</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">tracer: function</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">entries-in-buffer/entries-written: 1270/1270   #P:8</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;">#                              </span><span style="color: #ff7f24;">_-------=&gt; irqs-off          </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">/  _------=&gt; need-resched      </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|/  _-----=&gt; need-resched_lazy </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||/  _----=&gt; hardirq/softirq   </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|||/  _---=&gt; preempt-depth     </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||||/  _--=&gt; preempt-lazy-depth</span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ff7f24;">#                            </span><span style="color: #ff7f24;">|||||| /     delay</span>
<span style="color: #ff7f24;">#           </span><span style="color: #ff7f24;">TASK-PID   CPU#  |||||||    TIMESTAMP  FUNCTION</span>
<span style="color: #ff7f24;">#              </span><span style="color: #ff7f24;">| |       |   |||||||       |         |</span>
            bash-1367  [001] ....... 34240.654888: schedule_work &lt;-tty_flip_buffer_push
            bash-1367  [001] .N..... 34240.654902: schedule &lt;-sysret_careful
     kworker/1:1-57    [001] ....... 34240.654921: schedule &lt;-worker_thread
          &lt;idle&gt;-0     [000] .N..... 34240.654949: schedule &lt;-cpu_idle
            bash-1367  [001] ....... 34240.655069: schedule_work &lt;-tty_flip_buffer_push
            bash-1367  [001] .N..... 34240.655079: schedule &lt;-sysret_careful
            sshd-1365  [000] ....... 34240.655087: schedule_timeout &lt;-wait_for_common
            sshd-1365  [000] ....... 34240.655088: schedule &lt;-schedule_timeout



set_ftrace_notrace
------------------

There are cases were you may want to trace everything except for various
<span style="color: #b0c4de;">functions</span> that you don<span style="color: #ffa07a;">'t care about. Perhaps there'</span>s functions that cause
too much noise<span style="color: #00ffff;"> in</span> the trace, for example, perhaps locks are showing
up<span style="color: #00ffff;"> in</span> the trace and you don<span style="color: #ffa07a;">'t care about them:</span>

<span style="color: #ffa07a;">&gt;# echo '</span>*lock*<span style="color: #ffa07a;">' &gt; set_ftrace_notrace</span>
<span style="color: #ffa07a;">&gt;# cat set_ftrace_notrace</span>
<span style="color: #ffa07a;">update_persistent_clock</span>
<span style="color: #ffa07a;">read_persistent_clock</span>
<span style="color: #ffa07a;">set_task_blockstep</span>
<span style="color: #ffa07a;">user_enable_block_step</span>
<span style="color: #ffa07a;">read_hv_clock</span>
<span style="color: #ffa07a;">__acpi_acquire_global_lock</span>
<span style="color: #ffa07a;">__acpi_release_global_lock</span>
<span style="color: #ffa07a;">cpu_hotplug_driver_lock</span>
<span style="color: #ffa07a;">cpu_hotplug_driver_unlock</span>
<span style="color: #ffa07a;">[...]</span>

<span style="color: #ffa07a;">But notice that you also included functions that have "clock" and "block"</span>
<span style="color: #ffa07a;">in their names. To remove them but still keep the "lock" functions, use</span>
<span style="color: #ffa07a;">the '</span>!<span style="color: #ffa07a;">' symbol:</span>


<span style="color: #ffa07a;">&gt;# echo '</span>!*clock*<span style="color: #ffa07a;">' &gt;&gt; set_ftrace_notrace</span>
<span style="color: #ffa07a;">&gt;# echo '</span>!*block*<span style="color: #ffa07a;">' &gt;&gt; set_ftrace_notrace</span>
<span style="color: #ffa07a;">&gt;# cat set_ftrace_notrace</span>
<span style="color: #ffa07a;">__acpi_acquire_global_lock</span>
<span style="color: #ffa07a;">__acpi_release_global_lock</span>
<span style="color: #ffa07a;">cpu_hotplug_driver_lock</span>
<span style="color: #ffa07a;">cpu_hotplug_driver_unlock</span>
<span style="color: #ffa07a;">lock_vector_lock</span>
<span style="color: #ffa07a;">unlock_vector_lock</span>
<span style="color: #ffa07a;">console_lock</span>
<span style="color: #ffa07a;">console_trylock</span>
<span style="color: #ffa07a;">console_unlock</span>
<span style="color: #ffa07a;">is_console_locked</span>
<span style="color: #ffa07a;">kmsg_dump_get_line_nolock</span>
<span style="color: #ffa07a;">[...]</span>

<span style="color: #ffa07a;">But remember to use '</span>&gt;&gt;<span style="color: #ffa07a;">' instead of '</span>&gt;<span style="color: #ffa07a;">', as that will clear out all</span>
<span style="color: #ffa07a;">functions in the file.</span>



<span style="color: #ffa07a;">Latency tracers</span>
<span style="color: #ffa07a;">---------------</span>

<span style="color: #ffa07a;">As stated, the difference between events and tracers, is that events</span>
<span style="color: #ffa07a;">just enable recording some specific information within the kernel.</span>
<span style="color: #ffa07a;">Traces have a bit more impact. Function tracing, in essence, also</span>
<span style="color: #ffa07a;">just records information, but it requires a bit more work than enabling</span>
<span style="color: #ffa07a;">a static tracepoint (event). Also, to limit what function tracing can</span>
<span style="color: #ffa07a;">trace, requires writing into control files for the function tracer.</span>

<span style="color: #ffa07a;">Another type of tracer is the latency tracers. These record a snapshot</span>
<span style="color: #ffa07a;">of the trace when the latency is greater than the previously recorded</span>
<span style="color: #ffa07a;">latency. There are two types of latency tracers, one kind records the</span>
<span style="color: #ffa07a;">length of time when activities within the kernel are disabled, and the</span>
<span style="color: #ffa07a;">other records the time it takes from when a task is woken from sleep</span>
<span style="color: #ffa07a;">to the time it gets scheduled.</span>

<span style="color: #ffa07a;">tracing_max_latency</span>
<span style="color: #ffa07a;">-------------------</span>

<span style="color: #ffa07a;">A latency tracer will just keep track of a snapshot of a trace when a new</span>
<span style="color: #ffa07a;">max latency is hit. To see the current max latency time, cat the contents</span>
<span style="color: #ffa07a;">of the file "tracing_max_latency". This file can also be used to set</span>
<span style="color: #ffa07a;">the max time. Either to reset it back to zero or some lesser number to</span>
<span style="color: #ffa07a;">trigger new snapshots of latencies, or to set it to a greater number to</span>
<span style="color: #ffa07a;">not record anything unless a latency has exceeded some given time.</span>

<span style="color: #ffa07a;">The unit of time that "tracing_max_latency" uses (as well as all other</span>
<span style="color: #ffa07a;">tracing files, unless otherwise specified) is microseconds.</span>


<span style="color: #ffa07a;">irqsoff tracer</span>
<span style="color: #ffa07a;">--------------</span>

<span style="color: #ffa07a;">A common use of the tracing facility is to see how long interrupts have</span>
<span style="color: #ffa07a;">been disabled for. When interrupts are disabled, the system can not</span>
<span style="color: #ffa07a;">respond to external events, which can include a packet coming in on the</span>
<span style="color: #ffa07a;">network card, or perhaps a task on another CPU woke up a task on the current</span>
<span style="color: #ffa07a;">CPU and sent an interprocessor interrupt (IPI) to tell the current CPU</span>
<span style="color: #ffa07a;">to run the new task. With interrupts disabled, the current CPU will</span>
<span style="color: #ffa07a;">ignore all external events, which is a source of latencies. This is why</span>
<span style="color: #ffa07a;">monitorying how long interrupts are disabled can show why the system</span>
<span style="color: #ffa07a;">did not react in a proper time that was expected.</span>

<span style="color: #ffa07a;">The irqsoff tracer traces the time interrupts are disabled to the time</span>
<span style="color: #ffa07a;">they are enabled again. If the time interrupts were disabled is larger</span>
<span style="color: #ffa07a;">than the time specified by "tracing_max_latency" has, then it will</span>
<span style="color: #ffa07a;">save the current trace off to a "snapshot" buffer, reset the current</span>
<span style="color: #ffa07a;">buffer and continue tracing looking for the next time interrupts</span>
<span style="color: #ffa07a;">are off for a long time.</span>

<span style="color: #ffa07a;">Here'</span>s an example of how to use irqsoff tracer:

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 0 &gt; tracing_max_latency</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo irqsoff &gt; current_tracer</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sleep 10</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat trace</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">tracer: irqsoff</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">irqsoff latency trace v1.1.5 on 3.8.13-test-mrg-rt9+</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">--------------------------------------------------------------------</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">latency: 523 us, #1301/1301, CPU#2 | (Mreempt VP:0, KP:0, SP:0 HP:0 #P:8)</span>
<span style="color: #ff7f24;">#    </span><span style="color: #ff7f24;">-----------------</span>
<span style="color: #ff7f24;">#    </span><span style="color: #ff7f24;">| task: swapper/2-0 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span style="color: #ff7f24;">#    </span><span style="color: #ff7f24;">-----------------</span>
<span style="color: #ff7f24;">#  </span><span style="color: #ff7f24;">=&gt; started at: cpu_idle</span>
<span style="color: #ff7f24;">#  </span><span style="color: #ff7f24;">=&gt; ended at:   cpu_idle</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;">#                  </span><span style="color: #ff7f24;">_--------=&gt; CPU#              </span>
<span style="color: #ff7f24;">#                 </span><span style="color: #ff7f24;">/ _-------=&gt; irqs-off          </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">| / _------=&gt; need-resched      </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">|| / _-----=&gt; need-resched_lazy </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">||| / _----=&gt; hardirq/softirq   </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">|||| / _---=&gt; preempt-depth     </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">||||| / _--=&gt; preempt-lazy-depth</span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">|||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">||||||| /     delay             </span>
<span style="color: #ff7f24;">#  </span><span style="color: #ff7f24;">cmd     pid   |||||||| time  |   caller       </span>
<span style="color: #ff7f24;">#     </span><span style="color: #ff7f24;">\   /      ||||||||  \   |   /            </span>
  &lt;idle&gt;-0       2dN..1..    0us : tick_nohz_idle_exit &lt;-cpu_idle
  &lt;idle&gt;-0       2dN..1..    1us : menu_hrtimer_cancel &lt;-tick_nohz_idle_exit
  &lt;idle&gt;-0       2dN..1..    1us : ktime_get &lt;-tick_nohz_idle_exit
  &lt;idle&gt;-0       2dN..1..    1us : tick_do_update_jiffies64 &lt;-tick_nohz_idle_exit
  &lt;idle&gt;-0       2dN..1..    2us : update_cpu_load_nohz &lt;-tick_nohz_idle_exit
  &lt;idle&gt;-0       2dN..1..    2us : _raw_spin_lock &lt;-update_cpu_load_nohz
  &lt;idle&gt;-0       2dN..1..    3us : add_preempt_count &lt;-_raw_spin_lock
  &lt;idle&gt;-0       2dN..2..    3us : __update_cpu_load &lt;-update_cpu_load_nohz
  &lt;idle&gt;-0       2dN..2..    4us : sub_preempt_count &lt;-update_cpu_load_nohz
  &lt;idle&gt;-0       2dN..1..    4us : calc_load_exit_idle &lt;-tick_nohz_idle_exit
  &lt;idle&gt;-0       2dN..1..    5us : touch_softlockup_watchdog &lt;-tick_nohz_idle_exit
  &lt;idle&gt;-0       2dN..1..    5us : hrtimer_cancel &lt;-tick_nohz_idle_exit

[...]

  &lt;idle&gt;-0       2dN..1..  521us : account_idle_time &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       2dN..1..  521us : irqtime_account_process_tick.isra.2 &lt;-account_idle_ticks
  &lt;idle&gt;-0       2dN..1..  521us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       2dN..1..  522us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       2dN..1..  522us : account_idle_time &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       2dN..1..  522us : irqtime_account_process_tick.isra.2 &lt;-account_idle_ticks
  &lt;idle&gt;-0       2dN..1..  522us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       2dN..1..  523us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       2dN..1..  523us : account_idle_time &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       2dN..1..  523us : tick_nohz_idle_exit &lt;-cpu_idle
  &lt;idle&gt;-0       2dN..1..  524us+: trace_hardirqs_on &lt;-cpu_idle
  &lt;idle&gt;-0       2dN..1..  537us : &lt;stack trace&gt;
 =&gt; tick_nohz_idle_exit
 =&gt; cpu_idle
 =&gt; start_secondary


By default, the irqsoff tracer enables <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">tracing</span> to show what functions
are being called while interrupts were disabled. But as you can see, it
can produce a lot of output (the total line count of the above trace
was 1,327 lines. Most of that was cut to not waste space<span style="color: #00ffff;"> in</span> this document).
The problem with the <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">tracer</span> is that it incurs a substantial overhead
and exagerates the actual latency.

The reported latency above is 523 microseconds. The trace ends at 537
microseconds, but that<span style="color: #ffa07a;">'s because it took 14 microseconds to produce the</span>
<span style="color: #ffa07a;">stack trace.</span>

<span style="color: #ffa07a;">The end of the trace does a stack dump to show where the latency occurred.</span>
<span style="color: #ffa07a;">The above happened in tick_nohz_idle_exit(), and even though we can blame</span>
<span style="color: #ffa07a;">the function tracer for exagerating the latency, this trace shows</span>
<span style="color: #ffa07a;">that using NO HZ idle can have issues with a real time system. When a</span>
<span style="color: #ffa07a;">system with NO HZ set is idle, the timer tick is stopped. When the system</span>
<span style="color: #ffa07a;">resumes from idle, the timer must catch up to the current time and executes</span>
<span style="color: #ffa07a;">all the ticks it missed in the loop. This is done with interrupts disabled.</span>

<span style="color: #ffa07a;">Looking at the latency field "2dN..1.." you can see that this loop</span>
<span style="color: #ffa07a;">ran on CPU 2, had interrupts disabled "d". The scheduler needed to run</span>
<span style="color: #ffa07a;">"N" (for NEED_RESCHED). Preemption was disabled, as the preempt_count</span>
<span style="color: #ffa07a;">counter was set to "1".</span>

<span style="color: #ffa07a;">Ideally, when coming out of NO HZ, the accounting could be done in a single</span>
<span style="color: #ffa07a;">step, but as that is tricky to get right, the current method is to just</span>
<span style="color: #ffa07a;">run the current code in a loop as if the timer went off each time.</span>


<span style="color: #ffa07a;">No function tracing</span>
<span style="color: #ffa07a;">-------------------</span>

<span style="color: #ffa07a;">As function tracing can exaggerate the latency, you can either</span>
<span style="color: #ffa07a;">limit what functions are traced via the "set_ftrace_filter" and</span>
<span style="color: #ffa07a;">"set_ftrace_notrace" files as described above in the function tracing</span>
<span style="color: #ffa07a;">section. But you can also disable tracing totally via the</span>
<span style="color: #ffa07a;">sysctl file "kernel/ftrace_enabled".</span>

<span style="color: #ffa07a;">&gt;# echo 0 &gt; /proc/sys/kernel/ftrace_enabled</span>

<span style="color: #ffa07a;">  or</span>

<span style="color: #ffa07a;">&gt;# sysctl kernel.ftrace_enabled=0</span>

<span style="color: #ffa07a;">This disables function tracing by all the ftrace tracers. Including</span>
<span style="color: #ffa07a;">the function tracer, which would make it rather pointless because</span>
<span style="color: #ffa07a;">the function tracer would act just like the "nop" tracer.</span>

<span style="color: #ffa07a;">&gt;# echo 0 &gt; /proc/sys/kernel/ftrace_enabled</span>
<span style="color: #ffa07a;">&gt;# echo 0 &gt; tracing_max_latency</span>
<span style="color: #ffa07a;">&gt;# echo irqsoff &gt; current_tracer</span>
<span style="color: #ffa07a;">&gt;# sleep 10</span>
<span style="color: #ffa07a;">&gt;# cat trace</span>
<span style="color: #ffa07a;"># tracer: irqsoff</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;"># irqsoff latency trace v1.1.5 on 3.8.13-test-mrg-rt9+</span>
<span style="color: #ffa07a;"># --------------------------------------------------------------------</span>
<span style="color: #ffa07a;"># latency: 80 us, #4/4, CPU#6 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:8)</span>
<span style="color: #ffa07a;">#    -----------------</span>
<span style="color: #ffa07a;">#    | task: swapper/6-0 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span style="color: #ffa07a;">#    -----------------</span>
<span style="color: #ffa07a;">#  =&gt; started at: cpu_idle</span>
<span style="color: #ffa07a;">#  =&gt; ended at:   cpu_idle</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;">#                  _--------=&gt; CPU#              </span>
<span style="color: #ffa07a;">#                 / _-------=&gt; irqs-off          </span>
<span style="color: #ffa07a;">#                | / _------=&gt; need-resched      </span>
<span style="color: #ffa07a;">#                || / _-----=&gt; need-resched_lazy </span>
<span style="color: #ffa07a;">#                ||| / _----=&gt; hardirq/softirq   </span>
<span style="color: #ffa07a;">#                |||| / _---=&gt; preempt-depth     </span>
<span style="color: #ffa07a;">#                ||||| / _--=&gt; preempt-lazy-depth</span>
<span style="color: #ffa07a;">#                |||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ffa07a;">#                ||||||| /     delay             </span>
<span style="color: #ffa07a;">#  cmd     pid   |||||||| time  |   caller       </span>
<span style="color: #ffa07a;">#     \   /      ||||||||  \   |   /            </span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       6dN..1..    0us+: tick_nohz_idle_exit &lt;-cpu_idle</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       6dN..1..   81us : tick_nohz_idle_exit &lt;-cpu_idle</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       6dN..1..   81us+: trace_hardirqs_on &lt;-cpu_idle</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       6dN..1..   87us : &lt;stack trace&gt;</span>
<span style="color: #ffa07a;"> =&gt; tick_nohz_idle_exit</span>
<span style="color: #ffa07a;"> =&gt; cpu_idle</span>
<span style="color: #ffa07a;"> =&gt; start_secondary</span>


<span style="color: #ffa07a;">This time the latency is much more compact and accurate (80 microseconds</span>
<span style="color: #ffa07a;">is still a lot, but much lower than 523). Here the backtrace is much more</span>
<span style="color: #ffa07a;">important as its now the only real information to know where the latency</span>
<span style="color: #ffa07a;">occurred.</span>


<span style="color: #ffa07a;">preemptoff tracer</span>
<span style="color: #ffa07a;">-----------------</span>

<span style="color: #ffa07a;">There are points in the kernel that disables preemption but not interrupts.</span>
<span style="color: #ffa07a;">That is, an interrupt can still interrupt the current process but that</span>
<span style="color: #ffa07a;">process can not be scheduled out for a higher priority process.</span>

<span style="color: #ffa07a;">This tracer records the time that preemption is disabed via the</span>
<span style="color: #ffa07a;">kernel internal "preempt_disable()" function.</span>

<span style="color: #ffa07a;">&gt;# echo 0 &gt; /proc/sys/kernel/ftrace_enabled</span>
<span style="color: #ffa07a;">&gt;# echo 0 &gt; tracing_max_latency</span>
<span style="color: #ffa07a;">&gt;# echo preemptoff &gt; current_tracer</span>
<span style="color: #ffa07a;">&gt;# sleep 10</span>
<span style="color: #ffa07a;">&gt;# cat trace</span>
<span style="color: #ffa07a;"># tracer: preemptoff</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;"># preemptoff latency trace v1.1.5 on 3.8.13-test-mrg-rt9+</span>
<span style="color: #ffa07a;"># --------------------------------------------------------------------</span>
<span style="color: #ffa07a;"># latency: 65 us, #4/4, CPU#6 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:8)</span>
<span style="color: #ffa07a;">#    -----------------</span>
<span style="color: #ffa07a;">#    | task: swapper/6-0 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span style="color: #ffa07a;">#    -----------------</span>
<span style="color: #ffa07a;">#  =&gt; started at: cpuidle_enter</span>
<span style="color: #ffa07a;">#  =&gt; ended at:   start_secondary</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;">#                   _--------=&gt; CPU#              </span>
<span style="color: #ffa07a;">#                  / _-------=&gt; irqs-off          </span>
<span style="color: #ffa07a;">#                 | / _------=&gt; need-resched      </span>
<span style="color: #ffa07a;">#                 || / _-----=&gt; need-resched_lazy </span>
<span style="color: #ffa07a;">#                 ||| / _----=&gt; hardirq/softirq   </span>
<span style="color: #ffa07a;">#                 |||| / _---=&gt; preempt-depth     </span>
<span style="color: #ffa07a;">#                 ||||| / _--=&gt; preempt-lazy-depth</span>
<span style="color: #ffa07a;">#                 |||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ffa07a;">#                 ||||||| /     delay             </span>
<span style="color: #ffa07a;">#  cmd     pid    |||||||| time  |   caller       </span>
<span style="color: #ffa07a;">#     \   /      ||||||||  \   |   /            </span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       6d...1..    1us+: intel_idle &lt;-cpuidle_enter</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       6.N..1..   65us : cpu_idle &lt;-start_secondary</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       6.N..1..   66us+: trace_preempt_on &lt;-start_secondary</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       6.N..1..   71us : &lt;stack trace&gt;</span>
<span style="color: #ffa07a;"> =&gt; sub_preempt_count</span>
<span style="color: #ffa07a;"> =&gt; cpu_idle</span>
<span style="color: #ffa07a;"> =&gt; start_secondary</span>


<span style="color: #ffa07a;">There'</span>s not much interesting<span style="color: #00ffff;"> in</span> this trace except that preemption was
disabled for 65 microseconds.


preemptirqsoff tracer
---------------------

Knowing when interrupts are disabled or how long preemption is disabled
via the preempt_disable() kernel interface is not as interesting as
knowing how long true preemption is disabled. That is, if we have the
following scenario:

A) preempt_disable()

[...]

B) irqs_disable()

[...]

C) preempt_enable();

[...]

D) irqs_enable();


<span style="color: #ffa07a;">"irqsoff"</span> tracer will give you the time from B to D
<span style="color: #ffa07a;">"preemptoff"</span> tracer will give you the time from A to C.

But the current task can not be preempted from A to D which is what we
really care about. When a task can not be preempted, a new task can
no execute when it is woken up if it is to run on the same CPU as the
task that has true preemption disabled (either interrupts disabled or
preemption disabled). The <span style="color: #ffa07a;">"preemptirqsoff"</span> tracer will handle this.

<span style="color: #ffa07a;">"preemptirqsoff"</span> tracer will give you the time from A to D


&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 1 &gt; /proc/sys/kernel/ftrace_enabled</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 0 &gt; tracing_max_latency</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo preemptirqsoff &gt; current_tracer</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sleep 10</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat trace</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">tracer: preemptirqsoff</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">preemptirqsoff latency trace v1.1.5 on 3.8.13-test-mrg-rt9+</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">--------------------------------------------------------------------</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">latency: 377 us, #1289/1289, CPU#1 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:8)</span>
<span style="color: #ff7f24;">#    </span><span style="color: #ff7f24;">-----------------</span>
<span style="color: #ff7f24;">#    </span><span style="color: #ff7f24;">| task: swapper/1-0 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span style="color: #ff7f24;">#    </span><span style="color: #ff7f24;">-----------------</span>
<span style="color: #ff7f24;">#  </span><span style="color: #ff7f24;">=&gt; started at: cpuidle_enter</span>
<span style="color: #ff7f24;">#  </span><span style="color: #ff7f24;">=&gt; ended at:   start_secondary</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;">#                  </span><span style="color: #ff7f24;">_--------=&gt; CPU#              </span>
<span style="color: #ff7f24;">#                 </span><span style="color: #ff7f24;">/ _-------=&gt; irqs-off          </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">| / _------=&gt; need-resched      </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">|| / _-----=&gt; need-resched_lazy </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">||| / _----=&gt; hardirq/softirq   </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">|||| / _---=&gt; preempt-depth     </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">||||| / _--=&gt; preempt-lazy-depth</span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">|||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ff7f24;">#                </span><span style="color: #ff7f24;">||||||| /     delay             </span>
<span style="color: #ff7f24;">#  </span><span style="color: #ff7f24;">cmd     pid   |||||||| time  |   caller       </span>
<span style="color: #ff7f24;">#     </span><span style="color: #ff7f24;">\   /      ||||||||  \   |   /            </span>
  &lt;idle&gt;-0       1d...1..    0us : intel_idle &lt;-cpuidle_enter
  &lt;idle&gt;-0       1d...1..    1us : ktime_get &lt;-cpuidle_wrap_enter
  &lt;idle&gt;-0       1d...1..    2us : smp_reschedule_interrupt &lt;-reschedule_interrupt
  &lt;idle&gt;-0       1d...1..    3us : scheduler_ipi &lt;-smp_reschedule_interrupt
  &lt;idle&gt;-0       1d...1..    3us : irq_enter &lt;-scheduler_ipi
  &lt;idle&gt;-0       1d...1..    4us : rcu_irq_enter &lt;-irq_enter
  &lt;idle&gt;-0       1d...1..    4us : rcu_eqs_exit_common.isra.45 &lt;-rcu_irq_enter
  &lt;idle&gt;-0       1d...1..    5us : tick_check_idle &lt;-irq_enter
  &lt;idle&gt;-0       1d...1..    5us : tick_check_oneshot_broadcast &lt;-tick_check_idle
  &lt;idle&gt;-0       1d...1..    5us : ktime_get &lt;-tick_check_idle
  &lt;idle&gt;-0       1d...1..    6us : tick_nohz_stop_idle &lt;-tick_check_idle
  &lt;idle&gt;-0       1d...1..    6us : update_ts_time_stats &lt;-tick_nohz_stop_idle
  &lt;idle&gt;-0       1d...1..    7us : nr_iowait_cpu &lt;-update_ts_time_stats
  &lt;idle&gt;-0       1d...1..    7us : touch_softlockup_watchdog &lt;-sched_clock_idle_wakeup_event
  &lt;idle&gt;-0       1d...1..    7us : tick_do_update_jiffies64 &lt;-tick_check_idle
  &lt;idle&gt;-0       1d...1..    8us : touch_softlockup_watchdog &lt;-tick_check_idle
  &lt;idle&gt;-0       1d...1..    8us : irqtime_account_irq &lt;-irq_enter
  &lt;idle&gt;-0       1d...1..    9us : in_serving_softirq &lt;-irqtime_account_irq
  &lt;idle&gt;-0       1d...1..    9us : add_preempt_count &lt;-irq_enter
  &lt;idle&gt;-0       1d..h1..    9us : sched_ttwu_pending &lt;-scheduler_ipi
  &lt;idle&gt;-0       1d..h1..   10us : _raw_spin_lock &lt;-sched_ttwu_pending
  &lt;idle&gt;-0       1d..h1..   10us : add_preempt_count &lt;-_raw_spin_lock
  &lt;idle&gt;-0       1d..h2..   11us : sub_preempt_count &lt;-sched_ttwu_pending
  &lt;idle&gt;-0       1d..h1..   11us : raise_softirq_irqoff &lt;-scheduler_ipi
  &lt;idle&gt;-0       1d..h1..   12us : do_raise_softirq_irqoff &lt;-raise_softirq_irqoff
  &lt;idle&gt;-0       1d..h1..   12us : irq_exit &lt;-scheduler_ipi
  &lt;idle&gt;-0       1d..h1..   12us : irqtime_account_irq &lt;-irq_exit
  &lt;idle&gt;-0       1d..h1..   13us : sub_preempt_count &lt;-irq_exit
  &lt;idle&gt;-0       1d...2..   13us : wakeup_softirqd &lt;-irq_exit
  &lt;idle&gt;-0       1d...2..   14us : wake_up_process &lt;-wakeup_softirqd
  &lt;idle&gt;-0       1d...2..   14us : try_to_wake_up &lt;-wake_up_process

[...]

  &lt;idle&gt;-0       1d...4..   18us : dequeue_rt_stack &lt;-enqueue_task_rt
  &lt;idle&gt;-0       1d...4..   19us : cpupri_set &lt;-enqueue_task_rt
  &lt;idle&gt;-0       1d...4..   20us : update_rt_migration &lt;-enqueue_task_rt
  &lt;idle&gt;-0       1d...4..   20us : ttwu_do_wakeup &lt;-ttwu_do_activate.constprop.90
  &lt;idle&gt;-0       1d...4..   20us : check_preempt_curr &lt;-ttwu_do_wakeup
  &lt;idle&gt;-0       1d...4..   21us : resched_task &lt;-check_preempt_curr
  &lt;idle&gt;-0       1dN..4..   21us : task_woken_rt &lt;-ttwu_do_wakeup
  &lt;idle&gt;-0       1dN..4..   22us : sub_preempt_count &lt;-try_to_wake_up
  &lt;idle&gt;-0       1dN..3..   22us : ttwu_stat &lt;-try_to_wake_up
  &lt;idle&gt;-0       1dN..3..   23us : _raw_spin_unlock_irqrestore &lt;-try_to_wake_up
  &lt;idle&gt;-0       1dN..3..   23us : sub_preempt_count &lt;-_raw_spin_unlock_irqrestore

[...]

  &lt;idle&gt;-0       1dN..1..  376us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       1dN..1..  376us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       1dN..1..  376us : account_idle_time &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       1dN..1..  377us : irqtime_account_process_tick.isra.2 &lt;-account_idle_ticks
  &lt;idle&gt;-0       1dN..1..  377us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       1dN..1..  377us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       1dN..1..  377us : account_idle_time &lt;-irqtime_account_process_tick.isra.2
  &lt;idle&gt;-0       1.N..1..  378us : cpu_idle &lt;-start_secondary
  &lt;idle&gt;-0       1.N..1..  378us+: trace_preempt_on &lt;-start_secondary
  &lt;idle&gt;-0       1.N..1..  391us : &lt;stack trace&gt;
 =&gt; sub_preempt_count
 =&gt; cpu_idle
 =&gt; start_secondary

The above is a much more interesting trace. Although we enabled <span style="color: #00ffff;">function</span>
tracing again, it allows us to see more of what is happening during
the trace.

The trace starts out at intel_idle() <span style="color: #b0c4de;">which</span> on the box the trace was run on
is the idle function. Idle <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">usually</span> disable preemption and
sometimes interrupts when the system is put to sleep, although an
interrupt will wake up the processor, the interrupt will not be serviced
<span style="color: #00ffff;">until</span> the processor re-enables interrupts again.

As interrupts and preemption is disabled across a full idle, the tracer
must account for this, as it is pretty useless to trace how long the
CPU has been idle. Thus, immediately exiting the idle state, the
latency tracers are re-enabled. This is where the start of the trace
occurred.

Then we can see that an interrupt is triggered after interrupts were
<span style="color: #87cefa;">enabled</span> (schedule_ipi). An interprocessor interrupt happened to wake up
a process that is on the current CPU.

Next the irq_enter() is called. This tells the system (including the
tracing system) that the kernel is now int interrupt mode. Notice that
<span style="color: #ffa07a;">'h'</span> is not set until after <span style="color: #ffa07a;">"add_preempt_count"</span> is called. That<span style="color: #ffa07a;">'s because</span>
<span style="color: #ffa07a;">the irq accounting is shared with the preempt_count code. A lot has happened</span>
<span style="color: #ffa07a;">before that got set, as NO HZ and RCU must perform activities immediately</span>
<span style="color: #ffa07a;">when coming out of idle via an interrupt.</span>

<span style="color: #ffa07a;">A softirq was raised while in the interrupt and as the MRG kernel runs</span>
<span style="color: #ffa07a;">soft interrupts as threads, the corresponding softirq was woken up</span>
<span style="color: #ffa07a;">on exiting the interrupt (irq_exit).</span>

<span style="color: #ffa07a;">This wakeup also triggered the NEED_RESCHED flag "N" to be set, to let</span>
<span style="color: #ffa07a;">the system know that the kernel needs to call schedule as soon as</span>
<span style="color: #ffa07a;">preemption is re-enabled.</span>

<span style="color: #ffa07a;">Finally the NO HZ accounting ran again with interrupts and preemption</span>
<span style="color: #ffa07a;">disabled. Finally, interrupts were enabled and so was the preemption.</span>



<span style="color: #ffa07a;">wakeup tracer</span>
<span style="color: #ffa07a;">-------------</span>

<span style="color: #ffa07a;">The previous tracers ("irqsoff", "preemptoff", and "preemptirqsoff")</span>
<span style="color: #ffa07a;">were single CPU tracers. That is, they only reported the activities</span>
<span style="color: #ffa07a;">on a single CPU, as interrupts only occurred there.</span>

<span style="color: #ffa07a;">Both "wakeup" and "wakeup_rt" tracers are full CPU tracers. That is,</span>
<span style="color: #ffa07a;">they report the activities of what happens across all CPUs. This is</span>
<span style="color: #ffa07a;">because a task may be woken from one CPU but get scheduled on another</span>
<span style="color: #ffa07a;">CPU.</span>

<span style="color: #ffa07a;">The "wakeup" tracer is not that interresting from a real-time perspective,</span>
<span style="color: #ffa07a;">as it records the time it takes to wake up the highest priority task</span>
<span style="color: #ffa07a;">in the system even if that task does not happen to be a real time task.</span>
<span style="color: #ffa07a;">Non real-time tasks may be delayed due scheduling balacing, and not</span>
<span style="color: #ffa07a;">immediately scheduled for throughput reasons. Real-time tasks are scheduled</span>
<span style="color: #ffa07a;">immediately after they are woken. Recording the max time it takes to</span>
<span style="color: #ffa07a;">wake up a non real-time task will hide the times it takes to wake up</span>
<span style="color: #ffa07a;">a real-time task. Because of this, we will focus on the "wakeup_rt" tracer</span>
<span style="color: #ffa07a;">instead.</span>


<span style="color: #ffa07a;">wakeup_rt tracer</span>
<span style="color: #ffa07a;">----------------</span>

<span style="color: #ffa07a;">The "wakeup" tracer records the time it takes from the current highest</span>
<span style="color: #ffa07a;">priority task to wake up to the time it is scheduled. Because non real-time</span>
<span style="color: #ffa07a;">tasks may take much longer to wake up than a real-time task, and that</span>
<span style="color: #ffa07a;">the latency tracers only record the longest time, "wakeup" tracer is not</span>
<span style="color: #ffa07a;">that suitable for seeing how long a real-time task takes to be scheduled</span>
<span style="color: #ffa07a;">from the time it is woken. For that, we use the "wakeup_rt" tracer.</span>

<span style="color: #ffa07a;">The "wakeup_rt" tracer only records the time for real-time tasks and</span>
<span style="color: #ffa07a;">ignores the time for non real-time tasks.</span>

<span style="color: #ffa07a;">&gt;# echo 0 &gt; tracing_max_latency</span>
<span style="color: #ffa07a;">&gt;# echo preemptirqsoff &gt; current_tracer</span>
<span style="color: #ffa07a;">&gt;# sleep 10</span>
<span style="color: #ffa07a;">&gt;# cat trace</span>
<span style="color: #ffa07a;"># tracer: wakeup_rt</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;"># wakeup_rt latency trace v1.1.5 on 3.8.13-test-mrg-rt9+</span>
<span style="color: #ffa07a;"># --------------------------------------------------------------------</span>
<span style="color: #ffa07a;"># latency: 385 us, #1339/1339, CPU#7 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:8)</span>
<span style="color: #ffa07a;">#    -----------------</span>
<span style="color: #ffa07a;">#    | task: ksoftirqd/7-51 (uid:0 nice:0 policy:1 rt_prio:1)</span>
<span style="color: #ffa07a;">#    -----------------</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;">#                  _--------=&gt; CPU#              </span>
<span style="color: #ffa07a;">#                 / _-------=&gt; irqs-off          </span>
<span style="color: #ffa07a;">#                | / _------=&gt; need-resched      </span>
<span style="color: #ffa07a;">#                || / _-----=&gt; need-resched_lazy </span>
<span style="color: #ffa07a;">#                ||| / _----=&gt; hardirq/softirq   </span>
<span style="color: #ffa07a;">#                |||| / _---=&gt; preempt-depth     </span>
<span style="color: #ffa07a;">#                ||||| / _--=&gt; preempt-lazy-depth</span>
<span style="color: #ffa07a;">#                |||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ffa07a;">#                ||||||| /     delay             </span>
<span style="color: #ffa07a;">#  cmd     pid   |||||||| time  |   caller       </span>
<span style="color: #ffa07a;">#     \   /      ||||||||  \   |   /            </span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7d...5..    0us :      0:120:R   + [007]    51: 98:R ksoftirqd/7</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7d...5..    2us : ttwu_do_activate.constprop.90 &lt;-try_to_wake_up</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7d...4..    2us : check_preempt_curr &lt;-ttwu_do_wakeup</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7d...4..    3us : resched_task &lt;-check_preempt_curr</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..4..    3us : task_woken_rt &lt;-ttwu_do_wakeup</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..4..    4us : sub_preempt_count &lt;-try_to_wake_up</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..3..    4us : ttwu_stat &lt;-try_to_wake_up</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..3..    4us : _raw_spin_unlock_irqrestore &lt;-try_to_wake_up</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..3..    5us : sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..    5us : idle_cpu &lt;-irq_exit</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..    5us : rcu_irq_exit &lt;-irq_exit</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..    6us : rcu_eqs_enter_common.isra.47 &lt;-rcu_irq_exit</span>

<span style="color: #ffa07a;">[...]</span>

<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   53us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   53us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   54us : account_idle_time &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   54us : irqtime_account_process_tick.isra.2 &lt;-account_idle_ticks</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   54us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   54us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   55us : account_idle_time &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   55us : irqtime_account_process_tick.isra.2 &lt;-account_idle_ticks</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   55us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   55us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   56us : account_idle_time &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   56us : irqtime_account_process_tick.isra.2 &lt;-account_idle_ticks</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   56us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   56us : nsecs_to_jiffies64 &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   57us : account_idle_time &lt;-irqtime_account_process_tick.isra.2</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..   57us : irqtime_account_process_tick.isra.2 &lt;-account_idle_ticks</span>

<span style="color: #ffa07a;">[...]</span>

<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN.h1..  377us : tick_program_event &lt;-hrtimer_interrupt</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN.h1..  378us : clockevents_program_event &lt;-tick_program_event</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN.h1..  378us : ktime_get &lt;-clockevents_program_event</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN.h1..  378us : lapic_next_deadline &lt;-clockevents_program_event</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN.h1..  379us : irq_exit &lt;-smp_apic_timer_interrupt</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN.h1..  379us : irqtime_account_irq &lt;-irq_exit</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN.h1..  379us : sub_preempt_count &lt;-irq_exit</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..  379us : wakeup_softirqd &lt;-irq_exit</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..  380us : idle_cpu &lt;-irq_exit</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..  380us : rcu_irq_exit &lt;-irq_exit</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..  380us : sub_preempt_count &lt;-irq_exit</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7.N..1..  381us : sub_preempt_count &lt;-cpu_idle</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7.N.....  381us : __schedule &lt;-preempt_schedule</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7.N.....  382us : add_preempt_count &lt;-__schedule</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7.N..1..  382us : rcu_note_context_switch &lt;-__schedule</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7.N..1..  382us : _raw_spin_lock_irq &lt;-__schedule</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..1..  382us : add_preempt_count &lt;-_raw_spin_lock_irq</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..  383us : update_rq_clock &lt;-__schedule</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..  383us : put_prev_task_idle &lt;-__schedule</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..  383us : pick_next_task_stop &lt;-__schedule</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..  384us : pick_next_task_rt &lt;-__schedule</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7dN..2..  384us : dequeue_pushable_task &lt;-pick_next_task_rt</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7d...3..  385us : __schedule &lt;-preempt_schedule</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       7d...3..  385us :      0:120:R ==&gt; [007]    51: 98:R ksoftirqd/7</span>


<span style="color: #ffa07a;">And once again we can see that NO HZ affects the wake up time of a</span>
<span style="color: #ffa07a;">real time task (this case it was ksoftirqd).</span>

<span style="color: #ffa07a;">Notice the first traced item:</span>

<span style="color: #ffa07a;">       0:120:R   + [007]    51: 98:R ksoftirqd/7</span>

<span style="color: #ffa07a;">This is in the format of:</span>

<span style="color: #ffa07a;">  &lt;pid&gt;:&lt;prio&gt;:&lt;process-state&gt;    + [&lt;CPU#&gt;]   &lt;pid&gt;:&lt;prio&gt;:&lt;process-state&gt;</span>

<span style="color: #ffa07a;">The first pid, prio and process-state is for the task performing the</span>
<span style="color: #ffa07a;">wake up. Again, the prio is the internal kernel prio, where 120 is for</span>
<span style="color: #ffa07a;">SCHED_OTHER. The "+" represents a wake up is happening. The CPU# the</span>
<span style="color: #ffa07a;">CPU waking task in currently assigned to (and being woken up on).</span>
<span style="color: #ffa07a;">The second set of pid, prio and process-state is for the task being</span>
<span style="color: #ffa07a;">woken up. The prio of 98 is internal to the kernel, and to get the real</span>
<span style="color: #ffa07a;">real-time priority for the task you must subtract it from 99.</span>
<span style="color: #ffa07a;">(99 - 98 = real-time priority of 1 - low priority)</span>

<span style="color: #ffa07a;">The process-state should be always in the "R" (running) state, and</span>
<span style="color: #ffa07a;">can be ignored. The original location to record the trace when waking</span>
<span style="color: #ffa07a;">up was before the task was actually woken. Due to changes in the wake</span>
<span style="color: #ffa07a;">up code, the trace hook had to be moved to after the wake up, which</span>
<span style="color: #ffa07a;">means the task being woken up will have already been set to running</span>
<span style="color: #ffa07a;">and the trace will reflect that.</span>

<span style="color: #ffa07a;">The last line of the trace:</span>

<span style="color: #ffa07a;">      0:120:R ==&gt; [007]    51: 98:R ksoftirqd/7</span>

<span style="color: #ffa07a;">Represents the scheduling of a task.</span>

<span style="color: #ffa07a;">  &lt;pid&gt;:&lt;prio&gt;:&lt;process-state&gt; ==&gt; [CPU#] &lt;pid&gt;:&lt;prio&gt;&lt;process-state&gt;</span>

<span style="color: #ffa07a;">The first set of pid, prio and process-state belongs to the task that</span>
<span style="color: #ffa07a;">is being scheduled out. The second set is for the task that is being</span>
<span style="color: #ffa07a;">scheduled in. The "==&gt;" represents a task scheduling switch, and the</span>
<span style="color: #ffa07a;">CPU# should always match the current CPU that is on (7 in this case).</span>

<span style="color: #ffa07a;">The first process-state here is of more importance than that of the</span>
<span style="color: #ffa07a;">wake up trace. If the previous task is in the running state (as it is</span>
<span style="color: #ffa07a;">in this case), that means it has been preempted (still wants to run</span>
<span style="color: #ffa07a;">but must yield for the new task).</span>



<span style="color: #ffa07a;">Using events in tracers</span>
<span style="color: #ffa07a;">-----------------------</span>

<span style="color: #ffa07a;">With the "wakeup_rt" tracer, as with all tracers, function tracing can</span>
<span style="color: #ffa07a;">exaggerate the latency times. But disabling the function tracing for</span>
<span style="color: #ffa07a;">"wakeup_rt" is not very useful.</span>

<span style="color: #ffa07a;">&gt;# echo 0 &gt; /proc/sys/kernel/ftrace_enabled</span>
<span style="color: #ffa07a;">&gt;# echo 0 &gt; tracing_max_latency</span>
<span style="color: #ffa07a;">&gt;# echo wakeup_rt &gt; current_tracer</span>
<span style="color: #ffa07a;">&gt;# sleep 10</span>
<span style="color: #ffa07a;">&gt;# cat trace</span>
<span style="color: #ffa07a;"># tracer: wakeup_rt</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;"># wakeup_rt latency trace v1.1.5 on 3.8.13-test-mrg-rt9+</span>
<span style="color: #ffa07a;"># --------------------------------------------------------------------</span>
<span style="color: #ffa07a;"># latency: 64 us, #18446744073709512109/18446744073709512109, CPU#5 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:8)</span>
<span style="color: #ffa07a;">#    -----------------</span>
<span style="color: #ffa07a;">#    | task: irq/43-em1-878 (uid:0 nice:0 policy:1 rt_prio:50)</span>
<span style="color: #ffa07a;">#    -----------------</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;">#                  _--------=&gt; CPU#              </span>
<span style="color: #ffa07a;">#                 / _-------=&gt; irqs-off          </span>
<span style="color: #ffa07a;">#                | / _------=&gt; need-resched      </span>
<span style="color: #ffa07a;">#                || / _-----=&gt; need-resched_lazy </span>
<span style="color: #ffa07a;">#                ||| / _----=&gt; hardirq/softirq   </span>
<span style="color: #ffa07a;">#                |||| / _---=&gt; preempt-depth     </span>
<span style="color: #ffa07a;">#                ||||| / _--=&gt; preempt-lazy-depth</span>
<span style="color: #ffa07a;">#                |||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ffa07a;">#                ||||||| /     delay             </span>
<span style="color: #ffa07a;">#  cmd     pid   |||||||| time  |   caller       </span>
<span style="color: #ffa07a;">#     \   /      ||||||||  \   |   /            </span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       0d..h4..    0us :      0:120:R   + [005]   878: 49:R irq/43-em1</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       0d..h4..    2us+: ttwu_do_activate.constprop.90 &lt;-try_to_wake_up</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       5d...3..   63us : __schedule &lt;-preempt_schedule</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       5d...3..   64us :      0:120:R ==&gt; [005]   878: 49:R irq/43-em1</span>

<span style="color: #ffa07a;">The irq thread was woken up by a task on CPU 0, and it scheduled on</span>
<span style="color: #ffa07a;">CPU 5.</span>


<span style="color: #ffa07a;">As function tracing causes a large overhead, with the wakeup tracers, you</span>
<span style="color: #ffa07a;">can still get information by using events, and events are sparse enough</span>
<span style="color: #ffa07a;">to not cause much overhead even when enabled.</span>

<span style="color: #ffa07a;">&gt;# echo 0 &gt; /proc/sys/kernel/ftrace_enabled</span>
<span style="color: #ffa07a;">&gt;# echo 1 &gt; events/enable</span>
<span style="color: #ffa07a;">&gt;# echo 0 &gt; tracing_max_latency</span>
<span style="color: #ffa07a;">&gt;# echo wakeup_rt &gt; current_tracer</span>
<span style="color: #ffa07a;">&gt;# sleep 10</span>
<span style="color: #ffa07a;">&gt;# cat trace</span>
<span style="color: #ffa07a;"># tracer: wakeup_rt</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;"># wakeup_rt latency trace v1.1.5 on 3.8.13-test-mrg-rt9+</span>
<span style="color: #ffa07a;"># --------------------------------------------------------------------</span>
<span style="color: #ffa07a;"># latency: 67 us, #15/15, CPU#1 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:8)</span>
<span style="color: #ffa07a;">#    -----------------</span>
<span style="color: #ffa07a;">#    | task: irq/43-em1-878 (uid:0 nice:0 policy:1 rt_prio:50)</span>
<span style="color: #ffa07a;">#    -----------------</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;">#                   _--------=&gt; CPU#              </span>
<span style="color: #ffa07a;">#                  / _-------=&gt; irqs-off          </span>
<span style="color: #ffa07a;">#                 | / _------=&gt; need-resched      </span>
<span style="color: #ffa07a;">#                 || / _-----=&gt; need-resched_lazy </span>
<span style="color: #ffa07a;">#                 ||| / _----=&gt; hardirq/softirq   </span>
<span style="color: #ffa07a;">#                 |||| / _---=&gt; preempt-depth     </span>
<span style="color: #ffa07a;">#                 ||||| / _--=&gt; preempt-lazy-depth</span>
<span style="color: #ffa07a;">#                 |||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ffa07a;">#                 ||||||| /     delay             </span>
<span style="color: #ffa07a;">#  cmd     pid    |||||||| time  |   caller       </span>
<span style="color: #ffa07a;">#     \   /      ||||||||  \   |   /            </span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       0d..h4..    0us :      0:120:R   + [001]   878: 49:R irq/43-em1</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       0d..h4..    1us : ttwu_do_activate.constprop.90 &lt;-try_to_wake_up</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       0d..h4..    1us+: sched_wakeup: comm=irq/43-em1 pid=878 prio=49 success=1 target_cpu=001</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       0....2..    5us : power_end: cpu_id=0</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       0....2..    6us+: cpu_idle: state=4294967295 cpu_id=0</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       0d...2..    9us : power_start: type=1 state=3 cpu_id=0</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       0d...2..   10us+: cpu_idle: state=3 cpu_id=0</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       1.N..2..   25us+: power_end: cpu_id=1</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       1.N..2..   27us+: cpu_idle: state=4294967295 cpu_id=1</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       1dN..3..   30us : hrtimer_cancel: hrtimer=ffff88011ea4cf40</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       1dN..3..   31us+: hrtimer_start: hrtimer=ffff88011ea4cf40 function=tick_sched_timer expires=9670689000000 softexpires=9670689000000</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       1.N..2..   64us : rcu_utilization: Start context switch</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       1.N..2..   65us+: rcu_utilization: End context switch</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       1d...3..   66us : __schedule &lt;-preempt_schedule</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       1d...3..   67us :      0:120:R ==&gt; [001]   878: 49:R irq/43-em1</span>


<span style="color: #ffa07a;">The above trace is much more accurate to a real latency, but this time</span>
<span style="color: #ffa07a;">we get a lot more information. The task being woken up in on CPU 1, and</span>
<span style="color: #ffa07a;">the first time we see CPU 1 is at the 25 microsecond time. The "power_end"</span>
<span style="color: #ffa07a;">trace point shows that the CPU is coming out of a deep power state, which</span>
<span style="color: #ffa07a;">explains why the time took so long. The high resolution timer has been</span>
<span style="color: #ffa07a;">reinitialized, and we can assume from our other traces that the NO HZ</span>
<span style="color: #ffa07a;">code is running again to catch up on the tick, although no trace points</span>
<span style="color: #ffa07a;">currently represent that. This process took 33 microseconds, where we</span>
<span style="color: #ffa07a;">see RCU handling a context switch, and eventually the schedule takes place.</span>



<span style="color: #ffa07a;">function_graph</span>
<span style="color: #ffa07a;">--------------</span>

<span style="color: #ffa07a;">The "function" tracer is extremely informative, albeit invasive, but</span>
<span style="color: #ffa07a;">it is a bit difficult for a human to read.</span>

<span style="color: #ffa07a;">          &lt;idle&gt;-0     [000] ....1.. 10698.878897: sub_preempt_count &lt;-__schedule</span>
<span style="color: #ffa07a;">            less-3062  [006] ....... 10698.878897: add_preempt_count &lt;-migrate_disable</span>
<span style="color: #ffa07a;">             cat-3061  [007] d...... 10698.878897: add_preempt_count &lt;-_raw_spin_lock</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [000] ....... 10698.878897: add_preempt_count &lt;-cpu_idle</span>
<span style="color: #ffa07a;">            less-3062  [006] ....11. 10698.878897: pin_current_cpu &lt;-migrate_disable</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [000] ....1.. 10698.878898: tick_nohz_idle_enter &lt;-cpu_idle</span>
<span style="color: #ffa07a;">             cat-3061  [007] d...1.. 10698.878898: sub_preempt_count &lt;-__raw_spin_unlock</span>
<span style="color: #ffa07a;">            less-3062  [006] ....111 10698.878898: sub_preempt_count &lt;-migrate_disable</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [000] ....1.. 10698.878898: set_cpu_sd_state_idle &lt;-tick_nohz_idle_enter</span>
<span style="color: #ffa07a;">             cat-3061  [007] ....... 10698.878898: free_delayed &lt;-__slab_alloc.isra.60</span>
<span style="color: #ffa07a;">            less-3062  [006] .....11 10698.878898: migrate_disable &lt;-get_page_from_freelist</span>
<span style="color: #ffa07a;">            less-3062  [006] .....11 10698.878898: add_preempt_count &lt;-migrate_disable</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [000] d...1.. 10698.878898: __tick_nohz_idle_enter &lt;-tick_nohz_idle_enter</span>
<span style="color: #ffa07a;">            less-3062  [006] ....112 10698.878898: sub_preempt_count &lt;-migrate_disable</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [000] d...1.. 10698.878898: ktime_get &lt;-__tick_nohz_idle_enter</span>
<span style="color: #ffa07a;">             cat-3061  [007] ....... 10698.878898: __rt_mutex_init &lt;-tracing_open</span>


<span style="color: #ffa07a;">The "function_graph" tracer is a bit more easy on the eyes, and lets</span>
<span style="color: #ffa07a;">the developer follow the code in much more detail.</span>

<span style="color: #ffa07a;">&gt;# echo function_graph &gt; current_tracer</span>
<span style="color: #ffa07a;">&gt;# cat trace</span>
<span style="color: #ffa07a;"># tracer: function_graph</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;"># CPU  DURATION                  FUNCTION CALLS</span>
<span style="color: #ffa07a;"># |     |   |                     |   |   |   |</span>
<span style="color: #ffa07a;"> 5)   0.125 us    |            source_load();</span>
<span style="color: #ffa07a;"> 5)   0.137 us    |            idle_cpu();</span>
<span style="color: #ffa07a;"> 5)   0.105 us    |            source_load();</span>
<span style="color: #ffa07a;"> 5)   0.110 us    |            idle_cpu();</span>
<span style="color: #ffa07a;"> 5)   0.132 us    |            source_load();</span>
<span style="color: #ffa07a;"> 5)   0.134 us    |            idle_cpu();</span>
<span style="color: #ffa07a;"> 5)   0.127 us    |            source_load();</span>
<span style="color: #ffa07a;"> 5)   0.144 us    |            idle_cpu();</span>
<span style="color: #ffa07a;"> 5)   0.132 us    |            source_load();</span>
<span style="color: #ffa07a;"> 5)   0.112 us    |            idle_cpu();</span>
<span style="color: #ffa07a;"> 5)   0.120 us    |            source_load();</span>
<span style="color: #ffa07a;"> 5)   0.130 us    |            idle_cpu();</span>
<span style="color: #ffa07a;"> 5) + 20.812 us   |          } /* find_busiest_group */</span>
<span style="color: #ffa07a;"> 5) + 21.905 us   |        } /* load_balance */</span>
<span style="color: #ffa07a;"> 5)   0.099 us    |        msecs_to_jiffies();</span>
<span style="color: #ffa07a;"> 5)   0.120 us    |        __rcu_read_unlock();</span>
<span style="color: #ffa07a;"> 5)               |        _raw_spin_lock() {</span>
<span style="color: #ffa07a;"> 5)   0.115 us    |          add_preempt_count();</span>
<span style="color: #ffa07a;"> 5)   1.115 us    |        }</span>
<span style="color: #ffa07a;"> 5) + 46.645 us   |      } /* idle_balance */</span>
<span style="color: #ffa07a;"> 5)               |      put_prev_task_rt() {</span>
<span style="color: #ffa07a;"> 5)               |        update_curr_rt() {</span>
<span style="color: #ffa07a;"> 5)               |          cpuacct_charge() {</span>
<span style="color: #ffa07a;"> 5)   0.110 us    |            __rcu_read_lock();</span>
<span style="color: #ffa07a;"> 5)   0.110 us    |            __rcu_read_unlock();</span>
<span style="color: #ffa07a;"> 5)   2.111 us    |          }</span>
<span style="color: #ffa07a;"> 5)   0.100 us    |          sched_avg_update();</span>
<span style="color: #ffa07a;"> 5)               |          _raw_spin_lock() {</span>
<span style="color: #ffa07a;"> 5)   0.116 us    |            add_preempt_count();</span>
<span style="color: #ffa07a;"> 5)   1.151 us    |          }</span>
<span style="color: #ffa07a;"> 5)   0.122 us    |          balance_runtime();</span>
<span style="color: #ffa07a;"> 5)   0.110 us    |          sub_preempt_count();</span>
<span style="color: #ffa07a;"> 5)   8.165 us    |        }</span>
<span style="color: #ffa07a;"> 5)   9.152 us    |      }</span>
<span style="color: #ffa07a;"> 5)   0.148 us    |      pick_next_task_fair();</span>
<span style="color: #ffa07a;"> 5)   0.112 us    |      pick_next_task_stop();</span>
<span style="color: #ffa07a;"> 5)   0.117 us    |      pick_next_task_rt();</span>
<span style="color: #ffa07a;"> 5)   0.123 us    |      pick_next_task_fair();</span>
<span style="color: #ffa07a;"> 5)   0.138 us    |      pick_next_task_idle();</span>
<span style="color: #ffa07a;"> ------------------------------------------</span>
<span style="color: #ffa07a;"> 5)   ksoftir-39   =&gt;    &lt;idle&gt;-0   </span>
<span style="color: #ffa07a;"> ------------------------------------------</span>

<span style="color: #ffa07a;"> 5)               |      finish_task_switch() {</span>
<span style="color: #ffa07a;"> 5)               |        _raw_spin_unlock_irq() {</span>
<span style="color: #ffa07a;"> 5)   0.260 us    |          sub_preempt_count();</span>
<span style="color: #ffa07a;"> 5)   1.289 us    |        }</span>
<span style="color: #ffa07a;"> 5)   2.309 us    |      }</span>
<span style="color: #ffa07a;"> 5)   0.132 us    |      sub_preempt_count();</span>
<span style="color: #ffa07a;"> 5) ! 151.784 us  |    } /* __schedule */</span>
<span style="color: #ffa07a;"> 5)   0.272 us    |  } /* sub_preempt_count */</span>


<span style="color: #ffa07a;">The "function" tracer only traces the start of the function where as the</span>
<span style="color: #ffa07a;">"function_graph" tracer also traces the exit of the function, allowing</span>
<span style="color: #ffa07a;">to show a flow of function calls in the kernel. As one function calls</span>
<span style="color: #ffa07a;">the next function, it is indented in the trace and C code curly brackets</span>
<span style="color: #ffa07a;">are placed around them. When there'</span>s a leaf <span style="color: #00ffff;">function</span> (a <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">that</span>
does not call any other <span style="color: #00ffff;">function</span>, or any <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">that</span> happens to be
traced), it is simply finished with a <span style="color: #ffa07a;">";"</span>.

This tracer has a different format than the other tracers, to help
ease the reading of the trace. The first number <span style="color: #ffa07a;">"5)"</span> represents the
CPU that the trace happened on. The second number is the time the
<span style="color: #00ffff;">function</span> <span style="color: #87cefa;">took</span> to execute. Note, this time also include the overhead
of the <span style="color: #ffa07a;">"function_graph"</span> tracer itself, so for functions that have
several other functions traced within it, its time will be rather
exaggerated. For leaf functions, the time is rather accurate.

When a schedule switch is detected (does not require the sched_switch
event enabled, as all traces record the pid), it shows up as separately
displayed.

 ------------------------------------------
 5)   ksoftir-39   =&gt;    &lt;idle&gt;-0   
 ------------------------------------------

The name is cropped to 7 characters (from <span style="color: #ffa07a;">"ksoftirqd"</span> to <span style="color: #ffa07a;">"ksoftir"</span>).


Follow a <span style="color: #00ffff;">function</span>
-----------------

Because the <span style="color: #ffa07a;">"function_graph"</span> tracer records both the start and exit
of a <span style="color: #00ffff;">function</span>, several more features are possible. One of these features
is to graph only a specific function. That is, to see what a specific
<span style="color: #00ffff;">function</span> <span style="color: #87cefa;">calls</span> and ignore all other functions.

For example, if you are interested<span style="color: #00ffff;"> in</span> what the sys_read() <span style="color: #00ffff;">function</span>
calls, you can use the <span style="color: #ffa07a;">"set_graph_function"</span> file<span style="color: #00ffff;"> in</span> the tracing
debug file system.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo sys_read &gt; set_graph_function</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo function_graph &gt; current_tracer</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sleep 10</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat trace</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">tracer: function_graph</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">CPU  DURATION                  FUNCTION CALLS</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">|     |   |                     |   |   |   |</span>
 0)               |  sys_read() {
 0)   0.126 us    |    fget_light();
 0)               |    vfs_read() {
 0)               |      rw_verify_area() {
 0)               |        security_file_permission() {
 0)   0.077 us    |          cap_file_permission();
 0)   0.076 us    |          __fsnotify_parent();
 0)   0.100 us    |          fsnotify();
 0)   2.001 us    |        }
 0)   2.608 us    |      }
 0)               |      tty_read() {
 0)   0.070 us    |        tty_paranoia_check();
 0)               |        tty_ldisc_ref_wait() {
 0)               |          tty_ldisc_try() {
 0)               |            _raw_spin_lock_irqsave() {
 0)   0.130 us    |              add_preempt_count();
 0)   0.759 us    |            }
 0)               |            _raw_spin_unlock_irqrestore() {
 0)   0.132 us    |              sub_preempt_count();
 0)   0.774 us    |            }
 0)   2.576 us    |          }
 0)   3.161 us    |        }
 0)               |        n_tty_read() {
 0)               |          _mutex_lock_interruptible() {
 0)   0.087 us    |            rt_mutex_lock_interruptible();
 0)   0.694 us    |          }
 0)               |          add_wait_queue() {
 0)               |            migrate_disable() {
 0)   0.100 us    |              add_preempt_count();
 0)   0.073 us    |              pin_current_cpu();
 0)   0.085 us    |              sub_preempt_count();
 0)   1.829 us    |            }
 0)   0.060 us    |            rt_spin_lock();
 0)   0.065 us    |            rt_spin_unlock();
 0)               |            migrate_enable() {
 0)   0.077 us    |              add_preempt_count();
 0)   0.070 us    |              unpin_current_cpu();
 0)   0.077 us    |              sub_preempt_count();
 0)   1.847 us    |            }
 0)   5.899 us    |          }


The above shows the flow of functions called by sys_read().


To reset the <span style="color: #ffa07a;">"set_graph_function"</span> simply write into that file like
the <span style="color: #ffa07a;">"set_ftrace_filter"</span> file is done.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo &gt; set_graph_function</span>


Time a <span style="color: #00ffff;">function</span>
---------------

As the <span style="color: #ffa07a;">"function_graph"</span> tracer is associated to the <span style="color: #ffa07a;">"function"</span> tracer
it is also affected by the <span style="color: #ffa07a;">"set_ftrace_filter"</span>, <span style="color: #ffa07a;">"set_ftrace_notrace"</span>
as well as the sysctl feature <span style="color: #ffa07a;">"kernel.ftrace_enabled"</span>.

As mentioned previously, only the leaf functions contain the most accurate
<span style="color: #b0c4de;">times</span> of execution. By filtering on a specific <span style="color: #00ffff;">function</span>, you can see
the time it takes to execute a single function.


&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo do_IRQ &gt; set_ftrace_filter</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo function_graph &gt; current_tracer</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sleep 10</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat trace</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">tracer: function_graph</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">CPU  DURATION                  FUNCTION CALLS</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">|     |   |                     |   |   |   |</span>
 4)   ==========&gt; |
 4)   6.486 us    |  do_IRQ();
 0)   ==========&gt; |
 0)   3.801 us    |  do_IRQ();
 4)   ==========&gt; |
 4)   3.221 us    |  do_IRQ();
 0)   ==========&gt; |
 0) + 11.153 us   |  do_IRQ();
 0)   ==========&gt; |
 0) + 10.968 us   |  do_IRQ();
 6)   ==========&gt; |
 6)   9.280 us    |  do_IRQ();
 0)   ==========&gt; |
 0)   9.467 us    |  do_IRQ();
 0)   ==========&gt; |
 0) + 11.238 us   |  do_IRQ();


The <span style="color: #ffa07a;">"==========&gt;"</span> show when an interrupt entered. The <span style="color: #ffa07a;">"&lt;=========="</span> is
missing because it is associated with the exit part of the trace.
As <span style="color: #ffa07a;">"do_IRQ"</span> is a leaf <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">here</span>, the exit arrow was folded into
the <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">and</span> does not appear<span style="color: #00ffff;"> in</span> the trace.


Events<span style="color: #00ffff;"> in</span> <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">graph</span> tracer
-------------------------------

As explained previously, events can be enabled with all tracers.
But with the <span style="color: #ffa07a;">"function_graph"</span> tracer, they are displayed a little
differently.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 1 &gt; events/irq/enable</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo do_IRQ &gt; set_ftrace_filter</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo function_graph &gt; current_tracer</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sleep 10</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat trace</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">tracer: function_graph</span>
<span style="color: #ff7f24;">#</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">CPU  DURATION                  FUNCTION CALLS</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">|     |   |                     |   |   |   |</span>
 5)   ==========&gt; |
 5)               |  do_IRQ() {
 5)               |  /* irq_handler_entry: <span style="color: #eedd82;">irq</span>=43 <span style="color: #eedd82;">name</span>=em1 */
 5)               |  /* irq_handler_exit: <span style="color: #eedd82;">irq</span>=43 <span style="color: #eedd82;">ret</span>=handled */
 5) + 15.721 us   |  }
 5)   &lt;========== |
 3)               |  /* softirq_raise: <span style="color: #eedd82;">vec</span>=3 [<span style="color: #eedd82;">action</span>=NET_RX] */
 3)               |  /* softirq_entry: <span style="color: #eedd82;">vec</span>=3 [<span style="color: #eedd82;">action</span>=NET_RX] */
 3)               |  /* softirq_exit: <span style="color: #eedd82;">vec</span>=3 [<span style="color: #eedd82;">action</span>=NET_RX] */
 0)   ==========&gt; |
 0)               |  do_IRQ() {
 0)               |  /* irq_handler_entry: <span style="color: #eedd82;">irq</span>=43 <span style="color: #eedd82;">name</span>=em1 */
 0)               |  /* irq_handler_exit: <span style="color: #eedd82;">irq</span>=43 <span style="color: #eedd82;">ret</span>=handled */
 0)   8.915 us    |  }
 0)   &lt;========== |
 3)               |  /* softirq_raise: <span style="color: #eedd82;">vec</span>=3 [<span style="color: #eedd82;">action</span>=NET_RX] */
 3)               |  /* softirq_entry: <span style="color: #eedd82;">vec</span>=3 [<span style="color: #eedd82;">action</span>=NET_RX] */
 3)               |  /* softirq_exit: <span style="color: #eedd82;">vec</span>=3 [<span style="color: #eedd82;">action</span>=NET_RX] */
 0)               |  /* softirq_raise: <span style="color: #eedd82;">vec</span>=1 [<span style="color: #eedd82;">action</span>=TIMER] */
 0)               |  /* softirq_raise: <span style="color: #eedd82;">vec</span>=9 [<span style="color: #eedd82;">action</span>=RCU] */
 ------------------------------------------
 0)    &lt;idle&gt;-0    =&gt;   ksoftir-3   
 ------------------------------------------

 0)               |  /* softirq_entry: <span style="color: #eedd82;">vec</span>=1 [<span style="color: #eedd82;">action</span>=TIMER] */
 0)               |  /* softirq_exit: <span style="color: #eedd82;">vec</span>=1 [<span style="color: #eedd82;">action</span>=TIMER] */
 0)               |  /* softirq_entry: <span style="color: #eedd82;">vec</span>=9 [<span style="color: #eedd82;">action</span>=RCU] */
 0)               |  /* softirq_exit: <span style="color: #eedd82;">vec</span>=9 [<span style="color: #eedd82;">action</span>=RCU] */
 ------------------------------------------
 0)   ksoftir-3    =&gt;    &lt;idle&gt;-0   
 ------------------------------------------

Keeping with the C formatting, events<span style="color: #00ffff;"> in</span> the <span style="color: #ffa07a;">"function_graph"</span> tracer
appear as comments. Recording the interrupt events gives more detail
to what interrupts are occurring when <span style="color: #ffa07a;">"do_IRQ()"</span> is called. As the
<span style="color: #ffa07a;">"do_IRQ()"</span> exit trace is not folded, the <span style="color: #ffa07a;">"&lt;=========="</span> appears to
display that the interrupt is over.


Annotations
-----------

In the traces, including the <span style="color: #ffa07a;">"function_graph"</span> tracer, you may see
annotations around the times. <span style="color: #ffa07a;">"+"</span> and <span style="color: #ffa07a;">"!"</span>. A <span style="color: #ffa07a;">"+"</span> appears when the
<span style="color: #b0c4de;">time</span> between events is greater than 10 microseconds, and a <span style="color: #ffa07a;">"!"</span> appears
when that time is greater than 100 microseconds. You can see this<span style="color: #00ffff;"> in</span> the
above tracers:

  &lt;idle&gt;-0       0d..h4..    2us+: ttwu_do_activate.constprop.90 &lt;-try_to_wake_up
  &lt;idle&gt;-0       5d...3..   63us : __schedule &lt;-preempt_schedule


 5) + 20.812 us   |          } /* find_busiest_group */
 5) + 21.905 us   |        } /* load_balance */

 5) ! 151.784 us  |    } /* __schedule */



Buffer size
-----------

When tracing functions, you will almost always use events. This is because
the amount of functions being traced will quickly fill the ring buffer
faster than anything can read from it. The amount lost can be minimized
with filtering the trace as well as increasing the size of the buffer.

The size of the buffer is controlled by the <span style="color: #ffa07a;">"buffer_size_kb"</span> file.
As the name suggests, the size is<span style="color: #00ffff;"> in</span> kilobytes. When you first boot up,
as tracing is used by only a small minority of users, the trace buffer
is compressed. The first time you use any of the tracing features,
the tracing buffer will automatically increase to a decent size.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat buffer_size_kb </span>
<span style="color: #87cefa;">7</span> (expanded: 1408)

Note, for efficiency reasons, the buffer is split into multiple buffers
per CPU. The size displayed by <span style="color: #ffa07a;">"buffer_size_kb"</span> is the size of each
CPU buffer. To see the total size of all buffers look at
<span style="color: #ffa07a;">"buffer_total_size_kb"</span>

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat buffer_total_size_kb</span>
<span style="color: #87cefa;">56</span> (expanded: 11264)

After running any trace, the buffer will expand to the size that is
denoted by the <span style="color: #ffa07a;">"expanded"</span> value.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 1 &gt; events/enable</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat buffer_size_kb </span>
1408

To change the size of the buffer, simply echo<span style="color: #00ffff;"> in</span> a number.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo 10000 &gt; buffer_size_kb</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat buffer_size_kb</span>
10000

Note, if you change the size before using any tracer, the buffers
will go to that size, and the expanded value will then be ignored.


Buffer size per CPU
-------------------

If there<span style="color: #ffa07a;">'s a case you care about activity on one CPU more than another</span>
<span style="color: #ffa07a;">CPU, and you need to save memory, you can change the sizes of the</span>
<span style="color: #ffa07a;">ring buffers per CPU. These files exist in a "per_cpu/cpuX/" directory.</span>

<span style="color: #ffa07a;">&gt;# cat per_cpu/cpu1/buffer_size_kb</span>
<span style="color: #ffa07a;">10000</span>

<span style="color: #ffa07a;">&gt;# echo 100 &gt; per_cpu/cpu1/buffer_size_kb</span>
<span style="color: #ffa07a;">&gt;# cat per_cpu/cpu1/buffer_size_kb</span>
<span style="color: #ffa07a;">100</span>

<span style="color: #ffa07a;">When the per CPU buffers differ in size, the top level buffer_size_kb</span>
<span style="color: #ffa07a;">will display an "X".</span>

<span style="color: #ffa07a;">&gt;# cat buffer_size_kb</span>
<span style="color: #ffa07a;">X</span>

<span style="color: #ffa07a;">But the total size will still display the amount allocated.</span>

<span style="color: #ffa07a;">&gt;# cat buffer_total_size_kb </span>
<span style="color: #ffa07a;">70100</span>


<span style="color: #ffa07a;">Trace Marker</span>
<span style="color: #ffa07a;">------------</span>

<span style="color: #ffa07a;">It is sometimes useful to synchronize actions in userspace with events</span>
<span style="color: #ffa07a;">within the kernel. The "trace_marker" allows userspace to write into</span>
<span style="color: #ffa07a;">the ftrace buffer.</span>

<span style="color: #ffa07a;">&gt;# echo hello world &gt; trace_marker </span>
<span style="color: #ffa07a;">&gt;# cat trace</span>
<span style="color: #ffa07a;"># tracer: nop</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;"># entries-in-buffer/entries-written: 1/1   #P:8</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;">#                              _-------=&gt; irqs-off          </span>
<span style="color: #ffa07a;">#                            /  _------=&gt; need-resched      </span>
<span style="color: #ffa07a;">#                            |/  _-----=&gt; need-resched_lazy </span>
<span style="color: #ffa07a;">#                            ||/  _----=&gt; hardirq/softirq   </span>
<span style="color: #ffa07a;">#                            |||/  _---=&gt; preempt-depth     </span>
<span style="color: #ffa07a;">#                            ||||/  _--=&gt; preempt-lazy-depth</span>
<span style="color: #ffa07a;">#                            ||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ffa07a;">#                            |||||| /     delay</span>
<span style="color: #ffa07a;">#           TASK-PID   CPU#  |||||||    TIMESTAMP  FUNCTION</span>
<span style="color: #ffa07a;">#              | |       |   |||||||       |         |</span>
<span style="color: #ffa07a;">            bash-1086  [001] .....11 21351.346541: tracing_mark_write: hello world</span>

<span style="color: #ffa07a;">Writing into the kernel is very light weight. User programs can take</span>
<span style="color: #ffa07a;">advantage of this with the following C code:</span>

<span style="color: #ffa07a;">        static int trace_fd = -1;</span>

<span style="color: #ffa07a;">        void trace_write(const char *fmt, ...)</span>
<span style="color: #ffa07a;">        {</span>
<span style="color: #ffa07a;">                va_list ap;</span>
<span style="color: #ffa07a;">                char buf[256];</span>
<span style="color: #ffa07a;">                int n;</span>

<span style="color: #ffa07a;">                if (trace_fd &lt; 0)</span>
<span style="color: #ffa07a;">                        return;</span>

<span style="color: #ffa07a;">                va_start(ap, fmt);</span>
<span style="color: #ffa07a;">                n = vsnprintf(buf, 256, fmt, ap);</span>
<span style="color: #ffa07a;">                va_end(ap);</span>

<span style="color: #ffa07a;">                write(trace_fd, buf, n);</span>
<span style="color: #ffa07a;">        }</span>


<span style="color: #ffa07a;">        [...]</span>

<span style="color: #ffa07a;">        trace_fd = open("trace_marker", WR_ONLY);</span>


<span style="color: #ffa07a;">and later use the "trace_write()" function to record into the ftrace</span>
<span style="color: #ffa07a;">buffer.</span>

<span style="color: #ffa07a;">        trace_write("record this event\n");</span>


<span style="color: #ffa07a;">tracer options</span>
<span style="color: #ffa07a;">--------------</span>

<span style="color: #ffa07a;">There are several options that can affect the formating of the trace</span>
<span style="color: #ffa07a;">output as well as how the tracers behave. Some trace options only exist</span>
<span style="color: #ffa07a;">for a given tracer and their control file appears only when the tracer</span>
<span style="color: #ffa07a;">is activated.</span>

<span style="color: #ffa07a;">The trace option control files exist in the "options" directory.</span>

<span style="color: #ffa07a;">&gt;# ls options</span>
<span style="color: #ffa07a;">annotate         graph-time       print-parent  sym-userobj</span>
<span style="color: #ffa07a;">bin              hex              raw           test_nop_accept</span>
<span style="color: #ffa07a;">block            irq-info         record-cmd    test_nop_refuse</span>
<span style="color: #ffa07a;">branch           latency-format   sleep-time    trace_printk</span>
<span style="color: #ffa07a;">context-info     markers          stacktrace    userstacktrace</span>
<span style="color: #ffa07a;">disable_on_free  overwrite        sym-addr      verbose</span>
<span style="color: #ffa07a;">ftrace_preempt   printk-msg-only  sym-offset</span>

<span style="color: #ffa07a;">The "function_graph" tracer adds several of its own.</span>

<span style="color: #ffa07a;">&gt;# echo function_graph &gt; current_tracer</span>
<span style="color: #ffa07a;">&gt;# ls options</span>
<span style="color: #ffa07a;">annotate           funcgraph-cpu       irq-info         sleep-time</span>
<span style="color: #ffa07a;">bin                funcgraph-duration  latency-format   stacktrace</span>
<span style="color: #ffa07a;">block              funcgraph-irqs      markers          sym-addr</span>
<span style="color: #ffa07a;">branch             funcgraph-overhead  overwrite        sym-offset</span>
<span style="color: #ffa07a;">context-info       funcgraph-overrun   printk-msg-only  sym-userobj</span>
<span style="color: #ffa07a;">disable_on_free    funcgraph-proc      print-parent     trace_printk</span>
<span style="color: #ffa07a;">ftrace_preempt     graph-time          raw              userstacktrace</span>
<span style="color: #ffa07a;">funcgraph-abstime  hex                 record-cmd       verbose</span>



<span style="color: #ffa07a;">  annotate - It is sometimes confusing when the CPU buffers are full</span>
<span style="color: #ffa07a;">               and one CPU buffer had a lot of events recently, thus</span>
<span style="color: #ffa07a;">             a shorter time frame, were another CPU may have only had</span>
<span style="color: #ffa07a;">             a few events, which lets it have older events. When</span>
<span style="color: #ffa07a;">             the trace is reported, it shows the oldest events first,</span>
<span style="color: #ffa07a;">             and it may look like only one CPU ran (the one with the</span>
<span style="color: #ffa07a;">             oldest events). When the annotate option is set, it will</span>
<span style="color: #ffa07a;">             display when a new CPU buffer started:</span>

<span style="color: #ffa07a;">          &lt;idle&gt;-0     [005] d...1..   910.328077: cpuidle_wrap_enter &lt;-cpuidle_enter_tk</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [005] d...1..   910.328077: ktime_get &lt;-cpuidle_wrap_enter</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [005] d...1..   910.328078: intel_idle &lt;-cpuidle_enter</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [005] d...1..   910.328078: leave_mm &lt;-intel_idle</span>
<span style="color: #ffa07a;">##### CPU 7 buffer started ####</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [007] d...1..   910.360866: tick_do_update_jiffies64 &lt;-tick_check_idle</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [007] d...1..   910.360866: _raw_spin_lock &lt;-tick_do_update_jiffies64</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [007] d...1..   910.360866: add_preempt_count &lt;-_raw_spin_lock</span>


<span style="color: #ffa07a;">  bin - This will print out the formats in raw binary.</span>

<span style="color: #ffa07a;">  block - When set, reading trace_pipe will not block when polled.</span>

<span style="color: #ffa07a;">  context-info - Show only the event data. Hides the comm, PID,</span>
<span style="color: #ffa07a;">                   timestamp, CPU, and other useful data.</span>

<span style="color: #ffa07a;">  disable_on_free - When the free_buffer is closed, tracing will</span>
<span style="color: #ffa07a;">                      stop (tracing_on set to 0).</span>

<span style="color: #ffa07a;">  ftrace_preempt - Normally the function tracer disables interrupts as</span>
<span style="color: #ffa07a;">                   the recursion protection will hide interrupts from being</span>
<span style="color: #ffa07a;">                 traced if the interrupt happened while another function</span>
<span style="color: #ffa07a;">                 was being traced. If this option is enabled, then it</span>
<span style="color: #ffa07a;">                 will not disable interrupts but will only disable</span>
<span style="color: #ffa07a;">                 preemption. But note, if an interrupt were to arrive</span>
<span style="color: #ffa07a;">                 when another function is being traced, all functions</span>
<span style="color: #ffa07a;">                 within that interrupt will not be traced, as function</span>
<span style="color: #ffa07a;">                 tracing is temporarily disablde for recursion protection.</span>

<span style="color: #ffa07a;">  graph-time - When running function graph tracer, to include the</span>
<span style="color: #ffa07a;">                 time to call nested functions. When this is not set,</span>
<span style="color: #ffa07a;">               the time reported for the function will only include</span>
<span style="color: #ffa07a;">               the time the function itself executed for, not the time</span>
<span style="color: #ffa07a;">               for functions that it called.</span>

<span style="color: #ffa07a;">  hex - Similar to raw, but the numbers will be in a hexadecimal</span>
<span style="color: #ffa07a;">        format.</span>

<span style="color: #ffa07a;">  irq-info - Shows the interrupt, preempt count, need resched data.</span>
<span style="color: #ffa07a;">               When disabled, the trace looks like:</span>

<span style="color: #ffa07a;"># tracer: function</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;"># entries-in-buffer/entries-written: 319494/4972382   #P:8</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;">#           TASK-PID   CPU#      TIMESTAMP  FUNCTION</span>
<span style="color: #ffa07a;">#              | |       |          |         |</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [004]    983.062800: lock_hrtimer_base.isra.25 &lt;-__hrtimer_start_range_ns</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [004]    983.062801: _raw_spin_lock_irqsave &lt;-lock_hrtimer_base.isra.25</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [004]    983.062801: add_preempt_count &lt;-_raw_spin_lock_irqsave</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [004]    983.062801: __remove_hrtimer &lt;-__hrtimer_start_range_ns</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [004]    983.062801: hrtimer_force_reprogram &lt;-__remove_hrtimer</span>


<span style="color: #ffa07a;">  latency-format - This option changes the trace. When</span>
<span style="color: #ffa07a;">                   it is enabled, the trace displays</span>
<span style="color: #ffa07a;">                   additional information about the</span>
<span style="color: #ffa07a;">                   latencies, as described in "Latency</span>
<span style="color: #ffa07a;">                   trace format".</span>

<span style="color: #ffa07a;">  markers - When set, the trace_marker is writable (only by root).</span>
<span style="color: #ffa07a;">              When disabled, the trace_marker will error with EINVAL</span>
<span style="color: #ffa07a;">            on write.</span>

<span style="color: #ffa07a;">  overwrite - This controls what happens when the trace buffer is</span>
<span style="color: #ffa07a;">              full. If "1" (default), the oldest events are</span>
<span style="color: #ffa07a;">              discarded and overwritten. If "0", then the newest</span>
<span style="color: #ffa07a;">              events are discarded.</span>
<span style="color: #ffa07a;">                (see per_cpu/cpu0/stats for overrun and dropped)</span>

<span style="color: #ffa07a;">  printk-msg-only - When set, trace_printk()s will only show the format</span>
<span style="color: #ffa07a;">                      and not their parameters (if trace_bprintk() or</span>
<span style="color: #ffa07a;">                    trace_bputs() was used to save the trace_printk()).</span>

<span style="color: #ffa07a;">  print-parent - On function traces, display the calling (parent)</span>
<span style="color: #ffa07a;">                 function as well as the function being traced.</span>

<span style="color: #ffa07a;">    print-parent:</span>
<span style="color: #ffa07a;">       bash-1423  [006]   1755.774709: msecs_to_jiffies &lt;-idle_balance</span>

<span style="color: #ffa07a;">    noprint-parent:</span>
<span style="color: #ffa07a;">       bash-1423  [006]   1755.774709: msecs_to_jiffies</span>


<span style="color: #ffa07a;">  raw - This will display raw numbers. This option is best for</span>
<span style="color: #ffa07a;">        use with user applications that can translate the raw</span>
<span style="color: #ffa07a;">        numbers better than having it done in the kernel.</span>

<span style="color: #ffa07a;">  record-cmd - When any event or tracer is enabled, a hook is enabled</span>
<span style="color: #ffa07a;">                 in the sched_switch trace point to fill comm cache</span>
<span style="color: #ffa07a;">               with mapped pids and comms. But this may cause some</span>
<span style="color: #ffa07a;">               overhead, and if you only care about pids, and not the</span>
<span style="color: #ffa07a;">               name of the task, disabling this option can lower the</span>
<span style="color: #ffa07a;">               impact of tracing.</span>

<span style="color: #ffa07a;">  sleep-time - When running function graph tracer, to include</span>
<span style="color: #ffa07a;">                 the time a task schedules out in its function.</span>
<span style="color: #ffa07a;">               When enabled, it will account time the task has been</span>
<span style="color: #ffa07a;">               scheduled out as part of the function call.</span>

<span style="color: #ffa07a;">  stacktrace - This is one of the options that changes the trace</span>
<span style="color: #ffa07a;">               itself. When a trace is recorded, so is the stack</span>
<span style="color: #ffa07a;">               of functions. This allows for back traces of</span>
<span style="color: #ffa07a;">               trace sites.</span>

<span style="color: #ffa07a;">  sym-addr - this will also display the function address as well</span>
<span style="color: #ffa07a;">             as the function name.</span>

<span style="color: #ffa07a;">  sym-offset - Display not only the function name, but also the</span>
<span style="color: #ffa07a;">               offset in the function. For example, instead of</span>
<span style="color: #ffa07a;">               seeing just "ktime_get", you will see</span>
<span style="color: #ffa07a;">               "ktime_get+0xb/0x20".</span>

<span style="color: #ffa07a;">    sym-offset:</span>
<span style="color: #ffa07a;">      bash-1423  [006]   1755.774709: msecs_to_jiffies+0x0/0x20</span>

<span style="color: #ffa07a;">    sym-addr:</span>
<span style="color: #ffa07a;">      bash-1423  [006]   1755.774709: msecs_to_jiffies &lt;ffffffff8106b5f0&gt;</span>


<span style="color: #ffa07a;">  sym-userobj - when user stacktrace are enabled, look up which</span>
<span style="color: #ffa07a;">                object the address belongs to, and print a</span>
<span style="color: #ffa07a;">                relative address. This is especially useful when</span>
<span style="color: #ffa07a;">                ASLR is on, otherwise you don'</span>t get a chance to
                resolve the address to object/file/line after
                the app is no longer running

                The lookup is performed when you read
                trace,trace_pipe. Example:

        a.out-1623  [000] 40874.465068: /root/a.out[+0x480] &lt;-/root/a.out[+0x494] &lt;- /root/a.out[+0x4a8] &lt;- /lib/libc-2.7.so[+0x1e1a6]

  trace_printk - Can disable trace_printk() from writing into the buffer.

  userstacktrace - This option changes the trace. It records a
                   stacktrace of the current userspace thread at each event.

  verbose - This deals with the trace file when the
            latency-format option is enabled.

    bash  4000 1 0 00000000 00010a95 [58127d26] 1720.415ms <span style="color: #ffa07a;">\</span>
    (+0.000ms): simple_strtoul (strict_strtoul)




This has been quite an<span style="color: #00ffff;"> in</span> depth look at how to use ftrace via the
debug file system. But it can be quite daunting to handle all these
different files. Luckily, there<span style="color: #ffa07a;">'s a tool that can do most of this</span>
<span style="color: #ffa07a;">work for you. It'</span>s called <span style="color: #ffa07a;">"trace-cmd"</span>



Using trace-cmd
---------------

trace-cmd is a tool that interacts with the ftrace tracing facility.
It reads and writes to the same files that are described above as
well as reading the files that can transfer the binary data of
the kernel tracing buffers<span style="color: #00ffff;"> in</span> an efficient manner to be read later.
The tool is very simple and easy to use.

There are several man pages for trace-cmd. First look at 

  man trace-cmd

to find out more information on the other commands. All of trace-cmd<span style="color: #ffa07a;">'s</span>
<span style="color: #ffa07a;">commands also have their own man pages in the format of:</span>

<span style="color: #ffa07a;">  man trace-cmd-&lt;command&gt;</span>

<span style="color: #ffa07a;">For example, the "record" command'</span>s man page is under trace-cmd-record.

This document will describe all the options for each command, but
instead will briefly discuss how to use trace-cmd and describe most of
its commands.



trace-cmd record and report
---------------------------

To use ftrace tracers and events you must first have to start tracing
by either echoing a name of a tracer into the <span style="color: #ffa07a;">"current_tracer"</span> file
or by echoing <span style="color: #ffa07a;">"1"</span> into one of the event <span style="color: #ffa07a;">"enable"</span> files.

For trace-cmd, the record option starts the tracing and will also save
the traced data into a file. Let<span style="color: #ffa07a;">'s start with an example:</span>


<span style="color: #ffa07a;">&gt;# cd ~</span>
<span style="color: #ffa07a;">&gt;# trace-cmd record -p function</span>
<span style="color: #ffa07a;">  plugin '</span><span style="color: #00ffff;">function</span><span style="color: #ffa07a;">'</span>
<span style="color: #ffa07a;">Hit Ctrl^C to stop recording</span>
<span style="color: #ffa07a;">(^C)</span>
<span style="color: #ffa07a;">Kernel buffer statistics:</span>
<span style="color: #ffa07a;">  Note: "entries" are the entries left in the kernel ring buffer and are not</span>
<span style="color: #ffa07a;">        recorded in the trace data. They should all be zero.</span>

<span style="color: #ffa07a;">CPU: 0</span>
<span style="color: #ffa07a;">entries: 0</span>
<span style="color: #ffa07a;">overrun: 38650181</span>
<span style="color: #ffa07a;">commit overrun: 0</span>
<span style="color: #ffa07a;">bytes: 3060</span>
<span style="color: #ffa07a;">oldest event ts: 15634.891771</span>
<span style="color: #ffa07a;">now ts: 15634.953219</span>
<span style="color: #ffa07a;">dropped events: 0</span>

<span style="color: #ffa07a;">CPU: 1</span>
<span style="color: #ffa07a;">entries: 0</span>
<span style="color: #ffa07a;">overrun: 38523960</span>
<span style="color: #ffa07a;">commit overrun: 0</span>
<span style="color: #ffa07a;">bytes: 1368</span>
<span style="color: #ffa07a;">oldest event ts: 15634.891771</span>
<span style="color: #ffa07a;">now ts: 15634.953938</span>
<span style="color: #ffa07a;">dropped events: 0</span>

<span style="color: #ffa07a;">CPU: 2</span>
<span style="color: #ffa07a;">entries: 0</span>
<span style="color: #ffa07a;">overrun: 41461508</span>
<span style="color: #ffa07a;">commit overrun: 0</span>
<span style="color: #ffa07a;">bytes: 1872</span>
<span style="color: #ffa07a;">oldest event ts: 15634.891773</span>
<span style="color: #ffa07a;">now ts: 15634.954630</span>
<span style="color: #ffa07a;">dropped events: 0</span>

<span style="color: #ffa07a;">CPU: 3</span>
<span style="color: #ffa07a;">entries: 0</span>
<span style="color: #ffa07a;">overrun: 38246206</span>
<span style="color: #ffa07a;">commit overrun: 0</span>
<span style="color: #ffa07a;">bytes: 36</span>
<span style="color: #ffa07a;">oldest event ts: 15634.891785</span>
<span style="color: #ffa07a;">now ts: 15634.955263</span>
<span style="color: #ffa07a;">dropped events: 0</span>

<span style="color: #ffa07a;">CPU: 4</span>
<span style="color: #ffa07a;">entries: 0</span>
<span style="color: #ffa07a;">overrun: 32730902</span>
<span style="color: #ffa07a;">commit overrun: 0</span>
<span style="color: #ffa07a;">bytes: 432</span>
<span style="color: #ffa07a;">oldest event ts: 15634.891716</span>
<span style="color: #ffa07a;">now ts: 15634.955952</span>
<span style="color: #ffa07a;">dropped events: 0</span>

<span style="color: #ffa07a;">CPU: 5</span>
<span style="color: #ffa07a;">entries: 0</span>
<span style="color: #ffa07a;">overrun: 33264601</span>
<span style="color: #ffa07a;">commit overrun: 0</span>
<span style="color: #ffa07a;">bytes: 2952</span>
<span style="color: #ffa07a;">oldest event ts: 15634.891769</span>
<span style="color: #ffa07a;">now ts: 15634.956630</span>
<span style="color: #ffa07a;">dropped events: 0</span>

<span style="color: #ffa07a;">CPU: 6</span>
<span style="color: #ffa07a;">entries: 0</span>
<span style="color: #ffa07a;">overrun: 30974204</span>
<span style="color: #ffa07a;">commit overrun: 0</span>
<span style="color: #ffa07a;">bytes: 2484</span>
<span style="color: #ffa07a;">oldest event ts: 15634.891772</span>
<span style="color: #ffa07a;">now ts: 15634.957249</span>
<span style="color: #ffa07a;">dropped events: 0</span>

<span style="color: #ffa07a;">CPU: 7</span>
<span style="color: #ffa07a;">entries: 0</span>
<span style="color: #ffa07a;">overrun: 32374274</span>
<span style="color: #ffa07a;">commit overrun: 0</span>
<span style="color: #ffa07a;">bytes: 3564</span>
<span style="color: #ffa07a;">oldest event ts: 15634.891652</span>
<span style="color: #ffa07a;">now ts: 15634.957938</span>
<span style="color: #ffa07a;">dropped events: 0</span>

<span style="color: #ffa07a;">CPU0 data recorded at offset=0x302000</span>
<span style="color: #ffa07a;">    146325504 bytes in size</span>
<span style="color: #ffa07a;">CPU1 data recorded at offset=0x8e8e000</span>
<span style="color: #ffa07a;">    148217856 bytes in size</span>
<span style="color: #ffa07a;">CPU2 data recorded at offset=0x11be8000</span>
<span style="color: #ffa07a;">    148066304 bytes in size</span>
<span style="color: #ffa07a;">CPU3 data recorded at offset=0x1a91d000</span>
<span style="color: #ffa07a;">    146219008 bytes in size</span>
<span style="color: #ffa07a;">CPU4 data recorded at offset=0x2348f000</span>
<span style="color: #ffa07a;">    145940480 bytes in size</span>
<span style="color: #ffa07a;">CPU5 data recorded at offset=0x2bfbd000</span>
<span style="color: #ffa07a;">    145403904 bytes in size</span>
<span style="color: #ffa07a;">CPU6 data recorded at offset=0x34a68000</span>
<span style="color: #ffa07a;">    141570048 bytes in size</span>
<span style="color: #ffa07a;">CPU7 data recorded at offset=0x3d16b000</span>
<span style="color: #ffa07a;">    147513344 bytes in size</span>


<span style="color: #ffa07a;">The "-p" is for ftrace tracers (use to be known as '</span>plugins<span style="color: #ffa07a;">' and the name</span>
<span style="color: #ffa07a;">is kept for historical reasons). In this case we started the</span>
<span style="color: #ffa07a;">"function" tracer. Since we did not add a command to execute, by</span>
<span style="color: #ffa07a;">default, trace-cmd will just start the tracing and record the data</span>
<span style="color: #ffa07a;">and wait for the user to hit Ctrl^C to stop.</span>

<span style="color: #ffa07a;">When the trace stops, it prints out status of each of the kernel'</span>s
per cpu trace buffers. The are:

  entries:  - Which is the number of entries still<span style="color: #00ffff;"> in</span> the kernel buffer.
              Ideally this should be zero, as trace-cmd would consume them
            all and put them into the data file.

  overrun:  - As tracing can be much faster than the saving of data,
              events can be lost due to overwriting of the old events
            that were not consumed yet when the buffer filled up.
            This is the number of events that were lost.

            The <span style="color: #ffa07a;">"function"</span> tracer can fill up the buffer extremely fast
            it is not uncommon to lose millions of events when
            tracing functions for any length of time.

  commit overrun: - This should always be zero, and if it is not, then
              the buffer size is way too small or something went wrong
            with the tracer.

  bytes: - The number of bytes consumed (not read as pages). This is
             more a status for developers of the tracing utitily.

  oldest event ts: - The timestamp for the oldest event still<span style="color: #00ffff;"> in</span> the ring
             buffer. Unless it gets overwritten, it will be the timestamp
           of the next event read.

  now ts: The current timestamp used by the tracing facility.

  dropped events: - If the buffer has overwrite mode disabled (from the
            trace options), then this will show the number of events that
          were lost due to not being able to write to the buffer because
          it was full. This is similar to the overrun field except that
          those are events that made it into the buffer but were overwritten.



By default, the file used to record the trace is called <span style="color: #ffa07a;">"trace.dat"</span>.
You can override the output file with the -o option.

To read the trace.dat file, simply run the trace-cmd report command:

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">trace-cmd report</span>
<span style="color: #eedd82;">version</span> = 6
<span style="color: #eedd82;">cpus</span>=8
       trace-cmd-3735  [003] 15618.722889: <span style="color: #00ffff;">function</span>:             __hrtimer_start_range_ns
       trace-cmd-3734  [002] 15618.722889: <span style="color: #00ffff;">function</span>:             _mutex_unlock
          &lt;idle&gt;-0     [000] 15618.722889: <span style="color: #00ffff;">function</span>:             cpuidle_wrap_enter
       trace-cmd-3735  [003] 15618.722890: <span style="color: #00ffff;">function</span>:                lock_hrtimer_base.isra.25
       trace-cmd-3734  [002] 15618.722890: <span style="color: #00ffff;">function</span>:                rt_mutex_unlock
          &lt;idle&gt;-0     [000] 15618.722890: <span style="color: #00ffff;">function</span>:                ktime_get
       trace-cmd-3735  [003] 15618.722890: <span style="color: #00ffff;">function</span>:                   _raw_spin_lock_irqsave
       trace-cmd-3735  [003] 15618.722891: <span style="color: #00ffff;">function</span>:                      add_preempt_count
       trace-cmd-3734  [002] 15618.722891: <span style="color: #00ffff;">function</span>:             __fsnotify_parent
          &lt;idle&gt;-0     [000] 15618.722891: <span style="color: #00ffff;">function</span>:             intel_idle
       trace-cmd-3735  [003] 15618.722891: <span style="color: #00ffff;">function</span>:                idle_cpu
       trace-cmd-3734  [002] 15618.722891: <span style="color: #00ffff;">function</span>:             fsnotify
          &lt;idle&gt;-0     [000] 15618.722891: <span style="color: #00ffff;">function</span>:                leave_mm
       trace-cmd-3735  [003] 15618.722891: <span style="color: #00ffff;">function</span>:                ktime_get
       trace-cmd-3734  [002] 15618.722891: <span style="color: #00ffff;">function</span>:                __srcu_read_lock
          &lt;idle&gt;-0     [000] 15618.722891: <span style="color: #00ffff;">function</span>:                   __phys_addr
       trace-cmd-3734  [002] 15618.722891: <span style="color: #00ffff;">function</span>:                   add_preempt_count
       trace-cmd-3735  [003] 15618.722891: <span style="color: #00ffff;">function</span>:                enqueue_hrtimer
       trace-cmd-3735  [003] 15618.722892: <span style="color: #00ffff;">function</span>:                _raw_spin_unlock_irqrestore
       trace-cmd-3734  [002] 15618.722892: <span style="color: #00ffff;">function</span>:                   sub_preempt_count
       trace-cmd-3735  [003] 15618.722892: <span style="color: #00ffff;">function</span>:                   sub_preempt_count
       trace-cmd-3734  [002] 15618.722892: <span style="color: #00ffff;">function</span>:                __srcu_read_unlock
       trace-cmd-3735  [003] 15618.722892: <span style="color: #00ffff;">function</span>:             schedule
       trace-cmd-3734  [002] 15618.722892: <span style="color: #00ffff;">function</span>:                   add_preempt_count
       trace-cmd-3735  [003] 15618.722893: <span style="color: #00ffff;">function</span>:                __schedule
       trace-cmd-3734  [002] 15618.722893: <span style="color: #00ffff;">function</span>:                   sub_preempt_count
       trace-cmd-3735  [003] 15618.722893: <span style="color: #00ffff;">function</span>:                   add_preempt_count
       trace-cmd-3735  [003] 15618.722893: <span style="color: #00ffff;">function</span>:                   rcu_note_context_switch
       trace-cmd-3734  [002] 15618.722893: <span style="color: #00ffff;">function</span>:             __audit_syscall_exit
       trace-cmd-3735  [003] 15618.722893: <span style="color: #00ffff;">function</span>:                   _raw_spin_lock_irq
       trace-cmd-3735  [003] 15618.722894: <span style="color: #00ffff;">function</span>:                      add_preempt_count
       trace-cmd-3734  [002] 15618.722894: <span style="color: #00ffff;">function</span>:                path_put
       trace-cmd-3735  [003] 15618.722894: <span style="color: #00ffff;">function</span>:                   deactivate_task
       trace-cmd-3734  [002] 15618.722894: <span style="color: #00ffff;">function</span>:                   dput
       trace-cmd-3735  [003] 15618.722894: <span style="color: #00ffff;">function</span>:                      dequeue_task
       trace-cmd-3734  [002] 15618.722894: <span style="color: #00ffff;">function</span>:                   mntput
       trace-cmd-3735  [003] 15618.722894: <span style="color: #00ffff;">function</span>:                         update_rq_clock
       trace-cmd-3734  [002] 15618.722894: <span style="color: #00ffff;">function</span>:                unroll_tree_refs


To filter out a CPU, use the --cpu option.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">trace-cmd report --cpu 1</span>
<span style="color: #eedd82;">version</span> = 6
<span style="color: #eedd82;">cpus</span>=8
          &lt;idle&gt;-0     [001] 15618.723287: <span style="color: #00ffff;">function</span>:             ktime_get
          &lt;idle&gt;-0     [001] 15618.723288: <span style="color: #00ffff;">function</span>:             smp_apic_timer_interrupt
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:                irq_enter
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:                   rcu_irq_enter
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:                      rcu_eqs_exit_common.isra.45
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:                   tick_check_idle
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:                      tick_check_oneshot_broadcast
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:                      ktime_get
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:                      tick_nohz_stop_idle
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:                         update_ts_time_stats
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:                            nr_iowait_cpu
          &lt;idle&gt;-0     [001] 15618.723291: <span style="color: #00ffff;">function</span>:             touch_softlockup_watchdog
          &lt;idle&gt;-0     [001] 15618.723291: <span style="color: #00ffff;">function</span>:                      tick_do_update_jiffies64
          &lt;idle&gt;-0     [001] 15618.723291: <span style="color: #00ffff;">function</span>:                      touch_softlockup_watchdog
          &lt;idle&gt;-0     [001] 15618.723291: <span style="color: #00ffff;">function</span>:                   irqtime_account_irq
          &lt;idle&gt;-0     [001] 15618.723292: <span style="color: #00ffff;">function</span>:                      in_serving_softirq
          &lt;idle&gt;-0     [001] 15618.723292: <span style="color: #00ffff;">function</span>:                   add_preempt_count
          &lt;idle&gt;-0     [001] 15618.723292: <span style="color: #00ffff;">function</span>:             exit_idle
          &lt;idle&gt;-0     [001] 15618.723292: <span style="color: #00ffff;">function</span>:                atomic_notifier_call_chain
          &lt;idle&gt;-0     [001] 15618.723293: <span style="color: #00ffff;">function</span>:                   __atomic_notifier_call_chain
          &lt;idle&gt;-0     [001] 15618.723293: <span style="color: #00ffff;">function</span>:                      __rcu_read_lock


Notice how the functions are indented similar to the function_graph
tracer.  This is because trace-cmd can post process the trace data
with more complex algorithms than are acceptable to implement<span style="color: #00ffff;"> in</span> the
kernel. It uses the parent <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">to</span> follow which <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">is</span> called
by other functions and be able to deduce a call graph.

To disable the indentation, use the -O report option.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">trace-cmd report --cpu 1 -O indent=0</span>
<span style="color: #eedd82;">version</span> = 6
<span style="color: #eedd82;">cpus</span>=8
          &lt;idle&gt;-0     [001] 15618.723287: <span style="color: #00ffff;">function</span>:             ktime_get
          &lt;idle&gt;-0     [001] 15618.723288: <span style="color: #00ffff;">function</span>:             smp_apic_timer_interrupt
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:             irq_enter
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:             rcu_irq_enter
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:             rcu_eqs_exit_common.isra.45
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:             tick_check_idle
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:             tick_check_oneshot_broadcast
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:             ktime_get
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:             tick_nohz_stop_idle
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:             update_ts_time_stats
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:             nr_iowait_cpu
          &lt;idle&gt;-0     [001] 15618.723291: <span style="color: #00ffff;">function</span>:             touch_softlockup_watchdog
          &lt;idle&gt;-0     [001] 15618.723291: <span style="color: #00ffff;">function</span>:             tick_do_update_jiffies64
          &lt;idle&gt;-0     [001] 15618.723291: <span style="color: #00ffff;">function</span>:             touch_softlockup_watchdog


To add back the parent:

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">trace-cmd report --cpu 1 -O indent=0 -O parent=1</span>
<span style="color: #eedd82;">version</span> = 6
<span style="color: #eedd82;">cpus</span>=8
          &lt;idle&gt;-0     [001] 15618.723287: <span style="color: #00ffff;">function</span>:             ktime_get &lt;-- cpuidle_wrap_enter
          &lt;idle&gt;-0     [001] 15618.723288: <span style="color: #00ffff;">function</span>:             smp_apic_timer_interrupt &lt;-- apic_timer_interrupt
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:             irq_enter &lt;-- smp_apic_timer_interrupt
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:             rcu_irq_enter &lt;-- irq_enter
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:             rcu_eqs_exit_common.isra.45 &lt;-- rcu_irq_enter
          &lt;idle&gt;-0     [001] 15618.723289: <span style="color: #00ffff;">function</span>:             tick_check_idle &lt;-- irq_enter
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:             tick_check_oneshot_broadcast &lt;-- tick_check_idle
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:             ktime_get &lt;-- tick_check_idle
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:             tick_nohz_stop_idle &lt;-- tick_check_idle
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:             update_ts_time_stats &lt;-- tick_nohz_stop_idle
          &lt;idle&gt;-0     [001] 15618.723290: <span style="color: #00ffff;">function</span>:             nr_iowait_cpu &lt;-- update_ts_time_stats
          &lt;idle&gt;-0     [001] 15618.723291: <span style="color: #00ffff;">function</span>:             touch_softlockup_watchdog &lt;-- sched_clock_idle_wakeup_event
          &lt;idle&gt;-0     [001] 15618.723291: <span style="color: #00ffff;">function</span>:             tick_do_update_jiffies64 &lt;-- tick_check_idle
          &lt;idle&gt;-0     [001] 15618.723291: <span style="color: #00ffff;">function</span>:             touch_softlockup_watchdog &lt;-- tick_check_idle
          &lt;idle&gt;-0     [001] 15618.723291: <span style="color: #00ffff;">function</span>:             irqtime_account_irq &lt;-- irq_enter
          &lt;idle&gt;-0     [001] 15618.723292: <span style="color: #00ffff;">function</span>:             in_serving_softirq &lt;-- irqtime_account_irq
          &lt;idle&gt;-0     [001] 15618.723292: <span style="color: #00ffff;">function</span>:             add_preempt_count &lt;-- irq_enter
          &lt;idle&gt;-0     [001] 15618.723292: <span style="color: #00ffff;">function</span>:             exit_idle &lt;-- smp_apic_timer_interrupt
          &lt;idle&gt;-0     [001] 15618.723292: <span style="color: #00ffff;">function</span>:             atomic_notifier_call_chain &lt;-- exit_idle
          &lt;idle&gt;-0     [001] 15618.723293: <span style="color: #00ffff;">function</span>:             __atomic_notifier_call_chain &lt;-- atomic_notifier_call_chain


Now the trace looks similar to the debug file system output.



Use the <span style="color: #ffa07a;">"-e"</span> option to record events:

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">trace-cmd record -e sched_switch</span>
/sys/kernel/debug/tracing/events/sched_switch/filter
/sys/kernel/debug/tracing/events/*/sched_switch/filter
Hit Ctrl^C to stop recording
(^C)
[...]

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">trace-cmd report</span>
<span style="color: #eedd82;">version</span> = 6
<span style="color: #eedd82;">cpus</span>=8
          &lt;idle&gt;-0     [006] 21642.751755: sched_switch:         swapper/6:0 [120] <span style="color: #eedd82;">R</span> ==&gt; trace-cmd:4876 [120]
          &lt;idle&gt;-0     [002] 21642.751776: sched_switch:         swapper/2:0 [120] <span style="color: #eedd82;">R</span> ==&gt; sshd:1208 [120]
       trace-cmd-4875  [005] 21642.751782: sched_switch:         trace-cmd:4875 [120] <span style="color: #eedd82;">D</span> ==&gt; swapper/5:0 [120]
       trace-cmd-4869  [001] 21642.751792: sched_switch:         trace-cmd:4869 [120] <span style="color: #eedd82;">S</span> ==&gt; swapper/1:0 [120]
       trace-cmd-4873  [003] 21642.751819: sched_switch:         trace-cmd:4873 [120] <span style="color: #eedd82;">S</span> ==&gt; swapper/3:0 [120]
          &lt;idle&gt;-0     [005] 21642.751835: sched_switch:         swapper/5:0 [120] <span style="color: #eedd82;">R</span> ==&gt; trace-cmd:4875 [120]
       trace-cmd-4877  [007] 21642.751847: sched_switch:         trace-cmd:4877 [120] <span style="color: #eedd82;">D</span> ==&gt; swapper/7:0 [120]
            sshd-1208  [002] 21642.751875: sched_switch:         sshd:1208 [120] <span style="color: #eedd82;">S</span> ==&gt; swapper/2:0 [120]
          &lt;idle&gt;-0     [007] 21642.751880: sched_switch:         swapper/7:0 [120] <span style="color: #eedd82;">R</span> ==&gt; trace-cmd:4877 [120]
       trace-cmd-4874  [004] 21642.751885: sched_switch:         trace-cmd:4874 [120] <span style="color: #eedd82;">S</span> ==&gt; swapper/4:0 [120]
          &lt;idle&gt;-0     [001] 21642.751902: sched_switch:         swapper/1:0 [120] <span style="color: #eedd82;">R</span> ==&gt; irq/43-em1:865 [49]
       trace-cmd-4876  [006] 21642.751903: sched_switch:         trace-cmd:4876 [120] <span style="color: #eedd82;">D</span> ==&gt; swapper/6:0 [120]
          &lt;idle&gt;-0     [006] 21642.751926: sched_switch:         swapper/6:0 [120] <span style="color: #eedd82;">R</span> ==&gt; trace-cmd:4876 [120]
      irq/43-em1-865   [001] 21642.751927: sched_switch:         irq/43-em1:865 [49] <span style="color: #eedd82;">S</span> ==&gt; swapper/1:0 [120]
       trace-cmd-4875  [005] 21642.752029: sched_switch:         trace-cmd:4875 [120] <span style="color: #eedd82;">S</span> ==&gt; swapper/5:0 [120]


Notice that only the <span style="color: #ffa07a;">"sched_switch"</span> name was used. trace-cmd will
search for a match of <span style="color: #ffa07a;">"-e"'s option for trace event systems, or single</span>
<span style="color: #ffa07a;">trace events themselves. To trace all interrupt events:</span>

<span style="color: #ffa07a;">&gt;# trace-cmd record -e irq sleep 10</span>
<span style="color: #ffa07a;">/sys/kernel/debug/tracing/events/irq/filter</span>
<span style="color: #ffa07a;">/sys/kernel/debug/tracing/events/*/irq/filter</span>
<span style="color: #ffa07a;">[...]</span>

<span style="color: #ffa07a;">Notice that when a command is passed to trace-cmd, it will just run that</span>
<span style="color: #ffa07a;">command and exit the trace when complete.</span>

<span style="color: #ffa07a;">&gt;# trace-cmd report</span>
<span style="color: #ffa07a;">version = 6</span>
<span style="color: #ffa07a;">cpus=8</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [002] 21767.342089: softirq_raise:        vec=9 [action=RCU]</span>
<span style="color: #ffa07a;">           sleep-4917  [007] 21767.342089: softirq_raise:        vec=9 [action=RCU]</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [006] 21767.342089: softirq_raise:        vec=9 [action=RCU]</span>
<span style="color: #ffa07a;">     ksoftirqd/0-3     [000] 21767.342096: softirq_entry:        vec=1 [action=TIMER]</span>
<span style="color: #ffa07a;">     ksoftirqd/4-33    [004] 21767.342096: softirq_entry:        vec=1 [action=TIMER]</span>
<span style="color: #ffa07a;">     ksoftirqd/3-27    [003] 21767.342097: softirq_entry:        vec=1 [action=TIMER]</span>
<span style="color: #ffa07a;">     ksoftirqd/7-51    [007] 21767.342097: softirq_entry:        vec=1 [action=TIMER]</span>
<span style="color: #ffa07a;">     ksoftirqd/4-33    [004] 21767.342097: softirq_exit:         vec=1 [action=TIMER]</span>



<span style="color: #ffa07a;">To get the status information of events similar to what the debug</span>
<span style="color: #ffa07a;">file system provides, add the "-l" (think "latency") option to the report.</span>


<span style="color: #ffa07a;">&gt;# trace-cmd report -l</span>
<span style="color: #ffa07a;">version = 6</span>
<span style="color: #ffa07a;">cpus=8</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       3d.h20 21767.341545: softirq_raise:        vec=8 [action=HRTIMER]</span>
<span style="color: #ffa07a;">ksoftirq-27      3...11 21767.341552: softirq_entry:        vec=8 [action=HRTIMER]</span>
<span style="color: #ffa07a;">ksoftirq-27      3...11 21767.341554: softirq_exit:         vec=8 [action=HRTIMER]</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       4d.h20 21767.342085: softirq_raise:        vec=7 [action=SCHED]</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       0d.h20 21767.342086: softirq_raise:        vec=7 [action=SCHED]</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       3d.h20 21767.342086: softirq_raise:        vec=7 [action=SCHED]</span>
<span style="color: #ffa07a;">   sleep-4917    7d.h10 21767.342086: softirq_raise:        vec=7 [action=SCHED]</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       6d.h20 21767.342087: softirq_raise:        vec=7 [action=SCHED]</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       2d.h20 21767.342087: softirq_raise:        vec=1 [action=TIMER]</span>
<span style="color: #ffa07a;">  &lt;idle&gt;-0       1d.h20 21767.342087: softirq_raise:        vec=1 [action=TIMER]</span>



<span style="color: #ffa07a;">Tracing all events</span>
<span style="color: #ffa07a;">------------------</span>

<span style="color: #ffa07a;">As mentioned above, the "-e" option to trace-cmd record is to choose</span>
<span style="color: #ffa07a;">what event should be traced. You can specify either an individual event,</span>
<span style="color: #ffa07a;">or a trace system:</span>

<span style="color: #ffa07a;">&gt;# trace-cmd record -e irq</span>

<span style="color: #ffa07a;">The above enables all tracepoints within the "irq" system.</span>

<span style="color: #ffa07a;">&gt;# trace-cmd record -e irq_handler_enter</span>
<span style="color: #ffa07a;">&gt;# trace-cmd record -e irq:irq_handler_enter</span>

<span style="color: #ffa07a;">The commands above are equivalent and will enable the tracepoint</span>
<span style="color: #ffa07a;">event "irq_handler_enter".</span>

<span style="color: #ffa07a;">But then there is the case where you want to trace all events.</span>
<span style="color: #ffa07a;">To do this, use the keyword "all".</span>

<span style="color: #ffa07a;">&gt;# trace-cmd record -e all</span>

<span style="color: #ffa07a;">This will enable all events.</span>


<span style="color: #ffa07a;">Tracing tracers and events</span>
<span style="color: #ffa07a;">--------------------------</span>

<span style="color: #ffa07a;">As events can be enabled within any tracer, it makes sense that trace-cmd</span>
<span style="color: #ffa07a;">would allow this as well. This is indeed the case. You may use both</span>
<span style="color: #ffa07a;">the "-p" and the "-e" options at the same time.</span>

<span style="color: #ffa07a;">&gt;# trace-cmd record -p function_graph -e all</span>
<span style="color: #ffa07a;">[...]</span>
<span style="color: #ffa07a;">&gt;# trace-cmd report</span>
<span style="color: #ffa07a;">version = 6</span>
<span style="color: #ffa07a;">cpus=8</span>
<span style="color: #ffa07a;">       trace-cmd-1698  [002]  2724.485397: funcgraph_entry:                   |                  kmem_cache_alloc() {</span>
<span style="color: #ffa07a;">       trace-cmd-1699  [007]  2724.485397: funcgraph_entry:        0.073 us   |      find_vma();</span>
<span style="color: #ffa07a;">       trace-cmd-1696  [000]  2724.485397: funcgraph_entry:                   |          lg_local_lock() {</span>
<span style="color: #ffa07a;">       trace-cmd-1698  [002]  2724.485397: funcgraph_entry:        0.033 us   |                    add_preempt_count();</span>
<span style="color: #ffa07a;">       trace-cmd-1696  [000]  2724.485397: funcgraph_entry:                   |            migrate_disable() {</span>
<span style="color: #ffa07a;">       trace-cmd-1699  [007]  2724.485398: funcgraph_entry:                   |      handle_mm_fault() {</span>
<span style="color: #ffa07a;">       trace-cmd-1696  [000]  2724.485398: funcgraph_entry:        0.027 us   |              add_preempt_count();</span>
<span style="color: #ffa07a;">       trace-cmd-1698  [002]  2724.485398: funcgraph_entry:        0.034 us   |                    sub_preempt_count();</span>
<span style="color: #ffa07a;">       trace-cmd-1699  [007]  2724.485398: funcgraph_entry:                   |        __mem_cgroup_count_vm_event() {</span>
<span style="color: #ffa07a;">       trace-cmd-1696  [000]  2724.485398: funcgraph_entry:        0.031 us   |              pin_current_cpu();</span>
<span style="color: #ffa07a;">       trace-cmd-1699  [007]  2724.485398: funcgraph_entry:        0.029 us   |          __rcu_read_lock();</span>
<span style="color: #ffa07a;">       trace-cmd-1698  [002]  2724.485398: kmem_cache_alloc:     (return_to_handler+0x0) call_site=ffffffff81662345 ptr=0xffff880114e260f0 bytes_req=240 bytes_alloc=240 gfp_flags=G</span>
<span style="color: #ffa07a;">FP_KERNEL</span>
<span style="color: #ffa07a;">       trace-cmd-1696  [000]  2724.485398: funcgraph_entry:        0.034 us   |              sub_preempt_count();</span>
<span style="color: #ffa07a;">       trace-cmd-1699  [007]  2724.485398: funcgraph_entry:        0.028 us   |          __rcu_read_unlock();</span>
<span style="color: #ffa07a;">       trace-cmd-1698  [002]  2724.485398: funcgraph_exit:         0.758 us   |                  }</span>
<span style="color: #ffa07a;">       trace-cmd-1698  [002]  2724.485398: funcgraph_entry:        0.029 us   |                  __rt_mutex_init();</span>
<span style="color: #ffa07a;">       trace-cmd-1696  [000]  2724.485398: funcgraph_exit:         0.727 us   |            }</span>
<span style="color: #ffa07a;">       trace-cmd-1699  [007]  2724.485398: funcgraph_exit:         0.466 us   |        }</span>

<span style="color: #ffa07a;">Notice here that trace-cmd report does not disply the function graph</span>
<span style="color: #ffa07a;">tracer any different than any other trace, like the "trace" file does.</span>


<span style="color: #ffa07a;">Function filtering</span>
<span style="color: #ffa07a;">------------------</span>

<span style="color: #ffa07a;">The "set_ftrace_filter" and "set_ftrace_notrace" is very useful in</span>
<span style="color: #ffa07a;">filtering out functions that you do not care about. These can be done</span>
<span style="color: #ffa07a;">with trace-cmd as well.</span>

<span style="color: #ffa07a;">The "-l" and "-n" are used the same as "set_ftrace_filter" and</span>
<span style="color: #ffa07a;">"set_ftrace_notrace" respectively. Think of "limit functions" for</span>
<span style="color: #ffa07a;">"-l" as the "-f" is used for event filtering.</span>

<span style="color: #ffa07a;">To add more than one function to the list, either used the glob expressions</span>
<span style="color: #ffa07a;">described previously, or use multiple "-l" or "-n" options.</span>

<span style="color: #ffa07a;">&gt;# trace-cmd record -p function -l "sched*" -n "*stat*"</span>

<span style="color: #ffa07a;">The above traces all functions that start with "sched" except those that</span>
<span style="color: #ffa07a;">have "stat" in their names.</span>



<span style="color: #ffa07a;">Event filtering</span>
<span style="color: #ffa07a;">---------------</span>

<span style="color: #ffa07a;">To filter events the same way as writing to the "filter" file inside</span>
<span style="color: #ffa07a;">the "events" directory (see "Filtering events" above), use the "-f"</span>
<span style="color: #ffa07a;">option. This option must follow the event that it will filter.</span>

<span style="color: #ffa07a;">&gt;# trace-cmd record -e sched_switch -f "prev_prio &lt; 100" \</span>
<span style="color: #ffa07a;">   -e sched_wakeup -f '</span><span style="color: #eedd82;">comm</span> == <span style="color: #ffa07a;">"bash"'</span>


<span style="color: #ffa07a;">Graph a function</span>
<span style="color: #ffa07a;">----------------</span>

<span style="color: #ffa07a;">To perform a graph of a specific function using "function_graph" tracer,</span>
<span style="color: #ffa07a;">trace-cmd provides the "-g" option.</span>

<span style="color: #ffa07a;">&gt;# trace-cmd record -p function_graph -g sys_read ls /</span>
<span style="color: #ffa07a;">[...]</span>
<span style="color: #ffa07a;">&gt;# trace-cmd report</span>
<span style="color: #ffa07a;">version = 6</span>
<span style="color: #ffa07a;">CPU 3 is empty</span>
<span style="color: #ffa07a;">CPU 4 is empty</span>
<span style="color: #ffa07a;">CPU 5 is empty</span>
<span style="color: #ffa07a;">cpus=8</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643252: funcgraph_entry:                   |  sys_read() {</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643253: funcgraph_entry:        0.147 us   |    fget_light();</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643254: funcgraph_entry:                   |    vfs_read() {</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643254: funcgraph_entry:                   |      rw_verify_area() {</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643255: funcgraph_entry:                   |        security_file_permission() {</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643255: funcgraph_entry:        0.068 us   |          cap_file_permission();</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643256: funcgraph_entry:        0.064 us   |          __fsnotify_parent();</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643256: funcgraph_entry:        0.095 us   |          fsnotify();</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643257: funcgraph_exit:         1.792 us   |        }</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643257: funcgraph_exit:         2.328 us   |      }</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643257: funcgraph_entry:                   |      seq_read() {</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643257: funcgraph_entry:                   |        _mutex_lock() {</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643258: funcgraph_entry:        0.062 us   |          rt_mutex_lock();</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643258: funcgraph_exit:         0.584 us   |        }</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643259: funcgraph_entry:                   |        m_start() {</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643259: funcgraph_entry:                   |          rt_down_read() {</span>
<span style="color: #ffa07a;">       trace-cmd-2183  [006]  4689.643259: funcgraph_entry:                   |            rt_mutex_lock() {</span>


<span style="color: #ffa07a;">Modify trace buffer size via trace-cmd</span>
<span style="color: #ffa07a;">--------------------------------------</span>

<span style="color: #ffa07a;">The trace-cmd record "-b" option lets you change the size of the</span>
<span style="color: #ffa07a;">ftrace buffer before recording the trace. Note, currently trace-cmd</span>
<span style="color: #ffa07a;">does not support per-cpu resize. The size is what is entered into</span>
<span style="color: #ffa07a;">"buffer_size_kb" at the top level.</span>


<span style="color: #ffa07a;">&gt;# trace-cmd record -b 10000 -p function</span>


<span style="color: #ffa07a;">trace-cmd start, stop and extract</span>
<span style="color: #ffa07a;">---------------------------------</span>

<span style="color: #ffa07a;">The trace-cmd start command takes almost all the options as the trace-cmd</span>
<span style="color: #ffa07a;">record command does. The difference between the two is that "start"</span>
<span style="color: #ffa07a;">will only enable ftrace, it will not do any recording. It is equivalent</span>
<span style="color: #ffa07a;">to enabling ftrace via the debug file system.</span>

<span style="color: #ffa07a;">&gt;# trace-cmd start -p function -e all</span>
<span style="color: #ffa07a;">&gt;# cat /sys/kernel/debug/tracing/trace</span>
<span style="color: #ffa07a;"># tracer: function</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;"># entries-in-buffer/entries-written: 1544167/2039168   #P:8</span>
<span style="color: #ffa07a;">#</span>
<span style="color: #ffa07a;">#                              _-------=&gt; irqs-off          </span>
<span style="color: #ffa07a;">#                            /  _------=&gt; need-resched      </span>
<span style="color: #ffa07a;">#                            |/  _-----=&gt; need-resched_lazy </span>
<span style="color: #ffa07a;">#                            ||/  _----=&gt; hardirq/softirq   </span>
<span style="color: #ffa07a;">#                            |||/  _---=&gt; preempt-depth     </span>
<span style="color: #ffa07a;">#                            ||||/  _--=&gt; preempt-lazy-depth</span>
<span style="color: #ffa07a;">#                            ||||| / _-=&gt; migrate-disable   </span>
<span style="color: #ffa07a;">#                            |||||| /     delay</span>
<span style="color: #ffa07a;">#           TASK-PID   CPU#  |||||||    TIMESTAMP  FUNCTION</span>
<span style="color: #ffa07a;">#              | |       |   |||||||       |         |</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816132: _mutex_unlock &lt;-rb_simple_write</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816133: rt_mutex_unlock &lt;-_mutex_unlock</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816134: __fsnotify_parent &lt;-vfs_write</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816134: fsnotify &lt;-vfs_write</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816135: __srcu_read_lock &lt;-fsnotify</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816135: add_preempt_count &lt;-__srcu_read_lock</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] ....1..  5946.816135: sub_preempt_count &lt;-__srcu_read_lock</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816135: __srcu_read_unlock &lt;-fsnotify</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816136: add_preempt_count &lt;-__srcu_read_unlock</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] ....1..  5946.816136: sub_preempt_count &lt;-__srcu_read_unlock</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816137: syscall_trace_leave &lt;-int_check_syscall_exit_work</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816137: __audit_syscall_exit &lt;-syscall_trace_leave</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816137: path_put &lt;-__audit_syscall_exit</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816137: dput &lt;-path_put</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816138: mntput &lt;-path_put</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816138: unroll_tree_refs &lt;-__audit_syscall_exit</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816138: kfree &lt;-__audit_syscall_exit</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] ....1..  5946.816139: kfree: call_site=ffffffff810eaff0 ptr=          (null)</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] ....1..  5946.816139: sys_exit: NR 1 = 1</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] d......  5946.816140: sys_write -&gt; 0x1</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] d......  5946.816151: do_page_fault &lt;-page_fault</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] d......  5946.816151: __do_page_fault &lt;-do_page_fault</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816152: rt_down_read_trylock &lt;-__do_page_fault</span>
<span style="color: #ffa07a;">       trace-cmd-2390  [003] .......  5946.816152: rt_mutex_trylock &lt;-rt_down_read_trylock</span>


<span style="color: #ffa07a;">Running trace-cmd stop is exactly the same as echoing "0" into the</span>
<span style="color: #ffa07a;">"tracing_on" file in the debug file system. This only stops writing to</span>
<span style="color: #ffa07a;">the trace buffers, it does not stop all the tracing mechanisms inside</span>
<span style="color: #ffa07a;">the kernel and still adds some overhead to the system.</span>

<span style="color: #ffa07a;">&gt;# cat /sys/kernel/debug/tracing/tracing_on</span>
<span style="color: #ffa07a;">1</span>
<span style="color: #ffa07a;">&gt;# trace-cmd stop</span>
<span style="color: #ffa07a;">&gt;# cat /sys/kernel/debug/tracing/tracing_on</span>
<span style="color: #ffa07a;">0</span>


<span style="color: #ffa07a;">Finally, if you want to create a "trace.dat" file from the ftrace</span>
<span style="color: #ffa07a;">kernel buffers you use the "extract" command. The tracing could</span>
<span style="color: #ffa07a;">have started with the "start" command or by manually modifying the</span>
<span style="color: #ffa07a;">ftrace debug file system files. This is useful if you found a trace</span>
<span style="color: #ffa07a;">and want to save it off where you can send it to other people, and</span>
<span style="color: #ffa07a;">also have the full features of the trace-cmd "report" command.</span>

<span style="color: #ffa07a;">&gt;# trace-cmd extract</span>
<span style="color: #ffa07a;">&gt;# trace-cmd report</span>
<span style="color: #ffa07a;">version = 6</span>
<span style="color: #ffa07a;">cpus=8</span>
<span style="color: #ffa07a;">CPU:6 [2544372 EVENTS DROPPED]</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717580: function:             rcu_note_context_switch</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717580: rcu_utilization:      ffffffff819e743b</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717580: rcu_utilization:      ffffffff819e7450</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717581: function:             add_preempt_count</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717581: function:             kthread_should_stop</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717581: function:             kthread_should_park</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717581: function:             ksoftirqd_should_run</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717582: function:             sub_preempt_count</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717582: function:             schedule</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717582: function:                __schedule</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717582: function:                   add_preempt_count</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717582: function:                   rcu_note_context_switch</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717583: rcu_utilization:      ffffffff819e743b</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717583: rcu_utilization:      ffffffff819e7450</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717583: function:                   _raw_spin_lock_irq</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717583: function:                      add_preempt_count</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717584: function:                   deactivate_task</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717584: function:                      dequeue_task</span>
<span style="color: #ffa07a;">     ksoftirqd/6-45    [006]  6192.717584: function:                         update_rq_clock</span>


<span style="color: #ffa07a;">The "extract" command takes a "-o" option to save the trace in a different</span>
<span style="color: #ffa07a;">name like the "record" command does. By default it just saves it into</span>
<span style="color: #ffa07a;">a file called "trace.dat".</span>


<span style="color: #ffa07a;">Resetting the trace</span>
<span style="color: #ffa07a;">-------------------</span>

<span style="color: #ffa07a;">As mentioned, the "stop" command does not lower the overhead of ftrace.</span>
<span style="color: #ffa07a;">It simply disables writing to the ftrace buffer. There'</span>s two ways of
resetting ftrace with trace-cmd.

The first way is with the <span style="color: #ffa07a;">"reset"</span> command.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">trace-cmd reset</span>

This disables practically everything<span style="color: #00ffff;"> in</span> ftrace. It also sets the
<span style="color: #ffa07a;">"tracing_on"</span> file to <span style="color: #ffa07a;">"0"</span>. It also erases everything inside the buffers,
so make sure to do your <span style="color: #ffa07a;">"extract"</span> before running the <span style="color: #ffa07a;">"reset"</span> command.

The <span style="color: #ffa07a;">"reset"</span> command also takes a <span style="color: #ffa07a;">"-b"</span> option that lets you resize the
buffer as well. This is useful to free the allocated buffers when you
are finished tracing.

&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">trace-cmd reset -b 0</span>
&gt;<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /sys/kernel/debug/tracing/buffer_total_size_kb</span>
8


The problem with the <span style="color: #ffa07a;">"reset"</span> command is that it may make it hard to
use the debug file system tracing files directly. It may disable various
parts of tracing that may give unexpected results when trying to use
the files directly. If you plan to use ftrace<span style="color: #ffa07a;">'s files directly after</span>
<span style="color: #ffa07a;">using trace-cmd, the trick is to start the "nop" tracer.</span>

<span style="color: #ffa07a;">&gt;# trace-cmd start -p nop</span>

<span style="color: #ffa07a;">This sets up ftrace to run the "nop" tracer, which does no tracing and</span>
<span style="color: #ffa07a;">has no overhead when enabled, and disables all events, and clears out</span>
<span style="color: #ffa07a;">the "trace" file. After running this command, the system should be</span>
<span style="color: #ffa07a;">set up to use the ftrace files directly as they are expected.</span>



<span style="color: #ffa07a;">Using trace-cmd over the network</span>
<span style="color: #ffa07a;">--------------------------------</span>

<span style="color: #ffa07a;">If the target system to trace is limited on disk space, or perhaps</span>
<span style="color: #ffa07a;">the disk usage is what is being traced, it can be prudent to record</span>
<span style="color: #ffa07a;">the trace via another median than to the hard drive. The "listen"</span>
<span style="color: #ffa07a;">command sets up a way for trace-cmd to record over the network.</span>

<span style="color: #ffa07a;">[Server]</span>
<span style="color: #ffa07a;">&gt;$ mkdir traces</span>
<span style="color: #ffa07a;">&gt;$ cd traces</span>
<span style="color: #ffa07a;">&gt;$ trace-cmd listen -p 55577</span>


<span style="color: #ffa07a;">Notice that the prompt above is "$". This denotes that the listen command</span>
<span style="color: #ffa07a;">does not need to be root if the listening port is not a privileged port.</span>

<span style="color: #ffa07a;">[Target]</span>
<span style="color: #ffa07a;">&gt;# trace-cmd record -e all -N Server:55577 ls /</span>


<span style="color: #ffa07a;">[Server]</span>
<span style="color: #ffa07a;">connected!</span>
<span style="color: #ffa07a;">Connected with Target:50671</span>
<span style="color: #ffa07a;">cpus=8</span>
<span style="color: #ffa07a;">pagesize=4096</span>
<span style="color: #ffa07a;">version = 6</span>
<span style="color: #ffa07a;">CPU0 data recorded at offset=0x3a7000</span>
<span style="color: #ffa07a;">    0 bytes in size</span>
<span style="color: #ffa07a;">CPU1 data recorded at offset=0x3a7000</span>
<span style="color: #ffa07a;">    8192 bytes in size</span>
<span style="color: #ffa07a;">CPU2 data recorded at offset=0x3a9000</span>
<span style="color: #ffa07a;">    8192 bytes in size</span>
<span style="color: #ffa07a;">CPU3 data recorded at offset=0x3ab000</span>
<span style="color: #ffa07a;">    8192 bytes in size</span>
<span style="color: #ffa07a;">CPU4 data recorded at offset=0x3ad000</span>
<span style="color: #ffa07a;">    8192 bytes in size</span>
<span style="color: #ffa07a;">CPU5 data recorded at offset=0x3af000</span>
<span style="color: #ffa07a;">    8192 bytes in size</span>
<span style="color: #ffa07a;">CPU6 data recorded at offset=0x3b1000</span>
<span style="color: #ffa07a;">    4096 bytes in size</span>
<span style="color: #ffa07a;">CPU7 data recorded at offset=0x3b2000</span>
<span style="color: #ffa07a;">    8192 bytes in size</span>
<span style="color: #ffa07a;">connected!</span>
<span style="color: #ffa07a;">(^C)</span>

<span style="color: #ffa07a;">&gt;$ ls</span>
<span style="color: #ffa07a;">trace.Target:50671.dat</span>
<span style="color: #ffa07a;">&gt;$ trace-cmd report trace.Target:50671.dat</span>
<span style="color: #ffa07a;">version = 6</span>
<span style="color: #ffa07a;">CPU 0 is empty</span>
<span style="color: #ffa07a;">cpus=8</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266143: mm_page_alloc:        page=0xffffea00007e8740 pfn=8292160 order=0 migratetype=0 gfp_flags=GFP_KERNEL|GFP_REPEAT|GFP_ZERO|GFP_NOTRACK</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266145: kmalloc:              (pte_lock_init+0x2c) call_site=ffffffff8116d78c ptr=0xffff880111e40d00 bytes_req=48 bytes_alloc=64 gfp_flags=GFP_KERNEL</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266152: mm_page_alloc:        page=0xffffea00034a50c0 pfn=55201984 order=0 migratetype=0 gfp_flags=GFP_KERNEL|GFP_REPEAT|GFP_ZERO|GFP_NOTRACK</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266153: kmalloc:              (pte_lock_init+0x2c) call_site=ffffffff8116d78c ptr=0xffff880111e40e40 bytes_req=48 bytes_alloc=64 gfp_flags=GFP_KERNEL</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266155: mm_page_alloc:        page=0xffffea000307d380 pfn=50844544 order=0 migratetype=2 gfp_flags=GFP_HIGHUSER_MOVABLE</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266167: mm_page_alloc:        page=0xffffea000323f900 pfn=52689152 order=0 migratetype=2 gfp_flags=GFP_HIGHUSER_MOVABLE</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266171: mm_page_alloc:        page=0xffffea00032cda80 pfn=53271168 order=0 migratetype=2 gfp_flags=GFP_HIGHUSER_MOVABLE</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266192: hrtimer_cancel:       hrtimer=0xffff88011ebccf40</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [006]  8865.266193: hrtimer_cancel:       hrtimer=0xffff88011eb8cf40</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266193: hrtimer_expire_entry: hrtimer=0xffff88011ebccf40 now=8905356001470 function=tick_sched_timer/0x0</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [006]  8865.266194: hrtimer_expire_entry: hrtimer=0xffff88011eb8cf40 now=8905356002620 function=tick_sched_timer/0x0</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266196: sched_stat_runtime:   comm=trace-cmd pid=2976 runtime=228684 [ns] vruntime=2941412131 [ns]</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [006]  8865.266197: softirq_raise:        vec=1 [action=TIMER]</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [006]  8865.266197: rcu_utilization:      ffffffff819e740d</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266198: softirq_raise:        vec=1 [action=TIMER]</span>
<span style="color: #ffa07a;">          &lt;idle&gt;-0     [006]  8865.266198: softirq_raise:        vec=9 [action=RCU]</span>
<span style="color: #ffa07a;">           &lt;...&gt;-2976  [007]  8865.266199: rcu_utilization:      ffffffff819e740d</span>


<span style="color: #ffa07a;">By default, the data is transfered via UDP. This is very efficient but</span>
<span style="color: #ffa07a;">it is possible to lose data and not know it. If you are worried about</span>
<span style="color: #ffa07a;">a full connection, then use the TCP protocol. The "-t" option</span>
<span style="color: #ffa07a;">on the "record" command forces trace-cmd to send the data over a TCP</span>
<span style="color: #ffa07a;">connection instead of a UDP one.</span>


<span style="color: #ffa07a;">Summary</span>
<span style="color: #ffa07a;">-------</span>

<span style="color: #ffa07a;">This document just highlighted the most common features of ftrace and</span>
<span style="color: #ffa07a;">trace-cmd. For more in depth look at what trace-cmd can do, read</span>
<span style="color: #ffa07a;">the man pages:</span>

<span style="color: #ffa07a;">  trace-cmd</span>
<span style="color: #ffa07a;">  trace-cmd-record</span>
<span style="color: #ffa07a;">  trace-cmd-report</span>
<span style="color: #ffa07a;">  trace-cmd-start</span>
<span style="color: #ffa07a;">  trace-cmd-stop</span>
<span style="color: #ffa07a;">  trace-cmd-extract</span>
<span style="color: #ffa07a;">  trace-cmd-reset</span>
<span style="color: #ffa07a;">  trace-cmd-listen</span>
<span style="color: #ffa07a;">  trace-cmd-split</span>
<span style="color: #ffa07a;">  trace-cmd-restore</span>
<span style="color: #ffa07a;">  trace-cmd-list</span>
<span style="color: #ffa07a;">  trace-cmd-stack</span>
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2016-01-28 Thu 21:51</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
