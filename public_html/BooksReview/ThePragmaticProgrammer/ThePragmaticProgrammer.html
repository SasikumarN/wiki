<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>The Pragmatic Programmer: From Journeyman to Master</title>
<!-- 2017-06-16 Fri 22:42 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">The Pragmatic Programmer: From Journeyman to Master</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Overview</a></li>
<li><a href="#sec-2">Pragmatic Software Development Tips</a>
<ul>
<li><a href="#sec-2-1">Languages To Learn</a></li>
<li><a href="#sec-2-2">The WISDOM Acrostic</a></li>
<li><a href="#sec-2-3">How to Maintain Orthogonality</a></li>
<li><a href="#sec-2-4">Things to prototype</a></li>
<li><a href="#sec-2-5">Architectural Questions</a></li>
<li><a href="#sec-2-6">Debugging Checklist</a></li>
<li><a href="#sec-2-7">Law of Demeter for Functions</a></li>
<li><a href="#sec-2-8">How to Program Deliberately</a></li>
<li><a href="#sec-2-9">When to Refactor</a></li>
<li><a href="#sec-2-10">Cutting the Gordian Knot</a></li>
<li><a href="#sec-2-11">Aspects of Testing</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Overview</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>homepage: <a href="https://pragprog.com/book/tpp/the-pragmatic-programmer">https://pragprog.com/book/tpp/the-pragmatic-programmer</a>
</li>
<li><a href="./tpp-code.tgz">Source Code</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Pragmatic Software Development Tips</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li><b>Care About Your Craft</b>

<p>
Why spend your life developing software unless you care about doing
it well?
</p>
</li>
<li><b>Provide Options, Don’t Make Lame Excuses</b>

<p>
Instead of excuses, provide options. Don’t say it can’t be done;
explain what can be done.
</p>
</li>
<li><b>Be a Catalyst for Change</b>

<p>
You can’t force change on people. Instead, show them how the future
might be and help them participate in creating it.
</p>
</li>
<li><b>Make Quality a Requirements Issue</b>

<p>
Involve your users in determining the project’s real quality
requirements.
</p>
</li>
<li><b>Critically Analyze What You Read and Hear</b>

<p>
Don’t be swayed by vendors, media hype, or dogma. Analyze
information in terms of you and your project.
</p>
</li>
<li><b>DRY—Don’t Repeat Yourself</b>

<p>
Every piece of knowledge must have a single, unambiguous,
authoritative representation within a system.
</p>
</li>
<li><b>Eliminate Effects Between Unrelated Things</b>

<p>
Design components that are self-contained, independent, and have a
single, well-defined purpose.
</p>
</li>
<li><b>Use Tracer Bullets to Find the Target</b>

<p>
Tracer bullets let you home in on your target by trying things and
seeing how close they land.
</p>
</li>
<li><b>Program Close to the Problem Domain</b>

<p>
Design and code in your user’s language.
</p>
</li>
<li><b>Iterate the Schedule with the Code</b>

<p>
Use experience you gain as you implement to refine the project time
scales.
</p>
</li>
<li><b>Use the Power of Command Shells</b>

<p>
Use the shell when graphical user interfaces don’t cut it.
</p>
</li>
<li><b>Always Use Source Code Control</b>

<p>
Source code control is a time machine for your work—you can go back.
</p>
</li>
<li><b>Don’t Panic When Debugging</b>

<p>
Take a deep breath and THINK! about what could be causing the bug.
</p>
</li>
<li><b>Don’t Assume It—Prove It</b>

<p>
Prove your assumptions in the actual environment—with real data and
boundary conditions.
</p>
</li>
<li><b>Write Code That Writes Code</b>

<p>
Code generators increase your productivity and help avoid
duplication.
</p>
</li>
<li><b>Design with Contracts</b>

<p>
Use contracts to document and verify that code does no more and no
less than it claims to do.
</p>
</li>
<li><b>Use Assertions to Prevent the Impossible</b>

<p>
Assertions validate your assumptions. Use them to protect your code
from an uncertain world.
</p>
</li>
<li><b>Finish What You Start</b>

<p>
Where possible, the routine or object that allocates a resource
should be responsible for deallocating it.
</p>
</li>
<li><b>Configure, Don’t Integrate</b>

<p>
Implement technology choices for an application as configuration
options, not through integration or engineering
</p>
</li>
<li><b>Analyze Workflow to Improve Concurrency</b>

<p>
Exploit concurrency in your user’s workflow.
</p>
</li>
<li><b>Always Design for Concurrency</b>

<p>
Allow for concurrency, and you’ll design cleaner interfaces with
fewer assumptions.
</p>
</li>
<li><b>Use Blackboards to Coordinate Workflow</b>

<p>
Use blackboards to coordinate disparate facts and agents, while
maintaining independence and isolation among participants.
</p>
</li>
<li><b>Estimate the Order of Your Algorithms</b>

<p>
Get a feel for how long things are likely to take before you write
code.
</p>
</li>
<li><b>Refactor Early, Refactor Often</b>

<p>
Just as you might weed and rearrange a garden, rewrite, rework, and
re-architect code when it needs it. Fix the root of the problem.
</p>
</li>
<li><b>Test Your Software, or Your Users Will</b>

<p>
Test ruthlessly. Don’t make your users find bugs for you.
</p>
</li>
<li><b>Don’t Gather Requirements—Dig for Them</b>

<p>
Requirements rarely lie on the surface. They’re buried deep beneath
layers of assumptions, misconceptions, and politics.
</p>
</li>
<li><b>Abstractions Live Longer than Details</b>

<p>
Invest in the abstraction, not the implementation. Abstractions can
survive the barrage of changes from different implementations and
new technologies.
</p>
</li>
<li><b>Don’t Think Outside the Box—Find the Box</b>

<p>
When faced with an impossible problem, identify the real
constraints. Ask yourself: “Does it have to be done this way? Does
it have to be done at all?”
</p>
</li>
<li><b>Some Things Are Better Done than Described</b>

<p>
Don’t fall into the specification spiral—at some point you need to
start coding.
</p>
</li>
<li><b>Costly Tools Don’t Produce Better Designs</b>

<p>
Beware of vendor hype, industry dogma, and the aura of the price
tag. Judge tools on their merits.
</p>
</li>
<li><b>Don’t Use Manual Procedures</b>

<p>
A shell script or batch file will execute the same instructions, in
the same order, time after time.
</p>
</li>
<li><b>Coding Ain’t Done ‘Til All the Tests Run</b>

<p>
‘Nuff said.
</p>
</li>
<li><b>Test State Coverage, Not Code Coverage</b>

<p>
Identify and test significant program states. Just testing lines of
code isn’t enough.
</p>
</li>
<li><b>English is Just a Programming Language</b>

<p>
Write documents as you would write code: honor the DRY principle,
use metadata, MVC, automatic generation, and so on.
</p>
</li>
<li><b>Gently Exceed Your Users’ Expectations</b>

<p>
Come to understand your users’ expectations, then deliver just that
little bit more.
</p>
</li>
<li><b>Think! About Your Work</b>

<p>
Turn off the autopilot and take control. Constantly critique and
appraise your work.
</p>
</li>
<li><b>Don’t Live with Broken Windows</b>

<p>
Fix bad designs, wrong decisions, and poor code when you see them.
</p>
</li>
<li><b>Remember the Big Picture</b>

<p>
Don’t get so engrossed in the details that you forget to check
what’s happening around you.
</p>
</li>
<li><b>Invest Regularly in Your Knowledge Portfolio</b>

<p>
Make learning a habit.
</p>
</li>
<li><b>It’s Both What You Say and the Way You Say It</b>

<p>
There’s no point in having great ideas if you don’t communicate
them effectively.
</p>
</li>
<li><b>Make It Easy to Reuse</b>

<p>
If it’s easy to reuse, people will. Create an environment that
supports reuse.
</p>
</li>
<li><b>There Are No Final Decisions</b>

<p>
No decision is cast in stone. Instead, consider each as being
written in the sand at the beach, and plan for change.
</p>
</li>
<li><b>Prototype to Learn</b>

<p>
Prototyping is a learning experience. Its value lies not in the code
you produce, but in the lessons you learn.
</p>
</li>
<li><b>Estimate to Avoid Surprises</b>

<p>
Estimate before you start. You’ll spot potential problems up front.
</p>
</li>
<li><b>Keep Knowledge in Plain Text</b>

<p>
Plain text won’t become obsolete. It helps leverage your work and
simplifies debugging and testing.
</p>
</li>
<li><b>Use a Single Editor Well</b>

<p>
The editor should be an extension of your hand; make sure your
editor is configurable, extensible, and programmable.
</p>
</li>
<li><b>Fix the Problem, Not the Blame</b>

<p>
It doesn’t really matter whether the bug is your fault or someone
else’s—it is still your problem, and it still needs to be fixed.
</p>
</li>
<li><b>“select” Isn’t Broken</b>

<p>
It is rare to find a bug in the OS or the compiler, or even a
third-party product or library. The bug is most likely in the
application.
</p>
</li>
<li><b>Learn a Text Manipulation Language</b>

<p>
You spend a large part of each day working with text. Why not have
the computer do some of it for you?
</p>
</li>
<li><b>You Can’t Write Perfect Software</b>

<p>
Software can’t be perfect. Protect your code and users from the
inevitable errors.
</p>
</li>
<li><b>Crash Early</b>

<p>
A dead program normally does a lot less damage than a crippled one.
</p>
</li>
<li><b>Use Exceptions for Exceptional Problems</b>

<p>
Exceptions can suffer from all the readability and maintainability
problems of classic spaghetti code. Reserve exceptions for
exceptional things.
</p>
</li>
<li><b>Minimize Coupling Between Modules</b>

<p>
Avoid coupling by writing “shy” code and applying the Law of
Demeter.
</p>
</li>
<li><b>Put Abstractions in Code, Details in Metadata</b>

<p>
Program for the general case, and put the specifics outside the
compiled code base.
</p>
</li>
<li><b>Design Using Services</b>

<p>
Design in terms of services—independent, concurrent objects behind
well-defined, consistent interfaces.
</p>
</li>
<li><b>Separate Views from Models</b>

<p>
Gain flexibility at low cost by designing your application in terms
of models and views.
</p>
</li>
<li><b>Don’t Program by Coincidence</b>

<p>
Rely only on reliable things. Beware of accidental complexity, and
don’t confuse a happy coincidence with a purposeful plan.
</p>
</li>
<li><b>Test Your Estimates</b>

<p>
Mathematical analysis of algorithms doesn’t tell you everything.
Try timing your code in its target environment.
</p>
</li>
<li><b>Design to Test</b>

<p>
Start thinking about testing before you write a line of code.
</p>
</li>
<li><b>Don’t Use Wizard Code You Don’t Understand</b>

<p>
Wizards can generate reams of code. Make sure you understand all of
it before you incorporate it into your project.
</p>
</li>
<li><b>Work with a User to Think Like a User</b>

<p>
It’s the best way to gain insight into how the system will really
be used.
</p>
</li>
<li><b>Use a Project Glossary</b>

<p>
Create and maintain a single source of all the specific terms and
vocabulary for a project.
</p>
</li>
<li><b>Start When You’re Ready</b>

<p>
You’ve been building experience all your life. Don’t ignore
niggling doubts.
</p>
</li>
<li><b>Don’t Be a Slave to Formal Methods</b>

<p>
Don’t blindly adopt any technique without putting it into the
context of your development practices and capabilities.
</p>
</li>
<li><b>Organize Teams Around Functionality</b>

<p>
Don’t separate designers from coders, testers from data modelers.
Build teams the way you build code.
</p>
</li>
<li><b>Test Early. Test Often. Test Automatically.</b>

<p>
Tests that run with every build are much more effective than test
plans that sit on a shelf.
</p>
</li>
<li><b>Use Saboteurs to Test Your Testing</b>

<p>
Introduce bugs on purpose in a separate copy of the source to verify
that testing will catch them.
</p>
</li>
<li><b>Find Bugs Once</b>

<p>
Once a human tester finds a bug, it should be the last time a human
tester finds that bug. Automatic tests should check for it from then
on.
</p>
</li>
<li><b>Build Documentation In, Don’t Bolt It On</b>

<p>
Documentation created separately from code is less likely to be
correct and up to date.
</p>
</li>
<li><b>Sign Your Work</b>

<p>
Craftsmen of an earlier age were proud to sign their work. You
should be, too.
</p>
</li>
</ul>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Languages To Learn</h3>
<div class="outline-text-3" id="text-2-1">
<p class="verse">
Tired of C, C++, and Java? Try CLOS, Dylan, Eiffel, Objective C, Prolog,<br  />
Smalltalk, or TOM. Each of these languages has different capabilities<br  />
and a different "flavor." Try a small project at home using one or more of them.<br  />
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">The WISDOM Acrostic</h3>
<div class="outline-text-3" id="text-2-2">
<p class="verse">
What do you want them to learn?<br  />
What is their interest in what you've got to say?<br  />
How sophisticated are they?<br  />
How much detail do they want?<br  />
Whom do you want to own the information?<br  />
How can you motivate them to listen to you?<br  />
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">How to Maintain Orthogonality</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>Design independent, well-defined components.
</li>
<li>Keep your code decoupled.
</li>
<li>Avoid global data.
</li>
<li>Refactor similar functions.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Things to prototype</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>Architecture
</li>
<li>New functionality in an existing system
</li>
<li>Structure or contents of external data
</li>
<li>Third-party tools or components
</li>
<li>Performance issues
</li>
<li>User interface design
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Architectural Questions</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>Are responsibilities well defined?
</li>
<li>Are the collaborations well defined?
</li>
<li>Is coupling minimized?
</li>
<li>Can you identify potential duplication?
</li>
<li>Are interface definitions and constraints acceptable?
</li>
<li>Can modules access needed data – when needed?
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Debugging Checklist</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>Is the problem being reported a direct result of the underlying bug,
or merely a symptom?
</li>
<li>Is the bug really in the compiler? Is it in the OS? Or is it in your code?
</li>
<li>If you explained this problem in detail to a coworker, what would you say?
</li>
<li>If the suspect code passes its unit tests, are the tests complete
enough? What happens if you run the unit test with this data?
</li>
<li>Do the conditions that caused this bug exist anywhere else in the
system?
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Law of Demeter for Functions</h3>
<div class="outline-text-3" id="text-2-7">
<p>
An object's method should call only methods belonging to:
</p>

<ul class="org-ul">
<li>Itself
</li>
<li>Any parameters passed in
</li>
<li>Objects it creates
</li>
<li>Component objects
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">How to Program Deliberately</h3>
<div class="outline-text-3" id="text-2-8">
<ul class="org-ul">
<li>Stay aware of what you're doing.
</li>
<li>Don't code blindfolded.
</li>
<li>Proceed from a plan.
</li>
<li>Rely only on reliable things.
</li>
<li>Document your assumptions.
</li>
<li>Test assumptions as well as code.
</li>
<li>Prioritize your effort.
</li>
<li>Don't be a slave to history.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">When to Refactor</h3>
<div class="outline-text-3" id="text-2-9">
<ul class="org-ul">
<li>You discover a violation of the DRY principle.
</li>
<li>You find things that could be more orthogonal.
</li>
<li>Your knowledge improves.
</li>
<li>The requirements evolve.
</li>
<li>You need to improve performance.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">Cutting the Gordian Knot</h3>
<div class="outline-text-3" id="text-2-10">
<p>
When solving impossible problems, ask yourself:
</p>

<ul class="org-ul">
<li>Is there an easier way?
</li>
<li>Am I solving the right problem?
</li>
<li>Why is this a problem?
</li>
<li>What makes it hard?
</li>
<li>Do I have to do it this way?
</li>
<li>Does it have to be done at all?
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-11" class="outline-3">
<h3 id="sec-2-11">Aspects of Testing</h3>
<div class="outline-text-3" id="text-2-11">
<ul class="org-ul">
<li>Unit testing
</li>
<li>Integration testing
</li>
<li>Validation and verification
</li>
<li>Resource exhaustion, errors, and recovery
</li>
<li>Performance testing
</li>
<li>Usability testing
</li>
<li>Testing the tests themselves
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2017-06-16 Fri 22:42</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
