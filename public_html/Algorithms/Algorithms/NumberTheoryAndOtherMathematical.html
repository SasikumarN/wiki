<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Number theory and Other Mathematical</title>
<!-- 2017-03-28 Tue 21:45 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Number theory and Other Mathematical</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Primality Test</a>
<ul>
<li><a href="#sec-1-1">Optimized</a></li>
<li><a href="#sec-1-2">Fermat’s method</a></li>
<li><a href="#sec-1-3">Miller–Rabin</a></li>
</ul>
</li>
<li><a href="#sec-2">Sieve of Eratosthenes</a></li>
<li><a href="#sec-3">Wilson’s Theorem</a></li>
<li><a href="#sec-4">Pollard’s Rho Algorithm for Prime Factorization</a></li>
<li><a href="#sec-5">Basic and Extended Euclidean algorithms</a>
<ul>
<li><a href="#sec-5-1">Extended Euclidean Algorithm</a></li>
</ul>
</li>
<li><a href="#sec-6">Modular multiplicative inverse</a>
<ul>
<li><a href="#sec-6-1">Works when m and a are coprime</a></li>
<li><a href="#sec-6-2">Works when m is prime</a></li>
</ul>
</li>
<li><a href="#sec-7">Euler’s Totient Function</a></li>
<li><a href="#sec-8">Chinese Remainder Theorem</a></li>
<li><a href="#sec-9">Compute nCr % p</a>
<ul>
<li><a href="#sec-9-1">Dynamic Programming</a></li>
<li><a href="#sec-9-2">Lucas Theorem</a></li>
</ul>
</li>
<li><a href="#sec-10">不用除法和求模运算，判断一个数能否被3整除</a>
<ul>
<li><a href="#sec-10-1">method1</a></li>
<li><a href="#sec-10-2">method2</a></li>
</ul>
</li>
<li><a href="#sec-11">BIT Manipulation</a>
<ul>
<li><a href="#sec-11-1">Find the maximum subarray XOR in a given array</a></li>
<li><a href="#sec-11-2">Find nth Magic Number</a></li>
<li><a href="#sec-11-3">Sum of bit differences among all pairs</a></li>
<li><a href="#sec-11-4"></a></li>
</ul>
</li>
<li><a href="#sec-12">cc</a></li>
</ul>
</div>
</div>



<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Primality Test</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Optimized</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>Instead of checking till n, we can check till √n because a larger
factor of n must be a multiple of smaller factor that has been
already checked
</li>
<li>The algorithm can be improved further by observing that all primes
are of the form 6k ± 1, with the exception of 2 and 3. This is
because all integers can be expressed as (6k + i) for some integer
k and for i = -1, 0, 1, 2, 3, or 4; 2 divides (6k + 0), (6k + 2),
(6k + 4); and 3 divides (6k + 3). So a more efficient method is to
test if n is divisible by 2 or 3, then to check through all the
numbers of form 6k ± 1.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">isPrime</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">if</span> (n &lt;= 1)  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  <span style="color: #00ffff;">if</span> (n &lt;= 3)  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;

  <span style="color: #00ffff;">if</span> (n%2 == 0 || n%3 == 0) <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 5; i*i &lt;= n; i = i+6) { 
    <span style="color: #00ffff;">if</span> (n%i == 0 || n%(i+2) == 0) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Fermat’s method</h3>
<div class="outline-text-3" id="text-1-2">
<p>
This method is a probabilistic method and is based on below <a href="https://en.wikipedia.org/wiki/Fermat's_little_theorem">Fermat’s
Little Theorem</a>.
</p>

<div class="org-src-container">

<pre class="src src-sh">Fermat<span style="color: #ffa07a;">'s Little Theorem:</span>
<span style="color: #ffa07a;">If n is a prime number, then for every a, 1 &lt;= a &lt; n,</span>

<span style="color: #ffa07a;">an-1 &#8801; 1 (mod n)</span>
<span style="color: #ffa07a;"> OR </span>
<span style="color: #ffa07a;">an-1 % n = 1 </span>


<span style="color: #ffa07a;">Example: Since 5 is prime, 24 &#8801; 1 (mod 5) [or 24%5 = 1],</span>
<span style="color: #ffa07a;">         34 &#8801; 1 (mod 5) and 44 &#8801; 1 (mod 5) </span>

<span style="color: #ffa07a;">         Since 7 is prime, 26 &#8801; 1 (mod 7),</span>
<span style="color: #ffa07a;">         36 &#8801; 1 (mod 7), 46 &#8801; 1 (mod 7) </span>
<span style="color: #ffa07a;">         56 &#8801; 1 (mod 7) and 66 &#8801; 1 (mod 7)</span>
</pre>
</div>

<p>
If a given number is prime, then this method always returns true. If
given number is composite (or non-prime), then it may return true or
false, but the probability of producing incorrect result for composite
is low and can be reduced by doing more iterations.
</p>

<p>
<a href="./Files/fermat_is_prime.cc">./Files/fermat_is_prime.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">power</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res</span> = 1;
  a = a % p;
  <span style="color: #00ffff;">while</span> (n &gt; 0) {
    <span style="color: #00ffff;">if</span> (n &amp; 1) {
      res = (res * a) % p;
    }
    n &gt;&gt;= 1;
    a = (a * a) % p;
  }
  <span style="color: #00ffff;">return</span> res;
}

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsPrime</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #00ffff;">if</span> (n &lt;= 1 || n == 4) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">if</span> (n &lt;= 3) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  }
  <span style="color: #00ffff;">while</span> (k &gt; 0) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 2 + rand() % (n - 4);
    <span style="color: #00ffff;">if</span> (power(a, n - 1, n) != 1) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    }
    --k;
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span> = 3;
  IsPrime(11, k) ? cout &lt;&lt; <span style="color: #ffa07a;">" true\n"</span> : cout &lt;&lt; <span style="color: #ffa07a;">" false\n"</span>;
  IsPrime(15, k) ? cout &lt;&lt; <span style="color: #ffa07a;">" true\n"</span> : cout &lt;&lt; <span style="color: #ffa07a;">" false\n"</span>;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Miller–Rabin<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup></h3>
<div class="outline-text-3" id="text-1-3">
<p>
This method is a probabilistic method (Like Fermat), but it generally
preferred over Fermat’s method.
</p>
<div class="org-src-container">

<pre class="src src-sh">// It returns false if n is composite and returns true if n
// is probably prime.  k is an input parameter that determines
// accuracy level. Higher value of k indicates more accuracy.
bool isPrime(int n, int k)
1) Handle base cases for n &lt; 3
2) If n is even, return false.
3) Find an odd number d such that n-1 can be written as d*2r. 
   Note that since, n is odd (n-1) must be even and r must be 
   greater than 0.
4) Do following k times
     <span style="color: #00ffff;">if</span> (millerTest(n, d) == false)
          <span style="color: #00ffff;">return </span><span style="color: #b0c4de;">false</span>
5) Return true.

// This <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">is</span> called for all k trials. It returns 
// false if n is composite and returns false if n is probably
// prime.  
// d is an odd number such that  d*<span style="color: #eedd82;">2r</span> = n-1 for some r &gt;= 1
bool millerTest(int n, int d)
1) Pick a random number <span style="color: #ffa07a;">'a'</span><span style="color: #00ffff;"> in</span> range [2, n-2]
2) Compute: <span style="color: #eedd82;">x</span> = pow(a, d) % n
3) If <span style="color: #eedd82;">x</span> == 1 or <span style="color: #eedd82;">x</span> == n-1, return true.

// Below loop mainly runs <span style="color: #ffa07a;">'r-1'</span> times.
4) Do following while d doesn<span style="color: #ffa07a;">'t become n-1.</span>
<span style="color: #ffa07a;">     a) x = (x*x) % n.</span>
<span style="color: #ffa07a;">     b) If (x == 1) return false.</span>
<span style="color: #ffa07a;">     c) If (x == n-1) return true.</span>
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-sh">Input: <span style="color: #eedd82;">n</span> = 13,  <span style="color: #eedd82;">k</span> = 2.

1) Compute d and r such that d*<span style="color: #eedd82;">2r</span> = n-1, 
     <span style="color: #eedd82;">d</span> = 3, <span style="color: #eedd82;">r</span> = 2. 
2) Call millerTest k times.

1st Iteration:
1) Pick a random number <span style="color: #ffa07a;">'a'</span><span style="color: #00ffff;"> in</span> range [2, n-2]
      Suppose <span style="color: #eedd82;">a</span> = 4

2) Compute: <span style="color: #eedd82;">x</span> = pow(a, d) % n
     <span style="color: #eedd82;">x</span> = 43 % <span style="color: #eedd82;">13</span> = 12

3) Since <span style="color: #eedd82;">x</span> = (n-1), return true.

IInd Iteration:
1) Pick a random number <span style="color: #ffa07a;">'a'</span><span style="color: #00ffff;"> in</span> range [2, n-2]
      Suppose <span style="color: #eedd82;">a</span> = 5

2) Compute: <span style="color: #eedd82;">x</span> = pow(a, d) % n
     <span style="color: #eedd82;">x</span> = 53 % <span style="color: #eedd82;">13</span> = 8

3) x neither 1 nor 12.

4) Do following (r-1) = 1 times
   a) <span style="color: #eedd82;">x</span> = (x * x) % <span style="color: #eedd82;">13</span> = (8 * 8) % <span style="color: #eedd82;">13</span> = 12
   b) Since <span style="color: #eedd82;">x</span> = (n-1), return true.

Since both iterations return true, we return true.
</pre>
</div>

<p>
<a href="./Files/miller-rabin_prime.cc">./Files/miller-rabin_prime.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">(x ^ y) % p</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">power</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> ) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res</span> = 1;
  x = x % p;
  <span style="color: #00ffff;">while</span> (y &gt; 0) {
    <span style="color: #00ffff;">if</span> (y &amp; 1) {
      res = (res * x) % p;
    }
    y &gt;&gt;= 1;
    x = (x * x) % p;
  }
  <span style="color: #00ffff;">return</span> res;
}

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">MillerTest</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">d</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 2 + rand() % (n - 4);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = power(a, d, n);
  <span style="color: #00ffff;">if</span> (x == 1 || x == n - 1) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  }
  <span style="color: #00ffff;">while</span> (d != n - 1) {
    x = (x * x) % n;
    d *= 2;
    <span style="color: #00ffff;">if</span> (x == 1) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (x == n - 1) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
}

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsPrime</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #00ffff;">if</span> (n &lt;= 1 || n == 4) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">if</span> (n &lt;= 3) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">d</span> = n - 1;
  <span style="color: #00ffff;">while</span> (d % 2 == 0) {
    d /= 2;
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; k; ++i) {
    <span style="color: #00ffff;">if</span> (MillerTest(d, n) == <span style="color: #7fffd4;">false</span>) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span> = 4;

  cout &lt;&lt; <span style="color: #ffa07a;">"All primes smaller than 100: \n"</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 1; n &lt; 100; n++) {
    <span style="color: #00ffff;">if</span> (IsPrime(n, k)) { 
      cout &lt;&lt; n &lt;&lt; <span style="color: #ffa07a;">" "</span>;
    }
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Sieve of Eratosthenes</h2>
<div class="outline-text-2" id="text-2">
<p>
Following is the algorithm to find all the prime numbers less than or equal to a given integer n by Eratosthenes’ method:
</p>

<ol class="org-ol">
<li>Create a list of consecutive integers from 2 to n: (2, 3, 4, …,
n).
</li>
<li>Initially, let p equal 2, the first prime number.
</li>
<li>Starting from p, count up in increments of p and mark each of these
numbers greater than p itself in the list. These numbers will be
2p, 3p, 4p, etc.; note that some of them may have already been
marked.
</li>

<li>Find the first number greater than p in the list that is not
marked. If there was no such number, stop. Otherwise, let p now
equal this number (which is the next prime), and repeat from
step 3.
</li>
</ol>

<p>
<a href="./Files/sieve_of_eratosthenes.cc">./Files/sieve_of_eratosthenes.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstring&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SieveOfEratosthenes</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">prime</span>[n+1];
  memset(prime, <span style="color: #7fffd4;">true</span>, <span style="color: #00ffff;">sizeof</span>(prime));

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = 2; p*p &lt;= n; p++) {
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">If prime[p] is not changed, then it is a prime</span>
    <span style="color: #00ffff;">if</span> (prime[p] == <span style="color: #7fffd4;">true</span>) {
      <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = p*2; i &lt;= n; i += p)
        prime[i] = <span style="color: #7fffd4;">false</span>;
    }
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = 2; p &lt;= n; p++) {
    <span style="color: #00ffff;">if</span> (prime[p]) {
      cout &lt;&lt; p &lt;&lt; <span style="color: #ffa07a;">" "</span>;
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 30;
  cout &lt;&lt; <span style="color: #ffa07a;">"Following are the prime numbers smaller "</span>
       &lt;&lt; <span style="color: #ffa07a;">" than or equal to "</span> &lt;&lt; n &lt;&lt; endl;
  SieveOfEratosthenes(n);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Wilson’s Theorem</h2>
<div class="outline-text-2" id="text-3">
<p>
Wilson’s theorem states that a natural number p &gt; 1 is a prime number
if and only if
</p>

<p>
\((n-1)!\ \equiv\ -1 \pmod n\) .
</p>

<p>
但是由于阶乘是呈爆炸增长的，其结论对于实际操作意义不大。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Pollard’s Rho Algorithm for Prime Factorization<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup></h2>
<div class="outline-text-2" id="text-4">
<p>
Given a positive integer n, and that it is composite, find a divisor
of it.
</p>

<p>
<b>Simple approach</b>: Test all integers less than √n
</p>

<p>
A large enough number will still mean a great deal of work. Pollard’s
Rho is a prime factorization algorithm, particularly fast for a large
composite number with small prime factors. The Rho algorithm’s most
remarkable success was the factorization of eighth Fermat number:
1238926361552897 * 93461639715357977769163558199606896584051237541638188580280321.
</p>

<p>
<b>Algorithm:</b>
</p>

<ol class="org-ol">
<li>Start with random x and c. Take y equal to x and f(x) = x2 + c.
</li>
<li>While a divisor isn’t obtained
<ul class="org-ul">
<li>Update x to f(x) (modulo n) [Tortoise Move]
</li>
<li>Update y to f(f(y)) (modulo n) [Hare Move]
</li>
<li>Calculate GCD of |x-y| and n
</li>
<li>If GCD is not unity
<ul class="org-ul">
<li>If GCD is n, repeat from step 2 with another set of x, y and c
</li>
<li>Else GCD is our answer
</li>
</ul>
</li>
</ul>
</li>
</ol>

<p>
<a href="./Files/pollard_rho.cc">./Files/pollard_rho.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctime&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">long</span> <span style="color: #87cefa;">ModularPow</span>(<span style="color: #98fb98;">long</span> <span style="color: #eedd82;">base</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">exp</span>, <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">mod</span>) {
  <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">res</span> = 1;
  <span style="color: #00ffff;">while</span> (exp &gt; 0) {
    <span style="color: #00ffff;">if</span> (exp &amp; 1) {
      res = (res * base) % mod;
    }
    exp &gt;&gt;= 1;
    base = (base * base) % mod;
  }
  <span style="color: #00ffff;">return</span> res;
}

<span style="color: #98fb98;">long</span> <span style="color: #87cefa;">GCD</span>(<span style="color: #98fb98;">long</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">if</span> (a == 0) {
    <span style="color: #00ffff;">return</span> b;
  }
  <span style="color: #00ffff;">return</span> GCD(b % a, a);
}

<span style="color: #98fb98;">long</span> <span style="color: #87cefa;">PollardRho</span>(<span style="color: #98fb98;">long</span> <span style="color: #eedd82;">n</span>) {
  srand(time(<span style="color: #7fffd4;">NULL</span>));
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">no prime divisor for 1</span>
  <span style="color: #00ffff;">if</span> (n == 1) {
    <span style="color: #00ffff;">return</span> n;
  }
  <span style="color: #00ffff;">if</span> (n % 2 == 0) {
    <span style="color: #00ffff;">return</span> 2;
  }
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">pick from the range [2, N)</span>
  <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">x</span> = (rand() % (n - 2)) + 2;
  <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">y</span> = x;
  <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">c</span> = (rand() % (n - 1)) + 1;
  <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">d</span> = 1;
  <span style="color: #00ffff;">while</span> (d == 1) {
    x = (ModularPow(x, 2, n) + c) % n;
    y = (ModularPow(y, 2, n) + c) % n;
    y = (ModularPow(y, 2, n) + c) % n;
    d = GCD(abs(x - y), n);
    <span style="color: #00ffff;">if</span> (d == n) {
      <span style="color: #00ffff;">return</span> PollardRho(n);
    }
  }
  <span style="color: #00ffff;">return</span> d;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">n</span> = 10967535067;
  printf(<span style="color: #ffa07a;">"One of the divisors for %ld is %ld."</span>,
         n, PollardRho(n));
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Basic and Extended Euclidean algorithms</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">gcd</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">if</span> (a == 0)
    <span style="color: #00ffff;">return</span> b;
  <span style="color: #00ffff;">return</span> gcd(b % a, a);
}
</pre>
</div>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Extended Euclidean Algorithm</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Extended Euclidean algorithm also finds integer coefficients x and y
such that:
</p>

<div class="org-src-container">

<pre class="src src-sh">ax + <span style="color: #eedd82;">by</span> = gcd(a, b)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">As seen above, x and y are results for inputs a and b,
   a.x + b.y = gcd                      ----(1)  

And x1 and y1 are results for inputs b%a and a
   (b%a).x1 + a.y1 = gcd   

When we put b%<span style="color: #eedd82;">a</span> = (b - (&#8970;b/a&#8971;).a) <span style="color: #00ffff;">in</span> above, 
we get following. Note that &#8970;b/a&#8971; is floor(a/b)

   (b - (&#8970;b/a&#8971;).a).x1 + a.y1  = gcd

Above equation can also be written as below
   b.x1 + a.(y1 - (&#8970;b/a&#8971;).x1) = gcd      ---(2)

After comparing coefficients of <span style="color: #ffa07a;">'a'</span> and <span style="color: #ffa07a;">'b'</span><span style="color: #00ffff;"> in</span> (1) and 
(2), we get following
   <span style="color: #eedd82;">x</span> = y1 - &#8970;b/a&#8971; * x1
   <span style="color: #eedd82;">y</span> = x1
</pre>
</div>

<p>
<a href="./Files/gcd_extended.cc">./Files/gcd_extended.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">ax + by = gcd(a, b) */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">GCDExtended</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">b</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">y</span>) {
  <span style="color: #00ffff;">if</span> (a == 0) {
    *x = 0;
    *y = 1;
    <span style="color: #00ffff;">return</span> b;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x1</span>, <span style="color: #eedd82;">y1</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">gcd</span> = GCDExtended(b % a, b, &amp;x1, &amp;y1);
  *x = y1 - (b / a) * x1;
  *y = x1;
  <span style="color: #00ffff;">return</span> gcd;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #eedd82;">y</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 35, <span style="color: #eedd82;">b</span> = 15;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">g</span> = GCDExtended(a, b, &amp;x, &amp;y);
  printf(<span style="color: #ffa07a;">"gcd(%d, %d) = %d, x = %d, y = %d\n"</span>,
         a, b, g, x, y);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Modular multiplicative inverse</h2>
<div class="outline-text-2" id="text-6">
<p>
Given two integers ‘a’ and ‘m’, find modular multiplicative
inverse of ‘a’ under modulo ‘m’.
</p>

<p>
The modular multiplicative inverse is an integer ‘x’ such that.
</p>
<div class="org-src-container">

<pre class="src src-sh">a x &#8801; 1 (mod m)
</pre>
</div>
<p>
The value of x should be in {0, 1, 2, … m-1},
</p>

<p>
The multiplicative inverse of “a modulo m” exists if and only if a
and m are relatively prime (i.e., if gcd(a, m) = 1).
</p>
</div>

<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Works when m and a are coprime</h3>
<div class="outline-text-3" id="text-6-1">
<p>
The idea is to use Extended Euclidean algorithms that takes two
integers ‘a’ and ‘b’, finds their gcd and also find ‘x’ and
‘y’ such that
</p>
<div class="org-src-container">

<pre class="src src-sh">ax + <span style="color: #eedd82;">by</span> = gcd(a, b)
</pre>
</div>

<p>
To find multiplicative inverse of ‘a’ under ‘m’, we put b = m in
above formula. Since we know that a and m are relatively prime, we can
put value of gcd as 1.
</p>
<div class="org-src-container">

<pre class="src src-sh">ax + <span style="color: #eedd82;">my</span> = 1
</pre>
</div>

<p>
If we take modulo m on both sides, we get
</p>
<div class="org-src-container">

<pre class="src src-sh">ax + my &#8801; 1 (mod m)
</pre>
</div>

<p>
We can remove the second term on left side as ‘my (mod m)’ would
always be 0 for an integer y.
</p>
<div class="org-src-container">

<pre class="src src-sh">ax + my &#8801; 1 (mod m)
ax  &#8801; 1 (mod m)
</pre>
</div>

<p>
So the ‘x’ that we can find using Extended Euclid Algorithm is
multiplicative inverse of ‘a’
</p>

<p>
<a href="./Files/mod_inverse.cc">./Files/mod_inverse.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">GCDExtended</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">b</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">y</span>) {
  <span style="color: #00ffff;">if</span> (a == 0) {
    *x = 0;
    *y = 1;
    <span style="color: #00ffff;">return</span> b;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x1</span>, <span style="color: #eedd82;">y1</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">gcd</span> = GCDExtended(b % a, a, &amp;x1, &amp;y1);
  *x = y1 - (b / a) * x1;
  *y = x1;
  <span style="color: #00ffff;">return</span> gcd;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ModInverse</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #eedd82;">y</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">g</span> = GCDExtended(a, m, &amp;x, &amp;y);
  <span style="color: #00ffff;">if</span> (g != 1) {
    cout &lt;&lt; <span style="color: #ffa07a;">"Inverse doesn't exist"</span> &lt;&lt; endl;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">m is added to handle negative x</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res</span> = (x % m + m) % m;
    cout &lt;&lt; <span style="color: #ffa07a;">"Modular multiplicative inverse is "</span> &lt;&lt; res &lt;&lt; endl;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 3, <span style="color: #eedd82;">m</span> = 11;
  ModInverse(a, m);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
<b>Iterative Implementation:</b>
</p>

<p>
<a href="./Files/mode_inverse_iterative.cc">./Files/mode_inverse_iterative.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ModInverse</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m0</span> = m, <span style="color: #eedd82;">t</span>, <span style="color: #eedd82;">q</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = 0, <span style="color: #eedd82;">y</span> = 1;
  <span style="color: #00ffff;">if</span> (m == 1) {
    <span style="color: #00ffff;">return</span> 0;
  }
  <span style="color: #00ffff;">while</span> (m &gt; 0) {
    q = a / m;
    t = m;
    m = a % m;
    a = t;

    t = x;
    x = y - q * x;
    y = t;
  }
  <span style="color: #00ffff;">if</span> (y &lt; 0) {
    y += m0;
  }
  <span style="color: #00ffff;">return</span> y;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 3, <span style="color: #eedd82;">m</span> = 11;
  cout &lt;&lt; <span style="color: #ffa07a;">"Modular multiplicative inverse is "</span> &lt;&lt;
      ModInverse(a, m) &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">Works when m is prime</h3>
<div class="outline-text-3" id="text-6-2">
<p>
If we know m is prime, then we can also use Fermats’s little theorem
to find the inverse.
</p>

\begin{equation}
\begin{align}
a^m-1 ≡ 1 (\mbox{mod } m) 
\end{align}
\end{equation}

<p>
If we multiply both sides with a-1 and switch the order, we get
</p>

\begin{equation}
\begin{align}
a^{-1} ≡ a^m-2 (\mbox{mod } m) 
\end{align}
\end{equation}

<p>
Time Complexity of this method is O(Log m)
</p>

<p>
<a href="./Files/mod_inverse1.cc">./Files/mod_inverse1.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">GCD</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">if</span> (a == 0) {
    <span style="color: #00ffff;">return</span> b;
  }
  <span style="color: #00ffff;">return</span> GCD(b % a, a);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">compute x^y under modulo m</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Power</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>) {
  <span style="color: #00ffff;">if</span> (y == 0) {
    <span style="color: #00ffff;">return</span> 1;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = Power(x, y / 2, m) % m;
  p = (p * p) % m;
  <span style="color: #00ffff;">return</span> (y % 2 == 0) ? p : (x * p) % m;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ModInverse</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">g</span> = GCD(a, m);
  <span style="color: #00ffff;">if</span> (g != 1) {
    cout &lt;&lt; <span style="color: #ffa07a;">"Inverse doesn't exist"</span> &lt;&lt; endl;
  } <span style="color: #00ffff;">else</span> {
    cout &lt;&lt; <span style="color: #ffa07a;">"Modular multiplicative inverse is "</span>
         &lt;&lt; Power(a, m-2, m) &lt;&lt; endl;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 3, <span style="color: #eedd82;">m</span> = 11;
  ModInverse(a, m);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Euler’s Totient Function<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup><sup>, </sup><sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup><sup>, </sup><sup><a id="fnr.5" name="fnr.5" class="footref" href="#fn.5">5</a></sup></h2>
<div class="outline-text-2" id="text-7">
<p>
Euler’s Totient function Φ(n) for an input n is count of numbers in
{1, 2, 3, …, n} that are relatively prime to n, 
</p>

<p>
The idea is based on Euler’s product formula which states that value
of totient functions is below product over all prime factors p of n.
</p>


<div class="figure">
<p><img src="./Files/eulersproduct.png" alt="eulersproduct.png" />
</p>
</div>

<p>
<a href="./Files/eduler_totient.cc">./Files/eduler_totient.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">EdulerTotient</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">res</span> = n;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = 2; p * p &lt;= n; ++p) {
    <span style="color: #00ffff;">if</span> (n % p == 0) {
      <span style="color: #00ffff;">while</span> (n % p == 0) {
        n /= p;
      }
      res *= (1.0 - (1.0 / (<span style="color: #98fb98;">float</span>)p));
    }
  }
  <span style="color: #00ffff;">if</span> (n &gt; 1) {
    res *= (1.0 - (1.0 / (<span style="color: #98fb98;">float</span>) n));
  }
  <span style="color: #00ffff;">return</span> (<span style="color: #98fb98;">int</span>)res;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">EdulerTotient1</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res</span> = n;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = 2; p * p &lt;= n; ++p) {
    <span style="color: #00ffff;">if</span> (n % p == 0) {
      <span style="color: #00ffff;">while</span> (n % p == 0) {
        n /= p;
      }
      res -= res / p;
    }
  }
  <span style="color: #00ffff;">if</span> (n &gt; 1) {
    res -= res / n;
  }
  <span style="color: #00ffff;">return</span> res;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>;
  <span style="color: #00ffff;">for</span> (n = 1; n &lt;= 10; n++) {
    printf(<span style="color: #ffa07a;">"phi(%d) = %d\n"</span>, n, EdulerTotient(n));
    printf(<span style="color: #ffa07a;">"phi(%d) = %d\n"</span>, n, EdulerTotient1(n));
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Chinese Remainder Theorem</h2>
<div class="outline-text-2" id="text-8">
<p>
We are given two arrays num[0..k-1] and rem[0..k-1]. In num[0..k-1],
every pair is coprime (gcd for every pair is 1). We need to find
minimum positive number x such that:
</p>
<div class="org-src-container">

<pre class="src src-sh">x % <span style="color: #eedd82;">num</span>[0]    =  rem[0], 
x % <span style="color: #eedd82;">num</span>[1]    =  rem[1], 
.......................
x % <span style="color: #eedd82;">num</span>[k-1]  =  rem[k-1]
</pre>
</div>

<p>
Chinise Remainder Theorem states that there always exists an x that
satisfies given congruences.<sup><a id="fnr.6" name="fnr.6" class="footref" href="#fn.6">6</a></sup>
</p>

<p>
A <b>Naive Approach</b> to find x is to start with 1 and one by one increment
it and check if dividing it with given elements in num[] produces
corresponding remainders in rem[]. Once we find such a x, we return
it.
</p>

<p>
An efficient solution is based on below formula.
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #eedd82;">x</span> =  ( &#8721; (rem[i]*pp[i]*inv[i]) ) % prod
   Where 0 &lt;= i &lt;= n-1

rem[i] is given array of remainders

prod is product of all given numbers
<span style="color: #eedd82;">prod</span> = num[0] * num[1] * ... * num[k-1]

pp[i] is product of all but num[i]
<span style="color: #eedd82;">pp</span>[i] = prod / num[i]

<span style="color: #eedd82;">inv</span>[i] = Modular Multiplicative Inverse of 
         pp[i] with respect to num[i]
</pre>
</div>

<p>
<a href="./Files/chinese_remainder.cc">./Files/chinese_remainder.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ModInverse</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m0</span> = m, <span style="color: #eedd82;">t</span>, <span style="color: #eedd82;">q</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = 0, <span style="color: #eedd82;">y</span> = 1;
  <span style="color: #00ffff;">if</span> (m == 1) {
    <span style="color: #00ffff;">return</span> 0;
  }
  <span style="color: #00ffff;">while</span> (m &gt; 0) {
    q = a / m;
    t = m;
    m = a % m;
    a = t;

    t = x;
    x = y - q * x;
    y = t;
  }
  <span style="color: #00ffff;">if</span> (y &lt; 0) {
    y += m0;
  }
  <span style="color: #00ffff;">return</span> y;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">FindMinX</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">num</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">rem</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">prod</span> = 1;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; k; ++i) {
    prod *= num[i];
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; k; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pp</span> = prod / num[i];
    res += rem[i] * ModInverse(pp, num[i]) * pp;
  }
  <span style="color: #00ffff;">return</span> res % prod;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num</span>[] = {3, 4, 5};
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rem</span>[] = {2, 3, 1};
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span> = <span style="color: #00ffff;">sizeof</span>(num)/<span style="color: #00ffff;">sizeof</span>(num[0]);
  cout &lt;&lt; <span style="color: #ffa07a;">"x is "</span> &lt;&lt; FindMinX(num, rem, k);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Compute nCr % p</h2>
<div class="outline-text-2" id="text-9">
<p>
Given three numbers n, r and p, compute value of nCr mod p.
Example:
</p>
<div class="org-src-container">

<pre class="src src-sh">Input:  <span style="color: #eedd82;">n</span> = 10, <span style="color: #eedd82;">r</span> = 2, <span style="color: #eedd82;">p</span> = 13
Output: 6
Explanation: 10C2 is 45 and 45 % 13 is 6.
</pre>
</div>
</div>

<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">Dynamic Programming</h3>
<div class="outline-text-3" id="text-9-1">
<p>
The idea is to compute nCr using below formula:
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #87cefa;">C</span>(n, r) = C(n-1, r-1) + C(n-1, r)
<span style="color: #87cefa;">C</span>(n, 0) = C(n, n) = 1
</pre>
</div>
<p>
Time complexity of above solution is O(n*r) and it requires O(n)
space.
</p>

<p>
<a href="./Files/ncr_dynamic.cc">./Files/ncr_dynamic.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstring&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">nCrModP</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">r</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">C</span>[r+1];
  memset(C, 0, <span style="color: #00ffff;">sizeof</span>(C));

  C[0] = 1;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt;= n; ++i) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = min(i, r); j &gt; 0; --j) {
      C[j] = (C[j] + C[j-1]) % p;
    }
  }
  <span style="color: #00ffff;">return</span> C[r];
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 10, <span style="color: #eedd82;">r</span> = 2, <span style="color: #eedd82;">p</span> = 13;
  cout &lt;&lt; <span style="color: #ffa07a;">"Value of nCr % p is "</span> &lt;&lt; nCrModP(n, r, p);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">Lucas Theorem</h3>
<div class="outline-text-3" id="text-9-2">
<p>
Lucas Theorem:
<img src="./Files/lucas-theorem.png" alt="lucas-theorem.png" />
</p>

<p>
<b>Time Complexity</b>: Time complexity of this solution is O(p<sup>2</sup> * Logp n).
There are O(Logp n) digits in base p representation of n. Each of
these digits is smaller than p, therefore, computations for individual
digits take O(p<sup>2</sup>). 
</p>

<p>
<a href="./Files/ncr_lucas.cc">./Files/ncr_lucas.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstring&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">nCrModPDP</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">r</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">C</span>[r+1];
  memset(C, 0, <span style="color: #00ffff;">sizeof</span>(C));

  C[0] = 1;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt;= n; ++i) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = min(i, r); j &gt; 0; --j) {
      C[j] = (C[j] + C[j-1]) % p;
    }
  }
  <span style="color: #00ffff;">return</span> C[r];
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">nCrModPLucas</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">r</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span>) {
  <span style="color: #00ffff;">if</span> (r == 0) {
    <span style="color: #00ffff;">return</span> 1;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ni</span> = n % p;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ri</span> = r % p;
  <span style="color: #00ffff;">return</span> (nCrModPLucas(n/p, r/p, p) *
          nCrModPDP(ni, ri, p)) % p;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 1000, <span style="color: #eedd82;">r</span> = 900, <span style="color: #eedd82;">p</span> = 13;
  cout &lt;&lt; <span style="color: #ffa07a;">"Value of nCr % p is "</span> &lt;&lt; nCrModPLucas(n, r, p);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">不用除法和求模运算，判断一个数能否被3整除</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">method1</h3>
<div class="outline-text-3" id="text-10-1">
<p>
这个数的每一个位上的数字加起来后，和为3的倍数。每个位相加，然后不断减去3,看结果是不是等于0
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">parse</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buffer</span>[1024];
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>,<span style="color: #eedd82;">length</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sum</span> = 0;
    <span style="color: #00ffff;">if</span>(n &lt; 10)
    {
        <span style="color: #00ffff;">if</span>(n == 0 || n == 3 || n == 6 || n == 9)
            <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
        <span style="color: #00ffff;">else</span>
            <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    }
    sprintf(buffer,<span style="color: #ffa07a;">"%d"</span>,n);
    length = strlen(buffer);
    <span style="color: #00ffff;">for</span>(i = 0; i != length; i++)
        sum += buffer[i] - <span style="color: #ffa07a;">'0'</span>;
    <span style="color: #00ffff;">return</span> parse(sum);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2">method2</h3>
<div class="outline-text-3" id="text-10-2">
<p>
3 = 0B11
如果a能被3整除，a=b×3,则a的最低位和b的最低位相同，a的次低位=b的次低位
+b的最低位，所以b的次低位=a的次低位-b的最低位，以此求出b。若不能则a不能被3整出
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">divideby3</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;
  <span style="color: #00ffff;">if</span>(n &lt; 0)
    n = -n;
  <span style="color: #00ffff;">while</span>(n &gt; 0){
    temp = n &amp; 1;
    n &gt;&gt;= 1;
    n = n - temp;
  }
  <span style="color: #00ffff;">return</span> (n == 0);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">BIT Manipulation</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">Find the maximum subarray XOR in a given array</h3>
<div class="outline-text-3" id="text-11-1">
<p>
An Efficient Solution can solve the above problem in O(n) time under
the assumption that integers take fixed number of bits to store. The
idea is to use Trie Data Structure. Below is algorithm.
</p>

<div class="org-src-container">

<pre class="src src-sh">1) Create an empty Trie.  Every node of Trie is going to 
   contain two children, for 0 and 1 value of bit.
2) Initialize <span style="color: #eedd82;">pre_xor</span> = 0 and insert into the Trie.
3) Initialize <span style="color: #eedd82;">result</span> = minus infinite
4) Traverse the given array and do following for every 
   array element arr[i].
       a) <span style="color: #eedd82;">pre_xor</span>  = pre_xor  ^ arr[i]
          pre_xor now contains xor of elements from 
          arr[0] to arr[i].
       b) Query the maximum xor value ending with arr[i] 
          from Trie.
       c) Update result if the value obtained<span style="color: #00ffff;"> in</span> step 
          4.b is more than current value of result.
</pre>
</div>
<p>
Let f(i,j) be the xor of the subarray from i to j ,then we have to
maximise f(i,j).
As f(i,j) = f(1,j) xor f(1,i-1) = curr<sub>prefix</sub> xor f(1,i-1).
Where f(1,i-1) is the prefix to be removed.
</p>

<p>
<a href="./Files/find_max_xor.cc">./Files/find_max_xor.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;limits&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">INT_SIZE</span> 32

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">TrieNode</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">value</span>;
  <span style="color: #98fb98;">TrieNode</span> *<span style="color: #eedd82;">arr</span>[2];
};

<span style="color: #98fb98;">TrieNode</span> *<span style="color: #87cefa;">NewNode</span>() {
  <span style="color: #98fb98;">TrieNode</span> *<span style="color: #eedd82;">temp</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">TrieNode</span>;
  temp-&gt;value = 0;
  temp-&gt;arr[0] = temp-&gt;arr[1] = <span style="color: #7fffd4;">NULL</span>;
  <span style="color: #00ffff;">return</span> temp;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Insert</span>(<span style="color: #98fb98;">TrieNode</span> *<span style="color: #eedd82;">root</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pre_xor</span>) {
  <span style="color: #98fb98;">TrieNode</span> *<span style="color: #eedd82;">temp</span> = root;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = INT_SIZE - 1; i &gt;= 0; --i) {
    <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">val</span> = pre_xor &amp; (1 &lt;&lt; i);
    <span style="color: #00ffff;">if</span> (temp-&gt;arr[val] == <span style="color: #7fffd4;">NULL</span>) {
      temp-&gt;arr[val] = NewNode();
    }
    temp = temp-&gt;arr[val];
  }
  temp-&gt;value = pre_xor;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Query</span>(<span style="color: #98fb98;">TrieNode</span> *<span style="color: #eedd82;">root</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pre_xor</span>) {
  <span style="color: #98fb98;">TrieNode</span> *<span style="color: #eedd82;">temp</span> = root;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = INT_SIZE - 1; i &gt;= 0; --i) {
    <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">val</span> = pre_xor &amp; (1 &lt;&lt; i);
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">first look for a prefix that has opposite bit</span>
    <span style="color: #00ffff;">if</span> (temp-&gt;arr[1-val] != <span style="color: #7fffd4;">NULL</span>) {
      temp = temp-&gt;arr[1-val];
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (temp-&gt;arr[val] != <span style="color: #7fffd4;">NULL</span>) {
      temp = temp-&gt;arr[val];
    }
  }
  <span style="color: #00ffff;">return</span> pre_xor ^ (temp-&gt;value);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">MaxSubarrayXOR</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">TrieNode</span> *<span style="color: #eedd82;">root</span> = NewNode();
  Insert(root, 0);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">result</span> = <span style="color: #7fffd4;">numeric_limits</span>&lt;<span style="color: #98fb98;">int</span>&gt;::min(), <span style="color: #eedd82;">pre_xor</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    pre_xor = pre_xor ^ arr[i];
    Insert(root, pre_xor);
    result = max(result, Query(root, pre_xor));
  }
  <span style="color: #00ffff;">return</span> result;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arr</span>[] = {8, 1, 2, 12};
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = <span style="color: #00ffff;">sizeof</span>(arr)/<span style="color: #00ffff;">sizeof</span>(arr[0]);
  cout &lt;&lt; <span style="color: #ffa07a;">"Max subarray XOR is "</span> &lt;&lt; MaxSubarrayXOR(arr, n) &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2">Find nth Magic Number</h3>
<div class="outline-text-3" id="text-11-2">
<p>
A magic number is defined as a number which can be expressed as a
power of 5 or sum of unique powers of 5. First few magic numbers are
5, 25, 30(5 + 25), 125, 130(125 + 5), ….
</p>

<p>
If we notice carefully the magic numbers can be represented as 001,
010, 011, 100, 101, 110 etc, where 001 is 0*pow(5,3) + 0*pow(5,2) +
1*pow(5,1). So basically we need to add powers of 5 for each bit set
in given integer n.
</p>

<p>
<a href="./Files/nth_magic.cc">./Files/nth_magic.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">NthMagicNum</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pow</span> = 1, <span style="color: #eedd82;">answer</span> = 0;
  <span style="color: #00ffff;">while</span> (n) {
    pow *= 5;
    <span style="color: #00ffff;">if</span> (n &amp; 1) {
      answer += pow;
    }
    n &gt;&gt;= 1;
  }
  <span style="color: #00ffff;">return</span> answer;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 5;
  cout &lt;&lt; <span style="color: #ffa07a;">"5th magic number is "</span> &lt;&lt; NthMagicNum(n) &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3">Sum of bit differences among all pairs</h3>
<div class="outline-text-3" id="text-11-3">
<p>
Given an integer array of n integers, find sum of bit differences in
all pairs that can be formed from array elements. Bit difference of a
pair (x, y) is count of different bits at same positions in binary
representations of x and y.  For example, bit difference for 2 and 7
is 2.
</p>

<p>
Examples:
</p>
<div class="org-src-container">

<pre class="src src-sh">Input:  arr[] = {1, 3, 5}
Output: 8
All pairs<span style="color: #00ffff;"> in</span> array are (1, 1), (1, 3), (1, 5)
                       (3, 1), (3, 3) (3, 5),
                       (5, 1), (5, 3), (5, 5)
Sum of bit <span style="color: #eedd82;">differences</span> =  0 + 1 + 1 +
                          1 + 0 + 2 +
                          1 + 2 + 0 
                       = 8
</pre>
</div>
<p>
An Efficient Solution can solve this problem in O(n) time using the
fact that all numbers are represented using 32 bits (or some fixed
number of bits). The idea is to count differences at individual bit
positions. 
</p>

<p>
<a href="./Files/bit_differences.cc">./Files/bit_differences.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">SumBitDifferences</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ret</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 32; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span> = 0;
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = 0; j &lt; n; ++j) {
      <span style="color: #00ffff;">if</span> (arr[j] &amp; (1 &lt;&lt; i)) {
        ++count;
      }
    }
    ret += (count * (n - count) * 2);
  }
  <span style="color: #00ffff;">return</span> ret;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arr</span>[] = {1, 3, 5};
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = <span style="color: #00ffff;">sizeof</span> arr / <span style="color: #00ffff;">sizeof</span> arr[0];
  cout &lt;&lt; SumBitDifferences(arr, n) &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-11-4" class="outline-3">
<h3 id="sec-11-4"></h3>
</div>
</div>


<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">cc</h2>
<div class="outline-text-2" id="text-12">
<div class="org-src-container">

<pre class="src src-sh"></pre>
</div>

<p>
<del>INCLUDE: "./Files/" src c+</del>
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/">http://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="http://www.geeksforgeeks.org/pollards-rho-algorithm-prime-factorization/">http://www.geeksforgeeks.org/pollards-rho-algorithm-prime-factorization/</a>
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
<a href="http://www.geeksforgeeks.org/eulers-totient-function/">http://www.geeksforgeeks.org/eulers-totient-function/</a>
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
<a href="https://en.wikipedia.org/wiki/Euler's_totient_function">https://en.wikipedia.org/wiki/Euler's_totient_function</a>
</p></div>

<div class="footdef"><sup><a id="fn.5" name="fn.5" class="footnum" href="#fnr.5">5</a></sup> <p class="footpara">
<a href="http://e-maxx.ru/algo/euler_function">http://e-maxx.ru/algo/euler_function</a>
</p></div>

<div class="footdef"><sup><a id="fn.6" name="fn.6" class="footnum" href="#fnr.6">6</a></sup> <p class="footpara">
<a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">https://en.wikipedia.org/wiki/Chinese_remainder_theorem</a>
</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2017-03-28 Tue 21:45</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
