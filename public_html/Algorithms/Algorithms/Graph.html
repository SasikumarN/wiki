<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Graph Algorithms</title>
<!-- 2017-04-09 Sun 23:21 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Graph Algorithms</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Breadth First Traversal for a Graph</a></li>
<li><a href="#sec-2">Depth First Traversal for a Graph</a></li>
<li><a href="#sec-3">Dijkstra’s shortest path algorithm</a></li>
<li><a href="#sec-4">Floyd Warshall Algorithm (All Pairs Shortest Path)</a></li>
<li><a href="#sec-5">Union-Find Algorithm(Detect Cycle in an Undirected Graph)</a></li>
<li><a href="#sec-6">Kruskal’s Minimum Spanning Tree Algorithm</a></li>
<li><a href="#sec-7">Prim’s Minimum Spanning Tree</a></li>
<li><a href="#sec-8">Topological Sorting</a></li>
<li><a href="#sec-9">Articulation Points (or Cut Vertices) in a Graph</a></li>
<li><a href="#sec-10">Bridges in a graph</a></li>
<li><a href="#sec-11">Tarjan's strongly connected components algorithm</a>
<ul>
<li><a href="#sec-11-1">Overview</a></li>
<li><a href="#sec-11-2">The algorithm in pseudocode</a></li>
<li><a href="#sec-11-3">Strong connectivity</a></li>
<li><a href="#sec-11-4">Strong connectivity algorithm</a></li>
<li><a href="#sec-11-5">Algorithm in Python</a></li>
<li><a href="#sec-11-6">More</a></li>
</ul>
</li>
<li><a href="#sec-12">Ford-Fulkerson Algorithm for Maximum Flow Problem</a></li>
<li><a href="#sec-13">Find minimum s-t cut in a flow network</a></li>
<li><a href="#sec-14">Dinic’s algorithm for Maximum Flow</a></li>
<li><a href="#sec-15">Check whether a given graph is Bipartite or not</a></li>
<li><a href="#sec-16">Maximum Bipartite Matching</a></li>
<li><a href="#sec-17">Hopcroft–Karp Algorithm for Maximum Matching</a></li>
<li><a href="#sec-18">cc</a></li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Breadth First Traversal for a Graph</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="./Files/breadth-first-traversal.cc">breadth-first-traversal.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;list&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Graph</span> {
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>;
  <span style="color: #98fb98;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt; *<span style="color: #eedd82;">adj</span>;
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Graph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">AddEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>);
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">print BFS from a given source s */</span>
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">BFS</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>);
};

<span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">Graph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>) {
  <span style="color: #00ffff;">this</span>-&gt;v = v;
  adj = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt;[v];
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">AddEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>) {
  adj[v].push_back(w);
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">BFS</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>) {
  <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">visited</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">bool</span>[v];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; v; ++i) {
    visited[i] = <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #98fb98;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">queue</span>;
  visited[s] = <span style="color: #7fffd4;">true</span>;
  queue.push_back(s);

  <span style="color: #7fffd4;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">node</span>;
  <span style="color: #00ffff;">while</span> (!queue.empty()) {
    node = queue.front();
    cout &lt;&lt; node &lt;&lt; <span style="color: #ffa07a;">" "</span>;
    queue.pop_front();

    <span style="color: #00ffff;">for</span> (it = adj[node].begin(); it != adj[node].end(); ++it) {
      <span style="color: #00ffff;">if</span> (!visited[*it]) {
        visited[*it] = <span style="color: #7fffd4;">true</span>;
        queue.push_back(*it);
      }
    }
  }
  cout &lt;&lt; endl;
  <span style="color: #00ffff;">delete</span>[] visited;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">Graph</span> <span style="color: #eedd82;">g</span>(4);
  g.AddEdge(0, 1);
  g.AddEdge(0, 2);
  g.AddEdge(1, 2);
  g.AddEdge(2, 0);
  g.AddEdge(2, 3);
  g.AddEdge(3, 3);

  cout &lt;&lt; <span style="color: #ffa07a;">"Following is Breadth First Traversal "</span>
       &lt;&lt; <span style="color: #ffa07a;">"(starting from vertex 2) \n"</span>;
  g.BFS(2);

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Depth First Traversal for a Graph</h2>
<div class="outline-text-2" id="text-2">
<p>
<a href="./Files/depth-first-traversal.cc">depth-first-traversal.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;list&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Graph</span> {
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>;
  <span style="color: #98fb98;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt; *<span style="color: #eedd82;">adj</span>;

  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">DFSHelper</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">visited</span>);
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Graph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">AddEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>);
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">print DFS from a given source s */</span>
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">DFS</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>);
};

<span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">Graph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>) {
  <span style="color: #00ffff;">this</span>-&gt;v = v;
  adj = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt;[v];
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">AddEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>) {
  adj[v].push_back(w);
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">DFSHelper</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">visited</span>) {
  visited[s] = <span style="color: #7fffd4;">true</span>;
  cout &lt;&lt; s &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  <span style="color: #7fffd4;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span>;
  <span style="color: #00ffff;">for</span> (it = adj[s].begin(); it != adj[s].end(); ++it) {
    <span style="color: #00ffff;">if</span> (!visited[*it]) {
      DFSHelper(*it, visited);
    }
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">DFS</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>) {
  <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">visited</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">bool</span>[v];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; v; ++i) {
    visited[i] = <span style="color: #7fffd4;">false</span>;
  }
  DFSHelper(s, visited);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">Graph</span> <span style="color: #eedd82;">g</span>(4);
  g.AddEdge(0, 1);
  g.AddEdge(0, 2);
  g.AddEdge(1, 2);
  g.AddEdge(2, 0);
  g.AddEdge(2, 3);
  g.AddEdge(3, 3);
  cout &lt;&lt; <span style="color: #ffa07a;">"Following is Depth First Traversal (starting from vertex 2) \n"</span>;
  g.DFS(2);
  cout &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Dijkstra’s shortest path algorithm</h2>
<div class="outline-text-2" id="text-3">
<ol class="org-ol">
<li>Create a set sptSet (shortest path tree set) that keeps track of
vertices included in shortest path tree, i.e., whose minimum
distance from source is calculated and finalized. Initially, this
set is empty.
</li>
<li>Assign a distance value to all vertices in the input graph.
Initialize all distance values as INFINITE. Assign distance value
as 0 for the source vertex so that it is picked first.
</li>
<li>While sptSet doesn’t include all vertices
a) Pick a vertex u which is not there in sptSetand has minimum
distance value.
b) Include u to sptSet.
c) Update distance value of all adjacent vertices of u. To update
the distance values, iterate through all adjacent vertices. For
every adjacent vertex v, if sum of distance value of u (from
source) and weight of edge u-v, is less than the distance value of
v, then update the distance value of v.
</li>
</ol>

<p>
<a href="./Files/dijkstra-shortest-path.cc">dijkstra-shortest-path.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;climits&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">V</span> 9

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">MinDistance</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">dist</span>, <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">spt_set</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">min</span> = INT_MAX, <span style="color: #eedd82;">min_index</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span> = 0; v &lt; V; ++v) {
    <span style="color: #00ffff;">if</span> (spt_set[v] == <span style="color: #7fffd4;">false</span> &amp;&amp; dist[v] &lt; min) {
      min = dist[v];
      min_index = v;
    }
  }
  <span style="color: #00ffff;">return</span> min_index;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PrintSolution</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">dist</span>) {
  printf(<span style="color: #ffa07a;">"Vertex   Distance from Source\n"</span>);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; i++) {
    printf(<span style="color: #ffa07a;">"%d \t\t %d\n"</span>, i, dist[i]);
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dijkstra</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[V][V], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">src</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">dist</span>[V];
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">spt_set</span>[V];

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; ++i) {
    dist[i] = INT_MAX;
    spt_set[i] = <span style="color: #7fffd4;">false</span>;
  }
  dist[src] = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span> = 0; count &lt; V - 1; ++count) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">min_dis_v</span> = MinDistance(dist, spt_set);
    spt_set[min_dis_v] = <span style="color: #7fffd4;">true</span>;
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span> = 0; v &lt; V; ++v) {
      <span style="color: #00ffff;">if</span> (!spt_set[v] &amp;&amp; graph[min_dis_v][v] &amp;&amp;
          dist[min_dis_v] != INT_MAX &amp;&amp;
          (dist[min_dis_v] + graph[min_dis_v][v] &lt; dist[v])) {
        dist[v] = dist[min_dis_v] + graph[min_dis_v][v];
      }
    }
  }
  PrintSolution(dist);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},
                     {4, 0, 8, 0, 0, 0, 0, 11, 0},
                     {0, 8, 0, 7, 0, 4, 0, 0, 2},
                     {0, 0, 7, 0, 9, 14, 0, 0, 0},
                     {0, 0, 0, 9, 0, 10, 0, 0, 0},
                     {0, 0, 4, 14, 10, 0, 2, 0, 0},
                     {0, 0, 0, 0, 0, 2, 0, 1, 6},
                     {8, 11, 0, 0, 0, 0, 1, 0, 7},
                     {0, 0, 2, 0, 0, 0, 6, 7, 0}
  };
  dijkstra(graph, 0);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Floyd Warshall Algorithm (All Pairs Shortest Path)</h2>
<div class="outline-text-2" id="text-4">
<p>
We initialize the solution matrix same as the input graph matrix as a
first step. Then we update the solution matrix by considering all
vertices as an intermediate vertex. The idea is to one by one pick all
vertices and update all shortest paths which include the picked vertex
as an intermediate vertex in the shortest path. When we pick vertex
number k as an intermediate vertex, we already have considered
vertices {0, 1, 2, .. k-1} as intermediate vertices. For every pair
(i, j) of source and destination vertices respectively, there are two
possible cases.
</p>

<ol class="org-ol">
<li>k is not an intermediate vertex in shortest path from i to j. We
keep the value of dist[i][j] as it is.
</li>
<li>k is an intermediate vertex in shortest path from i to j. We update
the value of dist[i][j] as dist[i][k] + dist[k][j].
</li>
</ol>

<p>
<a href="./Files/floyd-warshall-algorithm.cc">floyd-warshall-algorithm.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;climits&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">V</span> 4
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">INF</span> 9999

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PrintSolution</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">dist</span>[][V]) {
  printf (<span style="color: #ffa07a;">"Following matrix shows the shortest distances"</span>
          <span style="color: #ffa07a;">" between every pair of vertices \n"</span>);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; i++) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = 0; j &lt; V; j++) {
      <span style="color: #00ffff;">if</span> (dist[i][j] == INF)
        printf(<span style="color: #ffa07a;">"%7s"</span>, <span style="color: #ffa07a;">"INF"</span>);
      <span style="color: #00ffff;">else</span>
        printf (<span style="color: #ffa07a;">"%7d"</span>, dist[i][j]);
    }
    printf(<span style="color: #ffa07a;">"\n"</span>);
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">FloydWarshall</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[][V]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">dist</span>[V][V], <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span> , <span style="color: #eedd82;">k</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; V; ++i) {
    <span style="color: #00ffff;">for</span> (j = 0; j &lt; V; ++j) {
      dist[i][j] = graph[i][j];
    }
  }
  <span style="color: #00ffff;">for</span> (k = 0; k &lt; V; ++k) {
    <span style="color: #00ffff;">for</span> (i = 0; i &lt; V; ++i) {
      <span style="color: #00ffff;">for</span> (j = 0; j &lt; V; ++j) {
        <span style="color: #00ffff;">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) {
          dist[i][j] = dist[i][k] + dist[k][j];
        }
      }
    }
  }
  PrintSolution(dist);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Let us create the following weighted graph</span>
<span style="color: #ff7f24;">            10</span>
<span style="color: #ff7f24;">       (0)-------&gt;(3)</span>
<span style="color: #ff7f24;">        |         /|\</span>
<span style="color: #ff7f24;">      5 |          |</span>
<span style="color: #ff7f24;">        |          | 1</span>
<span style="color: #ff7f24;">       \|/         |</span>
<span style="color: #ff7f24;">       (1)-------&gt;(2)</span>
<span style="color: #ff7f24;">            3           */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[V][V] = { {0,   5,  INF, 10},
                      {INF, 0,   3, INF},
                      {INF, INF, 0,   1},
                      {INF, INF, INF, 0} };

  FloydWarshall(graph);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Union-Find Algorithm(Detect Cycle in an Undirected Graph)</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>Find: Determine which subset a particular element is in. This can be
used for determining if two elements are in the same subset.
</li>
<li>Union: Join two subsets into a single subset.
</li>
</ul>

<p>
<a href="./Files/union-find-algorithm.cc">union-find-algorithm.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstring&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NO_PARENT</span> -1

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Edge</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">src</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">dest</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Graph</span> {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">V-&gt; Number of vertices</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">E-&gt; Number of edges</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">E</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Edge</span>* <span style="color: #eedd82;">edge</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Graph</span>* <span style="color: #87cefa;">CreateGraph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">E</span>) {
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Graph</span>* <span style="color: #eedd82;">graph</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Graph</span>;
  graph-&gt;V = V;
  graph-&gt;E = E;
  graph-&gt;edge = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Edge</span>[E];
  <span style="color: #00ffff;">return</span> graph;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Find</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">parent</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  <span style="color: #00ffff;">if</span> (parent[i] == NO_PARENT) {
    <span style="color: #00ffff;">return</span> i;
  }
  <span style="color: #00ffff;">return</span> Find(parent, parent[i]);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Union</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">parent</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">xset</span> = Find(parent, x);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">yset</span> = Find(parent, y);
  parent[xset] = yset;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">IsCycle</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Graph</span>* <span style="color: #eedd82;">graph</span>) {
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">parent</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[graph-&gt;V];
  memset(parent, NO_PARENT, <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>) * graph-&gt;V);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; graph-&gt;E; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = Find(parent, graph-&gt;edge[i].src);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span> = Find(parent, graph-&gt;edge[i].dest);
    <span style="color: #00ffff;">if</span> (x == y) {
      <span style="color: #00ffff;">return</span> 1;
    }
    Union(parent, x, y);
  }
  <span style="color: #00ffff;">delete</span>[] parent;
  <span style="color: #00ffff;">return</span> 0;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Let us create following graph</span>
<span style="color: #ff7f24;">         0</span>
<span style="color: #ff7f24;">        |  \</span>
<span style="color: #ff7f24;">        |    \</span>
<span style="color: #ff7f24;">        1-----2 */</span>    
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span> = 3, <span style="color: #eedd82;">E</span> = 3;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Graph</span>* <span style="color: #eedd82;">graph</span> = CreateGraph(V, E);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">add edge 0-1</span>
  graph-&gt;edge[0].src = 0;
  graph-&gt;edge[0].dest = 1;

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">add edge 1-2</span>
  graph-&gt;edge[1].src = 1;
  graph-&gt;edge[1].dest = 2;

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">add edge 0-2</span>
  graph-&gt;edge[2].src = 0;
  graph-&gt;edge[2].dest = 2;

  <span style="color: #00ffff;">if</span> (IsCycle(graph))
    printf( <span style="color: #ffa07a;">"graph contains cycle\n"</span> );
  <span style="color: #00ffff;">else</span>
    printf( <span style="color: #ffa07a;">"graph doesn't contain cycle\n"</span> );
  <span style="color: #00ffff;">delete</span> graph;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Kruskal’s Minimum Spanning Tree Algorithm</h2>
<div class="outline-text-2" id="text-6">
<ol class="org-ol">
<li>Sort all the edges in non-decreasing order of their weight.
</li>
<li>Pick the smallest edge. Check if it forms a cycle with the spanning
tree  formed so far. If cycle is not formed, include this edge.
Else, discard it.  
</li>
<li>Repeat step#2 until there are (V-1) edges in the spanning tree.
</li>
</ol>

<p>
<a href="./Files/kruskal-min-spanning-tree.cc">kruskal-min-spanning-tree.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstring&gt;</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Edge</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">src</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">dest</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">weight</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Graph</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">E</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Edge</span> *<span style="color: #eedd82;">edge</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Graph</span>* <span style="color: #87cefa;">CreateGraph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">E</span>) {
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Graph</span> *<span style="color: #eedd82;">graph</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Graph</span>;
  graph-&gt;V = V;
  graph-&gt;E = E;
  graph-&gt;edge = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Edge</span>[E];
  <span style="color: #00ffff;">return</span> graph;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A structure to represent a subset for union-find</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">subset</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parent</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rank</span>;
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Find</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">subset</span> *<span style="color: #eedd82;">subsets</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">find root and make root as parent of i (path compression)</span>
  <span style="color: #00ffff;">if</span> (subsets[i].parent != i) {
    subsets[i].parent = Find(subsets, subsets[i].parent);
  }
  <span style="color: #00ffff;">return</span> subsets[i].parent;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A function that does union of two sets of x and y</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">(uses union by rank)</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Union</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">subset</span> *<span style="color: #eedd82;">subsets</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">xroot</span> = Find(subsets, x);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">yroot</span> = Find(subsets, y);

  <span style="color: #00ffff;">if</span> (subsets[xroot].rank &lt; subsets[yroot].rank) {
    subsets[xroot].parent = yroot;
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (subsets[xroot].rank &gt; subsets[yroot].rank) {
    subsets[yroot].parent = xroot;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">If ranks are same, then make one as root and increment</span>
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">its rank by one</span>
    subsets[yroot].parent = xroot;
    subsets[xroot].rank++;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">EdgeComp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Edge</span> *<span style="color: #eedd82;">e1</span> = (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Edge</span>*) a;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Edge</span> *<span style="color: #eedd82;">e2</span> = (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Edge</span>*) b;
  <span style="color: #00ffff;">return</span> e1-&gt;weight &gt; e2-&gt;weight;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">KruskalMST</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Graph</span> *<span style="color: #eedd82;">graph</span>) {
  qsort(graph-&gt;edge, graph-&gt;E, <span style="color: #00ffff;">sizeof</span>(graph-&gt;edge[0]), EdgeComp);
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">subset</span> *<span style="color: #eedd82;">subsets</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">subset</span>[graph-&gt;V];

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span> = 0; v &lt; graph-&gt;V; ++v) {
    subsets[v].parent = v;
    subsets[v].rank = 0;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">e</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Edge</span> <span style="color: #eedd82;">result</span>[graph-&gt;V];
  <span style="color: #00ffff;">while</span> (e &lt; graph-&gt;V - 1) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Edge</span> <span style="color: #eedd82;">next_edge</span> = graph-&gt;edge[i++];
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = Find(subsets, next_edge.src);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span> = Find(subsets, next_edge.dest);
    <span style="color: #00ffff;">if</span> (x != y) {
      result[e++] = next_edge;
      Union(subsets, x, y);
    }
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">else discard the next_edge</span>
  }
  printf(<span style="color: #ffa07a;">"Following are the edges in the constructed MST\n"</span>);
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; e; ++i) {
    printf(<span style="color: #ffa07a;">"%d -- %d == %d\n"</span>, result[i].src, result[i].dest,
           result[i].weight);
  }
  <span style="color: #00ffff;">delete</span>[] subsets;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Let us create following weighted graph</span>
<span style="color: #ff7f24;">         10</span>
<span style="color: #ff7f24;">     0--------1</span>
<span style="color: #ff7f24;">     |  \     |</span>
<span style="color: #ff7f24;">     6|   5\   |15</span>
<span style="color: #ff7f24;">     |      \ |</span>
<span style="color: #ff7f24;">     2--------3</span>
<span style="color: #ff7f24;">         4       */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span> = 4;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Number of vertices in graph</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">E</span> = 5;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Number of edges in graph</span>
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Graph</span>* <span style="color: #eedd82;">graph</span> = CreateGraph(V, E);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">add edge 0-1</span>
  graph-&gt;edge[0].src = 0;
  graph-&gt;edge[0].dest = 1;
  graph-&gt;edge[0].weight = 10;

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">add edge 0-2</span>
  graph-&gt;edge[1].src = 0;
  graph-&gt;edge[1].dest = 2;
  graph-&gt;edge[1].weight = 6;

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">add edge 0-3</span>
  graph-&gt;edge[2].src = 0;
  graph-&gt;edge[2].dest = 3;
  graph-&gt;edge[2].weight = 5;

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">add edge 1-3</span>
  graph-&gt;edge[3].src = 1;
  graph-&gt;edge[3].dest = 3;
  graph-&gt;edge[3].weight = 15;

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">add edge 2-3</span>
  graph-&gt;edge[4].src = 2;
  graph-&gt;edge[4].dest = 3;
  graph-&gt;edge[4].weight = 4;

  KruskalMST(graph);
  <span style="color: #00ffff;">delete</span>[] graph-&gt;edge;
  <span style="color: #00ffff;">delete</span> graph;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Prim’s Minimum Spanning Tree</h2>
<div class="outline-text-2" id="text-7">
<ol class="org-ol">
<li>Create a set mstSet that keeps track of vertices already included
in MST.
</li>
<li>Assign a key value to all vertices in the input graph. Initialize
all key values as INFINITE. Assign key value as 0 for the first
vertex so that it is picked first.
</li>
<li>While mstSet doesn’t include all vertices
a) Pick a vertex u which is not there in mstSet and has minimum key
value.
b) Include u to mstSet.
c) Update key value of all adjacent vertices of u. To update the
key values, iterate through all adjacent vertices. For every
adjacent vertex v, if weight of edge u-v is less than the previous
key value of v, update the key value as weight of u-v
</li>
</ol>

<p>
<a href="./Files/prim-min-spanning-tree.cc">prim-min-spanning-tree.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;climits&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">V</span> 5

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">MinKey</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">key</span>, <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">mst_set</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">min</span> = INT_MAX;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">min_index</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span> = 0; v &lt; V; ++v) {
    <span style="color: #00ffff;">if</span> (mst_set[v] == <span style="color: #7fffd4;">false</span> &amp;&amp; key[v] &lt; min) {
      min = key[v];
      min_index = v;
    }
  }
  <span style="color: #00ffff;">return</span> min_index;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">PrintMST</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">parent</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[V][V]) {
  printf(<span style="color: #ffa07a;">"Edge   Weight\n"</span>);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt; V; i++) {
    printf(<span style="color: #ffa07a;">"%d - %d    %d \n"</span>, parent[i], i, graph[i][parent[i]]);
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PrimMST</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[V][V]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">key</span>[V];
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">mst_set</span>[V];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; ++i) {
    key[i] = INT_MAX;
    mst_set[i] = <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parent</span>[V];
  key[0] = 0;
  parent[0] = -1;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span> = 0; count &lt; V - 1; ++count) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">min_v</span> = MinKey(key, mst_set);
    mst_set[min_v] = <span style="color: #7fffd4;">true</span>;
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span> = 0; v &lt; V; ++v) {
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">graph[min_v][v] is non zero only for adjacent vertices of min_v</span>
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">mstSet[v] is false for vertices not yet included in MST</span>
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Update the key only if graph[min_v][v] is smaller than key[v]</span>
      <span style="color: #00ffff;">if</span> (graph[min_v][v] &amp;&amp; mst_set[v] == <span style="color: #7fffd4;">false</span> &amp;&amp;
          graph[min_v][v] &lt; key[v]) {
        parent[v] = min_v;
        key[v] = graph[min_v][v];
      }
    }
  }
  PrintMST(parent, graph);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Let us create the following graph</span>
<span style="color: #ff7f24;">          2    3</span>
<span style="color: #ff7f24;">      (0)--(1)--(2)</span>
<span style="color: #ff7f24;">       |   / \   |</span>
<span style="color: #ff7f24;">      6| 8/   \5 |7</span>
<span style="color: #ff7f24;">       | /     \ |</span>
<span style="color: #ff7f24;">      (3)-------(4)</span>
<span style="color: #ff7f24;">            9          */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[V][V] = {{0, 2, 0, 6, 0},
                     {2, 0, 3, 8, 5},
                     {0, 3, 0, 0, 7},
                     {6, 8, 0, 0, 9},
                     {0, 5, 7, 9, 0},
  };
  PrimMST(graph);

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Topological Sorting</h2>
<div class="outline-text-2" id="text-8">
<p>
Topological sorting for Directed Acyclic Graph (DAG) is a linear
ordering of vertices such that for every directed edge uv, vertex u
comes before v in the ordering. Topological Sorting for a graph is not
possible if the graph is not a DAG.
</p>

<p>
<a href="./Files/topological-sorting.cc">topological-sorting.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span><span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;list&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stack&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Graph</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>; 
  <span style="color: #98fb98;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt; *<span style="color: #eedd82;">adj</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">topologicalSortUtil</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">visited</span>[], <span style="color: #98fb98;">stack</span>&lt;<span style="color: #98fb98;">int</span>&gt; &amp;<span style="color: #eedd82;">Stack</span>);
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Graph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>); 
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">addEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">topologicalSort</span>();
};

<span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">Graph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>) {
  <span style="color: #00ffff;">this</span>-&gt;V = V;
  adj = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt;[V];
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">addEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>) {
  adj[v].push_back(w);
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">topologicalSortUtil</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">visited</span>[], 
                                <span style="color: #98fb98;">stack</span>&lt;<span style="color: #98fb98;">int</span>&gt; &amp;<span style="color: #eedd82;">Stack</span>) {
  visited[v] = <span style="color: #7fffd4;">true</span>;
  <span style="color: #7fffd4;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = adj[v].begin(); i != adj[v].end(); ++i)
    <span style="color: #00ffff;">if</span> (!visited[*i])
      topologicalSortUtil(*i, visited, Stack);
  Stack.push(v);
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">topologicalSort</span>() {
  <span style="color: #98fb98;">stack</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">Stack</span>;
  <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">visited</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">bool</span>[V];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; i++)
    visited[i] = <span style="color: #7fffd4;">false</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; i++)
    <span style="color: #00ffff;">if</span> (visited[i] == <span style="color: #7fffd4;">false</span>)
      topologicalSortUtil(i, visited, Stack);

  <span style="color: #00ffff;">while</span> (Stack.empty() == <span style="color: #7fffd4;">false</span>) {
    cout &lt;&lt; Stack.top() &lt;&lt; <span style="color: #ffa07a;">" "</span>;
    Stack.pop();
  }
  cout &lt;&lt; endl;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">Graph</span> <span style="color: #eedd82;">g</span>(6);
  g.addEdge(5, 2);
  g.addEdge(5, 0);
  g.addEdge(4, 0);
  g.addEdge(4, 1);
  g.addEdge(2, 3);
  g.addEdge(3, 1);

  cout &lt;&lt; <span style="color: #ffa07a;">"Following is a Topological Sort of the given graph \n"</span>;
  g.topologicalSort();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Articulation Points (or Cut Vertices) in a Graph</h2>
<div class="outline-text-2" id="text-9">
<p>
A O(V+E) algorithm to find all Articulation Points (APs)
The idea is to use DFS (Depth First Search). In DFS, we follow
vertices in tree form called DFS tree. In DFS tree, a vertex u is
parent of another vertex v, if v is discovered by u (obviously v is an
adjacent of u in graph). In DFS tree, a vertex u is articulation point
if one of the following two conditions is true.
</p>

<ol class="org-ol">
<li>u is root of DFS tree and it has at least two children.
</li>
<li>u is not root of DFS tree and it has a child v such that no vertex
in subtree rooted with v has a back edge to one of the ancestors
(in DFS tree) of u.
</li>
</ol>

<p>
We do DFS traversal of given graph with additional code to find out
Articulation Points (APs). In DFS traversal, we maintain a <code>parent[]</code>
array where <code>parent[u]</code> stores parent of vertex u. Among the above
mentioned two cases, the first case is simple to detect. For every
vertex, count children. If currently visited vertex u is root
(<code>parent[u]</code> is NIL) and has more than two children, print it.
</p>

<p>
How to handle second case? The second case is trickier. We maintain an
array <code>disc[]</code> to store discovery time of vertices. For every node u, we
need to find out the earliest visited vertex (the vertex with minimum
discovery time) that can be reached from subtree rooted with u. So we
maintain an additional array <code>low[]</code> which is defined as follows.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #eedd82;">low</span>[u] = min(disc[u], disc[w]) 
where w is an ancestor of u and there is a back edge from 
some descendant of u to w.
</pre>
</div>

<p>
<a href="./Files/articulation-points.cc">articulation-points.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;list&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NIL</span> -1

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Graph</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Graph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Graph</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">AddEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">AP</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>;
  <span style="color: #98fb98;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt; *<span style="color: #eedd82;">adj</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">APUtil</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">visited</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">disc</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">low</span>,
              <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">parent</span>, <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">ap</span>);
};

<span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">Graph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>) {
  <span style="color: #00ffff;">this</span>-&gt;V = V;
  adj = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt;[V];
}

<span style="color: #7fffd4;">Graph</span>::~<span style="color: #87cefa;">Graph</span>() {
  <span style="color: #00ffff;">delete</span>[] adj;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">AddEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>) {
  adj[v].push_back(w);
  adj[w].push_back(v);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Note: the graph is undirected</span>
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">AP</span>() {
  <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">visited</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">bool</span>[V];
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">disc</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[V];
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">low</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[V];
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">parent</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[V];
  <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">ap</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">bool</span>[V];

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; ++i) {
    parent[i] = NIL;
    visited[i] = <span style="color: #7fffd4;">false</span>;
    ap[i] = <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; ++i) {
    <span style="color: #00ffff;">if</span> (visited[i] == <span style="color: #7fffd4;">false</span>) {
      APUtil(i, visited, disc, low, parent, ap);
    }
  }

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; ++i) {
    <span style="color: #00ffff;">if</span> (ap[i] == <span style="color: #7fffd4;">true</span>) {
      cout &lt;&lt; i &lt;&lt; <span style="color: #ffa07a;">" "</span>;
    }
  }
  <span style="color: #00ffff;">delete</span>[] visited;
  <span style="color: #00ffff;">delete</span>[] disc;
  <span style="color: #00ffff;">delete</span>[] low;
  <span style="color: #00ffff;">delete</span>[] parent;
  <span style="color: #00ffff;">delete</span>[] ap;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">APUtil</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">visited</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">disc</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">low</span>,
              <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">parent</span>, <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">ap</span>) {
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">time</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">children</span> = 0;
  visited[u] = <span style="color: #7fffd4;">true</span>;
  disc[u] = low[u] = ++time;
  <span style="color: #7fffd4;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span>;
  <span style="color: #00ffff;">for</span> (it = adj[u].begin(); it != adj[u].end(); ++it) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span> = *it;
    <span style="color: #00ffff;">if</span> (visited[v] == <span style="color: #7fffd4;">false</span>) {
      children++;
      parent[v] = u;
      APUtil(v, visited, disc, low, parent, ap);
      low[u] = min(low[u], low[v]);
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">case 1</span>
      <span style="color: #00ffff;">if</span> (parent[u] == NIL &amp;&amp; children &gt; 1) {
        ap[u] = <span style="color: #7fffd4;">true</span>;
      }
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">case 2</span>
      <span style="color: #00ffff;">if</span> (parent[u] != NIL &amp;&amp; low[v] &gt;= disc[u]) {
        ap[u] = <span style="color: #7fffd4;">true</span>;
      }
    } <span style="color: #00ffff;">else</span> {
      <span style="color: #00ffff;">if</span> (v != parent[u]) {
        low[u] = min(low[u], disc[v]);
      }
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Create graphs given in above diagrams</span>
  cout &lt;&lt; <span style="color: #ffa07a;">"\nArticulation points in first graph \n"</span>;
  <span style="color: #98fb98;">Graph</span> <span style="color: #eedd82;">g1</span>(5);
  g1.AddEdge(1, 0);
  g1.AddEdge(0, 2);
  g1.AddEdge(2, 1);
  g1.AddEdge(0, 3);
  g1.AddEdge(3, 4);
  g1.AP();

  cout &lt;&lt; <span style="color: #ffa07a;">"\nArticulation points in second graph \n"</span>;
  <span style="color: #98fb98;">Graph</span> <span style="color: #eedd82;">g2</span>(4);
  g2.AddEdge(0, 1);
  g2.AddEdge(1, 2);
  g2.AddEdge(2, 3);
  g2.AP();

  cout &lt;&lt; <span style="color: #ffa07a;">"\nArticulation points in third graph \n"</span>;
  <span style="color: #98fb98;">Graph</span> <span style="color: #eedd82;">g3</span>(7);
  g3.AddEdge(0, 1);
  g3.AddEdge(1, 2);
  g3.AddEdge(2, 0);
  g3.AddEdge(1, 3);
  g3.AddEdge(1, 4);
  g3.AddEdge(1, 6);
  g3.AddEdge(3, 5);
  g3.AddEdge(4, 5);
  g3.AP();

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Bridges in a graph</h2>
<div class="outline-text-2" id="text-10">
<p>
An edge in an undirected connected graph is a bridge iff removing it
disconnects the graph. For a disconnected undirected graph, definition
is similar, a bridge is an edge removing which increases number of
connected components.
</p>

<p>
A simple approach is to one by one remove all edges and see if removal
of a edge causes disconnected graph. Following are steps of simple
approach for connected graph.
</p>

<ol class="org-ol">
<li>For every edge (u, v), do following
a) Remove (u, v) from graph
b) See if the graph remains connected (We can either use BFS or
DFS)
c) Add (u, v) back to the graph.
</li>
</ol>

<p>
Time complexity of above method is O(E*(V+E)) for a graph represented
using adjacency list.
</p>

<p>
<b>A O(V+E) algorithm to find all Bridges</b>
The idea is similar to O(V+E) algorithm for Articulation Points. We do
DFS traversal of the given graph. In DFS tree an edge(u, v) (u is
parent of v in DFS tree) is bridge if there does not exit any other
alternative to reach u or an ancestor of u from subtree rooted with v.
As discussed in the previous post, the value low[v] indicates earliest
visited vertex reachable from subtree rooted with v. The condition for
an edge(u, v) to be a bridge is, <code>low[v] &gt; disc[u]</code>.
</p>

<p>
<a href="./Files/bridges-in-a-graph.cc">bridges-in-a-graph.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;list&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NIL</span> -1

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Graph</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Graph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Graph</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">AddEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Bridge</span>();

 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>;    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">No. of vertices</span>
  <span style="color: #98fb98;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt; *<span style="color: #eedd82;">adj</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">BridgeUtil</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">visited</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">disc</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span>[],
                  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parent</span>[]);
};

<span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">Graph</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">V</span>) {
  <span style="color: #00ffff;">this</span>-&gt;V = V;
  adj = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt;[V];
}

<span style="color: #7fffd4;">Graph</span>::~<span style="color: #87cefa;">Graph</span>() {
  <span style="color: #00ffff;">delete</span>[] adj;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">AddEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>) {
  adj[v].push_back(w);
  adj[w].push_back(v);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Note: the graph is undirected</span>
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">BridgeUtil</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">visited</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">disc</span>[], 
                       <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parent</span>[]) {
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">time</span> = 0;
  visited[u] = <span style="color: #7fffd4;">true</span>;
  disc[u] = low[u] = ++time;

  <span style="color: #7fffd4;">list</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span>;
  <span style="color: #00ffff;">for</span> (it = adj[u].begin(); it != adj[u].end(); ++it) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span> = *it;
    <span style="color: #00ffff;">if</span> (!visited[v]) {
      parent[v] = u;
      BridgeUtil(v, visited, disc, low, parent);
      low[u]  = min(low[u], low[v]);
      <span style="color: #00ffff;">if</span> (low[v] &gt; disc[u]) {
        cout &lt;&lt; u &lt;&lt;<span style="color: #ffa07a;">" "</span> &lt;&lt; v &lt;&lt; endl;
      }
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (v != parent[u]) {
      low[u]  = min(low[u], disc[v]);
    }
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Graph</span>::<span style="color: #87cefa;">Bridge</span>() {
  <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">visited</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">bool</span>[V];
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">disc</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[V];
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">low</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[V];
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">parent</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[V];

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; i++) {
    parent[i] = NIL;
    visited[i] = <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; i++) { 
    <span style="color: #00ffff;">if</span> (visited[i] == <span style="color: #7fffd4;">false</span>) {
      BridgeUtil(i, visited, disc, low, parent);
    }
  }
  <span style="color: #00ffff;">delete</span>[] visited;
  <span style="color: #00ffff;">delete</span>[] disc;
  <span style="color: #00ffff;">delete</span>[] low;
  <span style="color: #00ffff;">delete</span>[] parent;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"\nBridges in first graph \n"</span>;
  <span style="color: #98fb98;">Graph</span> <span style="color: #eedd82;">g1</span>(5);
  g1.AddEdge(1, 0);
  g1.AddEdge(0, 2);
  g1.AddEdge(2, 1);
  g1.AddEdge(0, 3);
  g1.AddEdge(3, 4);
  g1.Bridge();

  cout &lt;&lt; <span style="color: #ffa07a;">"\nBridges in second graph \n"</span>;
  <span style="color: #98fb98;">Graph</span> <span style="color: #eedd82;">g2</span>(4);
  g2.AddEdge(0, 1);
  g2.AddEdge(1, 2);
  g2.AddEdge(2, 3);
  g2.Bridge();

  cout &lt;&lt; <span style="color: #ffa07a;">"\nBridges in third graph \n"</span>;
  <span style="color: #98fb98;">Graph</span> <span style="color: #eedd82;">g3</span>(7);
  g3.AddEdge(0, 1);
  g3.AddEdge(1, 2);
  g3.AddEdge(2, 0);
  g3.AddEdge(1, 3);
  g3.AddEdge(1, 4);
  g3.AddEdge(1, 6);
  g3.AddEdge(3, 5);
  g3.AddEdge(4, 5);
  g3.Bridge();

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">Tarjan's strongly connected components algorithm</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">Overview</h3>
<div class="outline-text-3" id="text-11-1">
<p>
<a href="https://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm">Tarjan's algorithm</a> is an algorithm in graph theory for finding the
strongly connected components of a graph. It runs in linear time,
matching the time bound for alternative methods including Kosaraju's
algorithm and the path-based strong component algorithm.
</p>
</div>
</div>
<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2">The algorithm in pseudocode</h3>
<div class="outline-text-3" id="text-11-2">
<div class="org-src-container">

<pre class="src src-sh">algorithm tarjan is
 input: graph <span style="color: #eedd82;">G</span> = (V, E)
 output: set of strongly connected components (sets of vertices)

 index := 0
 S := empty
 <span style="color: #00ffff;">for</span> each v<span style="color: #00ffff;"> in</span> V do
   <span style="color: #00ffff;">if</span> (v.index is undefined) <span style="color: #00ffff;">then</span>
     strongconnect(v)
   end if
 end for

 <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">strongconnect</span>(v)
   // Set the depth index for v to the smallest unused index
   v.index := index
   v.lowlink := index
   index := index + 1
   S.push(v)
   v.onStack := true

   // Consider successors of v
   <span style="color: #00ffff;">for</span> each (v, w) <span style="color: #00ffff;">in</span> E do
     <span style="color: #00ffff;">if</span> (w.index is undefined) <span style="color: #00ffff;">then</span>
       // Successor w has not yet been visited; recurse on it
       strongconnect(w)
       v.lowlink  := min(v.lowlink, w.lowlink)
     <span style="color: #00ffff;">else if</span> (w.onStack) <span style="color: #00ffff;">then</span>
       // Successor w is<span style="color: #00ffff;"> in</span> stack S and hence<span style="color: #00ffff;"> in</span> the current SCC
       v.lowlink  := min(v.lowlink, w.index)
     end if
   end for

   // If v is a root node, pop the stack and generate an SCC
   <span style="color: #00ffff;">if</span> (v.lowlink = v.index) <span style="color: #00ffff;">then</span>
     start a new strongly connected component
     repeat
       w := S.pop()
       w.onStack := false
       add w to current strongly connected component
     <span style="color: #00ffff;">while</span> (w != v)
     output the current strongly connected component
   end if
 end <span style="color: #00ffff;">function</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3">Strong connectivity</h3>
<div class="outline-text-3" id="text-11-3">
<p>
In undirected graphs, two vertices are connected if they have a path
connecting them. How should we define connected in a directed graph?
</p>

<p>
We say that a vertex a is strongly connected to b if there exist two
paths, one from a to b and another from b to a.
</p>

<p>
Note that we allow the two paths to share vertices or even to share
edges. We will use a ~ b as shorthand for "a is strongly connected to
b". We will allow very short paths, with one vertex and no edges, so
that any vertex is strongly connected to itself.
</p>
</div>
</div>
<div id="outline-container-sec-11-4" class="outline-3">
<h3 id="sec-11-4">Strong connectivity algorithm<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup></h3>
<div class="outline-text-3" id="text-11-4">
<p>
Define the DFS numbering dfsnum(v) to be the number of vertices
visited before v in the DFS. Then if there is a back or cross edge out
of the subtree of v, it's to something visited before v and therefore
with a smaller dfsnum. We use this by defining the low value low(v) to
be the smallest dfsnum of a vertex reachable by a back or cross edge
from the subtree of v. If there is no such edge, low(v)=dfsnum(v).
Then rephrasing what we've seen so far, v is a head of a component
exactly when low(v)=dfsnum(v). The advantage of using these
definitions is that dfsnum(v) is trivial to calculate as we perform
the DFS, and low(v) is easily computed by combining the low values
from the children of v with the values coming from back or cross edges
out of v itself.
</p>

<p>
We use one more simple data structure, a stack L (represented as a
list) which we use to identify the subtree rooted at a vertex. We
simply push each new vertex onto L as we visit it; then when we have
finished visiting a vertex, its subtree will be everything pushed
after it onto L. If v is a head, and we've already deleted the other
heads in that subtree, the remaining vertices left on L will be
exactly the component [v].
</p>

<p>
We are now ready to describe the actual algorithm. It simply performs
a DFS, keeping track of the low and dfsnum values defined above, using
them to identify heads of components, and when finding a head deleting
the whole component from the graph, using L to find the vertices of
the component.
</p>
</div>
</div>

<div id="outline-container-sec-11-5" class="outline-3">
<h3 id="sec-11-5">Algorithm in Python</h3>
<div class="outline-text-3" id="text-11-5">
<p>
<a href="./Files/tarjan_strongly_connected.py">tarjan strongly connected.py</a>
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">strongly_connected_components</span>(graph):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Tarjan's Algorithm (named for its discoverer, Robert Tarjan) is a graph theory algorithm</span>
<span style="color: #ffa07a;">    for finding the strongly connected components of a graph.</span>

<span style="color: #ffa07a;">    Based on: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm</span>
<span style="color: #ffa07a;">    """</span>

    <span style="color: #ffebcd; background-color: #2f4f4f;">index_counter</span> = [0]
    <span style="color: #ffebcd; background-color: #2f4f4f;">stack</span> = []
    <span style="color: #ffebcd; background-color: #2f4f4f;">lowlinks</span> = {}
    <span style="color: #ffebcd; background-color: #2f4f4f;">index</span> = {}
    <span style="color: #ffebcd; background-color: #2f4f4f;">result</span> = []

    <span style="color: #00ffff;">def</span> <span style="color: #87cefa;">strongconnect</span>(node):
        <span style="color: #ff7f24;"># set the depth index for this node to the smallest unused index</span>
        index[node] = index_counter[0]
        lowlinks[node] = index_counter[0]
        index_counter[0] += 1
        stack.append(node)

        <span style="color: #ff7f24;"># Consider successors of `node`</span>
        <span style="color: #00ffff;">try:</span>
            <span style="color: #ffebcd; background-color: #2f4f4f;">successors</span> = graph[node]
        <span style="color: #00ffff;">except:</span>
            <span style="color: #ffebcd; background-color: #2f4f4f;">successors</span> = []
        <span style="color: #00ffff;">for</span> successor <span style="color: #00ffff;">in</span> successors:
            <span style="color: #00ffff;">if</span> successor <span style="color: #00ffff;">not</span> <span style="color: #00ffff;">in</span> lowlinks:
                <span style="color: #ff7f24;"># Successor has not yet been visited; recurse on it</span>
                strongconnect(successor)
                lowlinks[node] = <span style="color: #b0c4de;">min</span>(lowlinks[node],lowlinks[successor])
            <span style="color: #00ffff;">elif</span> successor <span style="color: #00ffff;">in</span> stack:
                <span style="color: #ff7f24;"># the successor is in the stack and hence in the current strongly connected component (SCC)</span>
                lowlinks[node] = <span style="color: #b0c4de;">min</span>(lowlinks[node],index[successor])

        <span style="color: #ff7f24;"># If `node` is a root node, pop the stack and generate an SCC</span>
        <span style="color: #00ffff;">if</span> lowlinks[node] == index[node]:
            <span style="color: #ffebcd; background-color: #2f4f4f;">connected_component</span> = []

            <span style="color: #00ffff;">while</span> <span style="color: #00ffff;">True</span>:
                <span style="color: #ffebcd; background-color: #2f4f4f;">successor</span> = stack.pop()
                connected_component.append(successor)
                <span style="color: #00ffff;">if</span> successor == node: <span style="color: #00ffff;">break</span>
            <span style="color: #ffebcd; background-color: #2f4f4f;">component</span> = <span style="color: #b0c4de;">tuple</span>(connected_component)
            <span style="color: #ff7f24;"># storing the result</span>
            result.append(component)

    <span style="color: #00ffff;">for</span> node <span style="color: #00ffff;">in</span> graph:
        <span style="color: #00ffff;">if</span> node <span style="color: #00ffff;">not</span> <span style="color: #00ffff;">in</span> lowlinks:
            strongconnect(node)

    <span style="color: #00ffff;">return</span> result

<span style="color: #00ffff;">if</span> <span style="color: #b0c4de;">__name__</span> == <span style="color: #ffa07a;">'__main__'</span>:
    <span style="color: #ffebcd; background-color: #2f4f4f;">result</span> = strongly_connected_components(
        {1:[2],2:[1,5],3:[4],4:[3,5],5:[6],6:[7],7:[8],8:[6,9],9:[]}
        );
    <span style="color: #b0c4de;">print</span> result
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-11-6" class="outline-3">
<h3 id="sec-11-6">More</h3>
<div class="outline-text-3" id="text-11-6">
<ul class="org-ul">
<li><a href="https://gist.github.com/chadhutchins/1440602">Tarjan's strongly connected components algorithm in Javascript</a>
</li>
<li><a href="https://github.com/bwesterb/py-tarjan">Python implementation of Tarjan's algorithm</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">Ford-Fulkerson Algorithm for Maximum Flow Problem</h2>
<div class="outline-text-2" id="text-12">
<p>
Given a graph which represents a flow network where every edge has a
capacity. Also given two vertices source ‘s’ and sink ‘t’ in the
graph, find the maximum possible flow from s to t with following
constraints:
</p>
<ol class="org-ol">
<li>Flow on an edge doesn’t exceed the given capacity of the edge.
</li>
<li>Incoming flow is equal to outgoing flow for every vertex except s
and t.
</li>
</ol>

<p>
For example, consider the following graph.
</p>


<div class="figure">
<p><img src="./Files/ford_fulkerson1.png" alt="ford_fulkerson1.png" />
</p>
</div>

<p>
The maximum possible flow in the above graph is 23.
</p>


<div class="figure">
<p><img src="./Files/ford_fulkerson2.png" alt="ford_fulkerson2.png" />
</p>
</div>

<p>
<b>Residual Graph</b> of a flow network is a graph which indicates additional
possible flow. If there is a path from source to sink in residual
graph, then it is possible to add flow. Every edge of a residual graph
has a value called <b>residual capacity</b> which is equal to original
capacity of the edge minus current flow. Residual capacity is
basically the current capacity of the edge.
</p>

<p>
The important thing is, we need to update residual capacities in the
residual graph. We subtract path flow from all edges along the path
and we add path flow along the reverse edges We need to add path flow
along reverse edges because may later need to send flow in reverse
direction.
</p>

<p>
The above implementation of Ford Fulkerson Algorithm is called
<a href="https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm">Edmonds-Karp Algorithm</a>. The idea of Edmonds-Karp is to use BFS in Ford
Fulkerson implementation as BFS always picks a path with minimum
number of edges. When BFS is used, the worst case time complexity can
be reduced to O(VE<sup>2</sup>). The above implementation uses adjacency matrix
representation though where BFS takes O(V<sup>2</sup>) time, the time complexity
of the above implementation is O(EV<sup>3</sup>) 
</p>

<p>
<a href="./Files/ford-fulkerson.cc">./Files/ford-fulkerson.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;queue&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;climits&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstring&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">V</span> 6

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">BFS</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[V][V], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parent</span>[]) {
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">visited</span>[V];
  memset(visited, 0 , <span style="color: #00ffff;">sizeof</span>(visited));
  <span style="color: #98fb98;">queue</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">q</span>;
  q.push(s);
  visited[s] = <span style="color: #7fffd4;">true</span>;
  parent[s] = -1;

  <span style="color: #00ffff;">while</span> (!q.empty()) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span> = q.front();
    q.pop();
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span> = 0; v &lt; V; ++v) {
      <span style="color: #00ffff;">if</span> (visited[v] == <span style="color: #7fffd4;">false</span> &amp;&amp; graph[u][v] &gt; 0) {
        q.push(v);
        parent[v] = u;
        visited[v] = <span style="color: #7fffd4;">true</span>;
      }
    }
  }
  <span style="color: #00ffff;">return</span> visited[t] == <span style="color: #7fffd4;">true</span>;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">FordFulkerson</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[V][V], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #eedd82;">v</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">resi_graph</span>[V][V];

  <span style="color: #00ffff;">for</span> (u = 0; u &lt; V; ++u) {
    <span style="color: #00ffff;">for</span> (v = 0; v &lt; V; ++v) {
      resi_graph[u][v] = graph[u][v];
    }
  }

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parent</span>[V];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max_flow</span> = 0;
  <span style="color: #00ffff;">while</span> (BFS(resi_graph, s, t, parent)) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">path_flow</span> = INT_MAX;
    <span style="color: #00ffff;">for</span> (v = t; v != s; v = parent[v]) {
      u = parent[v];
      path_flow = min(path_flow, resi_graph[u][v]);
    }
    <span style="color: #00ffff;">for</span> (v = t; v != s; v = parent[v]) {
      u = parent[v];
      resi_graph[u][v] -= path_flow;
      resi_graph[v][u] += path_flow;
    }
    max_flow += path_flow;
  }
  <span style="color: #00ffff;">return</span> max_flow;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[V][V] = { {0, 16, 13, 0, 0, 0},
                      {0, 0, 10, 12, 0, 0},
                      {0, 4, 0, 0, 14, 0},
                      {0, 0, 9, 0, 0, 20},
                      {0, 0, 0, 7, 0, 4},
                      {0, 0, 0, 0, 0, 0}
  };
  cout &lt;&lt; <span style="color: #ffa07a;">"The maximum possible flow from 0 to 5 is "</span>
       &lt;&lt; FordFulkerson(graph, 0 ,5) &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">Find minimum s-t cut in a flow network</h2>
<div class="outline-text-2" id="text-13">
<p>
In a flow network, an s-t cut is a cut that requires the source ‘s’
and the sink ‘t’ to be in different subsets, and it consists of
edges going from the source’s side to the sink’s side. The capacity
of an s-t cut is defined by the sum of capacity of each edge in the
cut-set.<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>

<p>
The problem discussed here is to find minimum capacity s-t cut of the
given network. Expected output is all edges of the minimum cut.
</p>

<p>
For example, in the following flow network, example s-t cuts are {{0
,1}, {0, 2}}, {{0, 2}, {1, 2}, {1, 3}}, etc. The minimum s-t cut is
{{1, 3}, {4, 3}, {4 5}} which has capacity as 12+7+4 = 23.
</p>


<div class="figure">
<p><img src="./Files/minCut.png" alt="minCut.png" />
</p>
</div>

<p>
Like Maximum Bipartite Matching, this is another problem which can
solved using Ford-Fulkerson Algorithm. This is based on max-flow
min-cut theorem.
</p>

<p>
The max-flow min-cut theorem states that in a flow network, the amount
of maximum flow is equal to capacity of the minimum cut. See CLRS book
for proof of this theorem.
</p>

<p>
From Ford-Fulkerson, we get capacity of minimum cut. How to print all
edges that form the minimum cut? The idea is to use residual graph.
</p>

<p>
Following are steps to print all edges of minimum cut.
</p>
<ol class="org-ol">
<li>Run Ford-Fulkerson algorithm and consider the final residual graph.
</li>
<li>Find the set of vertices that are reachable from source in the
residual graph.
</li>
<li>All edges which are from a reachable vertex to non-reachable vertex
are minimum cut edges. Print all such edges.
</li>
</ol>

<p>
<a href="./Files/min_cut_flow.cc">./Files/min_cut_flow.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstring&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;queue&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;limits&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">V</span> 6

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Returns true if there is a path from source 's' to sink 'd' in</span>
<span style="color: #ff7f24;">  residual graph. Also fills parent[] to store the path */</span>
<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">Bfs</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res_graph</span>[V][V], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">d</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">parent</span>) {
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">visited</span>[V];
  memset(visited, 0, <span style="color: #00ffff;">sizeof</span>(visited));
  <span style="color: #98fb98;">queue</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">q</span>;
  q.push(s);
  visited[s] = <span style="color: #7fffd4;">true</span>;
  parent[s] = -1;
  <span style="color: #00ffff;">while</span> (!q.empty()) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span> = q.front();
    q.pop();
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span> = 0; v &lt; V; ++v) {
      <span style="color: #00ffff;">if</span> (visited[v] == <span style="color: #7fffd4;">false</span> &amp;&amp; res_graph[u][v] &gt; 0) {
        q.push(v);
        parent[v] = u;
        visited[v] = <span style="color: #7fffd4;">true</span>;
      }
    }
  }
  <span style="color: #00ffff;">return</span> (visited[d] == <span style="color: #7fffd4;">true</span>);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Dfs</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res_graph</span>[V][V], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">bool</span> *<span style="color: #eedd82;">visited</span>) {
  visited[s] = <span style="color: #7fffd4;">true</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; ++i) {
    <span style="color: #00ffff;">if</span> (res_graph[s][i] &amp;&amp; !visited[i]) {
      Dfs(res_graph, i, visited);
    }
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">MinCut</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[V][V], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">d</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #eedd82;">v</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res_graph</span>[V][V];
  <span style="color: #00ffff;">for</span> (u = 0; u &lt; V; ++u) {
    <span style="color: #00ffff;">for</span> (v = 0; v &lt; V; ++v) {
      res_graph[u][v] = graph[u][v];
    }
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parent</span>[V];
  <span style="color: #00ffff;">while</span> (Bfs(res_graph, s, d, parent)) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">path_flow</span> = <span style="color: #7fffd4;">numeric_limits</span>&lt;<span style="color: #98fb98;">int</span>&gt;::max();
    <span style="color: #00ffff;">for</span> (v = d; v != s; v = parent[v]) {
      u = parent[v];
      path_flow = min(path_flow, res_graph[u][v]);
    }
    <span style="color: #00ffff;">for</span> (v = d; v != s; v = parent[v]) {
      u = parent[v];
      res_graph[u][v] -= path_flow;
      res_graph[v][u] += path_flow;
    }
  }
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">visited</span>[V];
  memset(visited, <span style="color: #7fffd4;">false</span>, <span style="color: #00ffff;">sizeof</span>(visited));
  Dfs(res_graph, s, visited);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; V; ++i) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = 0; j &lt; V; ++j) {
      <span style="color: #00ffff;">if</span> (visited[i] &amp;&amp; !visited[j] &amp;&amp; graph[i][j]) {
        cout &lt;&lt; i &lt;&lt; <span style="color: #ffa07a;">" - "</span> &lt;&lt; j &lt;&lt; endl;
      }
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">graph</span>[V][V] = { {0, 16, 13, 0, 0, 0},
                      {0, 0, 10, 12, 0, 0},
                      {0, 4, 0, 0, 14, 0},
                      {0, 0, 9, 0, 0, 20},
                      {0, 0, 0, 7, 0, 4},
                      {0, 0, 0, 0, 0, 0}
  };
  MinCut(graph, 0, 5);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">Dinic’s algorithm for Maximum Flow</h2>
<div class="outline-text-2" id="text-14">
<p>
<a href="http://www.geeksforgeeks.org/dinics-algorithm-maximum-flow/">http://www.geeksforgeeks.org/dinics-algorithm-maximum-flow/</a>
</p>

<p>
<a href="http://e-maxx.ru/algo/dinic">http://e-maxx.ru/algo/dinic</a>
</p>
</div>
</div>

<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">Check whether a given graph is Bipartite or not</h2>
<div class="outline-text-2" id="text-15">
<p>
A <a href="https://en.wikipedia.org/wiki/Bipartite_graph">Bipartite Graph</a> is a graph whose vertices can be divided into two
independent sets, U and V such that every edge (u, v) either connects
a vertex from U to V or a vertex from V to U. In other words, for
every edge (u, v), either u belongs to U and v to V, or u belongs to V
and v to U. We can also say that there is no edge that connects
vertices of same set.
</p>


<div class="figure">
<p><img src="./Files/Bipartite1.png" alt="Bipartite1.png" />
</p>
</div>

<p>
A bipartite graph is possible if the graph coloring is possible using
two colors such that vertices in a set are colored with the same
color.
</p>

<p>
Following is a simple algorithm to find out whether a given graph is
Birpartite or not using Breadth First Search (BFS).
</p>
<ol class="org-ol">
<li>Assign RED color to the source vertex (putting into set U).
</li>
<li>Color all the neighbors with BLUE color (putting into set V).
</li>
<li>While assigning colors, if we find a neighbor which is colored with
same color as current vertex, then the graph cannot be colored with
2 vertices (or graph is not Bipartite)
</li>
</ol>
</div>
</div>



<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16">Maximum Bipartite Matching</h2>
</div>


<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17">Hopcroft–Karp Algorithm for Maximum Matching</h2>
</div>


<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18">cc</h2>
<div class="outline-text-2" id="text-18">
<div class="org-src-container">

<pre class="src src-sh"></pre>
</div>

<p>
<del>INCLUDE: "./Files/" src c+</del>
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://www.ics.uci.edu/~eppstein/161/960220.html#sca">http://www.ics.uci.edu/~eppstein/161/960220.html#sca</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="http://en.wikipedia.org/wiki/Cut_(graph_theory)">http://en.wikipedia.org/wiki/Cut_(graph_theory)</a>
</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2017-04-09 Sun 23:21</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
