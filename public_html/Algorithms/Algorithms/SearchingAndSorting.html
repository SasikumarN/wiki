<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Searching and Sorting</title>
<!-- 2017-03-14 Tue 00:37 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Searching and Sorting</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">KMP Algorithm</a></li>
<li><a href="#sec-2">Rabin-Karp Algorithm</a></li>
<li><a href="#sec-3">Z algorithm</a></li>
<li><a href="#sec-4">Aho-Corasick Algorithm for Pattern Searching</a></li>
<li><a href="#sec-5">cc</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">KMP Algorithm</h2>
<div class="outline-text-2" id="text-1">
<p>
The KMP matching algorithm uses degenerating property (pattern having
same sub-patterns appearing more than once in the pattern) of the
pattern and improves the worst case complexity to O(n). The basic idea
behind KMP’s algorithm is: whenever we detect a mismatch (after some
matches), we already know some of the characters in the text of next
window. We take advantage of this information to avoid matching the
characters that we know will anyway match. 
</p>

<p>
<b>Preprocessing Overview:</b>
</p>
<ul class="org-ul">
<li>KMP algorithm does preproceses pat[] and constructs an auxiliary
<code>lps[]</code> of size m (same as size of pattern) which is used to skip
characters while matching.
</li>
<li><b>name lps indicates longest proper prefix which is also suffix</b>.. A
proper prefix is prefix with whole string not allowed. For example,
prefixes of “ABC” are “”, “A”, “AB” and “ABC”. Proper
prefixes are “”, “A” and “AB”. Suffixes of the string are
“”, “C”, “BC” and “ABC”.
</li>
<li>For each sub-pattern pat[0..i] where i = 0 to m-1, lps[i] stores
length of the maximum matching proper prefix which is also a suffix
of the sub-pattern pat[0..i].
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #eedd82;">lps</span>[i] = the longest proper prefix of pat[0..i] 
           <span style="color: #b0c4de;">which</span> is also a suffix of pat[0..i].
</pre>
</div>
</li>
</ul>


<p>
<a href="./Files/kmp_search.cc">./Files/kmp_search.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ComputeLPS</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span>&amp; <span style="color: #eedd82;">pat</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">lps</span>) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">length of the previous longest prefix suffix</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span> = 0;
  lps[0] = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span> = pat.size();
  <span style="color: #00ffff;">while</span> (i &lt; m) {
    <span style="color: #00ffff;">if</span> (pat[i] == pat[len]) {
      ++len;
      lps[i] = len;
      ++i;
    } <span style="color: #00ffff;">else</span> {
      <span style="color: #00ffff;">if</span> (len != 0) {
        len = lps[len-1];
      } <span style="color: #00ffff;">else</span> {
        lps[i] = 0;
        ++i;
      }
    }
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">KMPSearch</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span>&amp; <span style="color: #eedd82;">txt</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span>&amp; <span style="color: #eedd82;">pat</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span> = pat.size();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = txt.size();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lps</span>[m];
  ComputeLPS(pat, lps);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = 0;
  <span style="color: #00ffff;">while</span> (i &lt; n) {
    <span style="color: #00ffff;">if</span> (txt[i] == pat[j]) {
      ++i;
      ++j;
    }
    <span style="color: #00ffff;">if</span> (j == m) {
      cout &lt;&lt; <span style="color: #ffa07a;">"Found pattern at index "</span> &lt;&lt; i - j &lt;&lt; endl;
      j = lps[j-1];
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (i &lt; n &amp;&amp; txt[i] != pat[j]) {
      <span style="color: #00ffff;">if</span> (j != 0 ) {
        j = lps[j-1];
      } <span style="color: #00ffff;">else</span> {
        ++i;
      }
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">txt</span> = <span style="color: #ffa07a;">"ABABDABACDABABCABAB"</span>;
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">pat</span> = <span style="color: #ffa07a;">"ABABCABAB"</span>;
  KMPSearch(txt, pat);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Rabin-Karp Algorithm</h2>
<div class="outline-text-2" id="text-2">
<p>
Like the Naive Algorithm, Rabin-Karp algorithm also slides the pattern
one by one. But unlike the Naive algorithm, Rabin Karp algorithm
matches the hash value of the pattern with the hash value of current
substring of text, and if the hash values match then only it starts
matching individual characters. So Rabin Karp algorithm needs to
calculate hash values for following strings.
</p>

<ol class="org-ol">
<li>Pattern itself.
</li>
<li>All the substrings of text of length m.
</li>
</ol>

<p>
Rehashing is done using the following formula.
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #b0c4de;">hash</span>( txt[s+1 .. s+m] ) = d ( <span style="color: #b0c4de;">hash</span>( txt[s .. s+m-1]) &#8211; txt[s]*h ) + txt[s + m] ) mod q

<span style="color: #b0c4de;">hash</span>( txt[s .. s+m-1] ) : Hash value at shift s.
<span style="color: #b0c4de;">hash</span>( txt[s+1 .. s+m] ) : Hash value at next shift (or shift s+1)
d: Number of characters<span style="color: #00ffff;"> in</span> the alphabet
q: A prime number
h: d^(m-1)
</pre>
</div>

<p>
The average and best case running time of the Rabin-Karp algorithm is
<b>O(n+m)</b>, but its worst-case time is <b>O(nm)</b>. Worst case of Rabin-Karp
algorithm occurs when all characters of pattern and text are same as
the hash values of all the substrings of txt[] match with hash value
of pat[]. 
</p>

<p>
<a href="./Files/rabin-karp.cc">./Files/rabin-karp.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">D</span> 256

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Search</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span>&amp; <span style="color: #eedd82;">txt</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span>&amp; <span style="color: #eedd82;">pat</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">q</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = txt.size();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span> = pat.size();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = 0; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">hash value for pattern</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span> = 0; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">hash value for txt</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span> = 1;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The value of h would be "pow(d, M-1)%q"</span>
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; m-1; ++i) {
    h = (h * D) % q;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; m; ++i) {
    p = (D * p + pat[i]) % q;
    t = (D * t + txt[i]) % q;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt;= n - m; ++i) {
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Check the hash values of current window of text</span>
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">and pattern.</span>
    <span style="color: #00ffff;">if</span> (p == t) {
      <span style="color: #00ffff;">for</span> (j = 0; j &lt; m; ++j) {
        <span style="color: #00ffff;">if</span> (txt[i+j] != pat[j]) {
          <span style="color: #00ffff;">break</span>;
        }
      }
      <span style="color: #00ffff;">if</span> (j == m) {
        cout &lt;&lt; <span style="color: #ffa07a;">"Pattern found at index "</span> &lt;&lt; i &lt;&lt; endl;
      }
    }
    <span style="color: #00ffff;">if</span> (i &lt; n - m) {
      t = (D * (t - txt[i] * h) + txt[i+m]) % q;
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">might get negative value of t, converting it</span>
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">to positive</span>
      <span style="color: #00ffff;">if</span> (t &lt; 0) {
        t += q;
      }
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">txt</span> = <span style="color: #ffa07a;">"GEEKS FOR GEEKS"</span>;
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">pat</span> = <span style="color: #ffa07a;">"GEEK"</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">q</span> = 101; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A prime number</span>
  Search(txt, pat, q);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Z algorithm</h2>
<div class="outline-text-2" id="text-3">
<p>
An element Z[i] of Z array stores length of the longest substring
starting from str[i] which is also a prefix of str[0..n-1]. 
</p>

<div class="org-src-container">

<pre class="src src-sh">Examples:
<span style="color: #eedd82;">str</span>  = <span style="color: #ffa07a;">"aaaaaa"</span>
Z[]  = {x, 5, 4, 3, 2, 1}

<span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"aabaacd"</span>
Z[] = {x, 1, 0, 2, 1, 0, 0}

<span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"abababab"</span>
Z[] = {x, 0, 6, 0, 4, 0, 2, 0}
</pre>
</div>

<p>
The idea is to concatenate pattern and text, and create a string
“P$T” where P is pattern, $ is a special character should not be
present in pattern and text, and T is text. Build the Z array for
concatenated string. In Z array, if Z value at any point is equal to
pattern length, then pattern is present at that point.
</p>

<p>
We can construct Z array in linear time.
</p>
<div class="org-src-container">

<pre class="src src-sh">The idea is to maintain an interval [L, R] which is the interval with max R
such that [L,R] is prefix substring (substring which is also prefix). 

Steps for maintaining this interval are as follows &#8211; 

1) If i &gt; R then there is no prefix substring that starts before i and 
   ends after i, so we reset L and R and compute new [L,R] by comparing 
   str[0..] to str[i..] and get Z[i] (= R-L+1).

2) If i &lt;= R then let <span style="color: #eedd82;">K</span> = i-L,  now Z[i] &gt;= min(Z[K], R-i+1)  because 
   str[i..] matches with str[K..] for atleast R-i+1 characters (they are<span style="color: #00ffff;"> in</span>
   [L,R] interval which we know is a prefix substring).     
   Now two sub cases arise &#8211; 
      a) If Z[K] &lt; R-i+1  then there is no prefix substring starting at 
         <span style="color: #eedd82;">str</span>[i] (otherwise Z[K] would be larger)  so  Z[i] = Z[K]  and 
         interval [L,R] remains same.
      b) If Z[K] &gt;= R-i+1 then it is possible to extend the [L,R] interval
         thus we will set L as i and start matching from str[R]  onwards  and
         get new R then we will update interval [L,R] and calculate Z[i] (=R-L+1).
</pre>
</div>

<p>
<a href="./Files/z_algorithm.cc">./Files/z_algorithm.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GetZ</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span>&amp; <span style="color: #eedd82;">str</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">z</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span> = str.size();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>, <span style="color: #eedd82;">L</span>, <span style="color: #eedd82;">R</span>;
  L = R = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt; len; ++i) {
    <span style="color: #00ffff;">if</span> (i &gt; R) {
      L = R = i;
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">if i&gt;R nothing matches so we will calculate Z[i] using naive way.</span>
      <span style="color: #00ffff;">while</span> (R &lt; len &amp;&amp; str[R-L] == str[R]) {
        ++R;
      }
      z[i] = R - L;
      --R;
    } <span style="color: #00ffff;">else</span> {
      k = i - L;
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">if Z[k] is less than remaining interval</span>
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">then Z[i] will be equal to Z[k].</span>
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">For example, str = "ababab", i = 3, R = 5</span>
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">and L = 2</span>
      <span style="color: #00ffff;">if</span> (z[k] &lt; R - i + 1) {
        z[i] = z[k];
      } <span style="color: #00ffff;">else</span> {
        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">For example str = "aaaaaa" and i = 2, R is 5,</span>
        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">L is 0</span>
        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">else start from R and check manually</span>
        L = i;
        <span style="color: #00ffff;">while</span> (R &lt; len &amp;&amp; str[R-L] == str[R]) {
          ++R;
        }
        z[i] = R - L;
        --R;
      }
    }
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Search</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span>&amp; <span style="color: #eedd82;">text</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span>&amp; <span style="color: #eedd82;">pattern</span>) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">concat</span> = pattern + <span style="color: #ffa07a;">"$"</span> + text;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span> = concat.size();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">z</span>[len];
  GetZ(concat, z);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = pattern.size(); i &lt; len; ++i) {
    <span style="color: #00ffff;">if</span> (z[i] == pattern.size()) {
      cout &lt;&lt; <span style="color: #ffa07a;">"Pattern found at index "</span>
           &lt;&lt; i - pattern.size() - 1 &lt;&lt; endl;
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">text</span> = <span style="color: #ffa07a;">"GEEKS FOR GEEKS"</span>;
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">pattern</span> = <span style="color: #ffa07a;">"GEEK"</span>;
  Search(text, pattern);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Aho-Corasick Algorithm for Pattern Searching</h2>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">cc</h2>
<div class="outline-text-2" id="text-5">
<p>
<del>INCLUDE: "./Files/" src c+</del>
</p>

<div class="org-src-container">

<pre class="src src-c++"></pre>
</div>


<div class="org-src-container">

<pre class="src src-sh"></pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2017-03-14 Tue 00:37</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
