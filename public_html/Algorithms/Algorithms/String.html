<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>String / Array</title>
<!-- 2017-04-05 Wed 00:54 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">String / Array</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Find the element that appears once</a></li>
<li><a href="#sec-2">Count Inversions in an array</a>
<ul>
<li><a href="#sec-2-1">Enhance Merge Sort</a></li>
<li><a href="#sec-2-2">Using Self-Balancing Binary Search Tree</a></li>
<li><a href="#sec-2-3">Basic Approach using BIT</a></li>
</ul>
</li>
<li><a href="#sec-3">MO’s Algorithm</a>
<ul>
<li><a href="#sec-3-1">More</a></li>
</ul>
</li>
<li><a href="#sec-4">cc</a></li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Find the element that appears once</h2>
<div class="outline-text-2" id="text-1">
<p>
Given an array where every element occurs three times, except one
element which occurs only once. Find the element that occurs once.
Expected time complexity is O(n) and O(1) extra space.
</p>

<p>
Examples:
</p>
<div class="org-src-container">

<pre class="src src-sh">Input: arr[] = {12, 1, 12, 3, 12, 1, 1, 2, 3, 3}
Output: 2
</pre>
</div>

<p>
Run a loop for all elements in array. At the end of every iteration,
maintain following two values.
</p>
<ul class="org-ul">
<li>ones: The bits that have appeared 1st time or 4th time or 7th time
.. etc.
</li>
<li>twos: The bits that have appeared 2nd time or 5th time or 8th time
.. etc.
</li>
</ul>

<p>
Both ‘ones’ and ‘twos’ contain those extra bits which appear 3rd
time. Remove these extra bits by finding out common set bits in
‘ones’ and ‘twos’.
</p>

<p>
<a href="./Files/find_appears_once.cc">./Files/find_appears_once.cc</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">FindAppearsOnce</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ones</span> = 0, <span style="color: #eedd82;">twos</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    twos = twos | (ones &amp; arr[i]);
    ones = ones ^ arr[i];
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">common_bit_mask</span> = ~(ones &amp; twos);
    ones &amp;= common_bit_mask;
    twos &amp;= common_bit_mask;
  }
  <span style="color: #00ffff;">return</span> ones;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arr</span>[] = {3, 3, 2, 3};
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = <span style="color: #00ffff;">sizeof</span>(arr) / <span style="color: #00ffff;">sizeof</span>(arr[0]);
  cout &lt;&lt; <span style="color: #ffa07a;">"The element with single occurrence is "</span> &lt;&lt;
      FindAppearsOnce(arr, n) &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Count Inversions in an array</h2>
<div class="outline-text-2" id="text-2">
<p>
Inversion Count for an array indicates – how far (or close) the array
is from being sorted. If array is already sorted then inversion count
is 0. If array is sorted in reverse order that inversion count is the
maximum. 
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Enhance Merge Sort</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Time Complexity: O(nlogn)
</p>

<p>
<a href="./Files/count_inversions_merge.cc">./Files/count_inversions_merge.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Merge</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arr</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">temp</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">left</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mid</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">right</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>, <span style="color: #eedd82;">k</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inv_count</span> = 0;

  i = left;
  j = mid;
  k = left;
  <span style="color: #00ffff;">while</span> ((i &lt;= mid - 1) &amp;&amp; (j &lt;= right)) {
    <span style="color: #00ffff;">if</span> (arr[i] &lt;= arr[j]) {
      temp[k++] = arr[i++];
    } <span style="color: #00ffff;">else</span> {
      temp[k++] = arr[j++];
      inv_count += (mid - i);
    }
  }
  <span style="color: #00ffff;">while</span> (i &lt;= mid - 1) {
    temp[k++] = arr[i++];
  }
  <span style="color: #00ffff;">while</span> (j &lt;= right) {
    temp[k++] = arr[j++];
  }
  <span style="color: #00ffff;">for</span> (i = left; i &lt;= right; ++i) {
    arr[i] = temp[i];
  }
  <span style="color: #00ffff;">return</span> inv_count;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">MergeSortHelper</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arr</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">temp</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">left</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">right</span>) {
  <span style="color: #00ffff;">if</span> (left &gt;= right) {
    <span style="color: #00ffff;">return</span> 0;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mid</span> = (left + right) / 2;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inv_count</span>;
  inv_count = MergeSortHelper(arr, temp, left, mid);
  inv_count += MergeSortHelper(arr, temp, mid + 1, right);
  inv_count += Merge(arr, temp, left, mid + 1, right);
  <span style="color: #00ffff;">return</span> inv_count;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">MergeSort</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">size</span>) {
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">temp</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[size];
  <span style="color: #00ffff;">return</span> MergeSortHelper(arr, temp, 0, size - 1);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argv</span>, <span style="color: #98fb98;">char</span>** <span style="color: #eedd82;">args</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arr</span>[] = {1, 20, 6, 4, 5};
  cout &lt;&lt; <span style="color: #ffa07a;">"Number of inversions are "</span> &lt;&lt; MergeSort(arr, 5) &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Using Self-Balancing Binary Search Tree</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The idea is to use Self-Balancing Binary Search Tree like Red-Black
Tree, AVL Tree, etc and augment it so that every node also keeps track
of number of nodes in right subtree.
</p>

<p>
Time complexity of above solution is O(n Log n) as AVL insert takes
O(Log n) time.
</p>

<p>
<a href="./Files/count_inversions_bst.cc">./Files/count_inversions_bst.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">key</span>, <span style="color: #eedd82;">height</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">left</span>, *<span style="color: #eedd82;">right</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">size</span>;
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Height</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">node</span>) {
  <span style="color: #00ffff;">if</span> (node == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span> 0;
  }
  <span style="color: #00ffff;">return</span> node-&gt;height;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Size</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">node</span>) {
  <span style="color: #00ffff;">if</span> (node == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span> 0;
  }
  <span style="color: #00ffff;">return</span> node-&gt;size;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #87cefa;">NewNode</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">key</span>) {
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #eedd82;">node</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Node</span>;
  node-&gt; key = key;
  node-&gt;left = node-&gt;right = <span style="color: #7fffd4;">NULL</span>;
  node-&gt;height = node-&gt;size = 1;
  <span style="color: #00ffff;">return</span> node;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">GetBalance</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">node</span>) {
  <span style="color: #00ffff;">if</span> (node == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span> 0;
  }
  <span style="color: #00ffff;">return</span> Height(node-&gt;left) - Height(node-&gt;right);
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #87cefa;">RightRotate</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">y</span>) {
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">x</span> = y-&gt;left;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">t</span> = x-&gt;right;
  x-&gt;right = y;
  y-&gt;left = t;
  y-&gt;height = max(Height(y-&gt;left), Height(y-&gt;right)) + 1;
  x-&gt;height = max(Height(x-&gt;left), Height(x-&gt;right)) + 1;

  y-&gt;size = Size(y-&gt;left) + Size(y-&gt;right) + 1;
  x-&gt;size = Size(x-&gt;left) + Size(x-&gt;right) + 1;
  <span style="color: #00ffff;">return</span> x;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #87cefa;">LeftRotate</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">x</span>) {
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">y</span> = x-&gt;right;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">t</span> = y-&gt;left;
  y-&gt;left = x;
  x-&gt;right = t;
  x-&gt;height = max(Height(x-&gt;left), Height(x-&gt;right)) + 1;
  y-&gt;height = max(Height(y-&gt;left), Height(y-&gt;right)) + 1;

  x-&gt;size = Size(x-&gt;left) + Size(x-&gt;right) + 1;
  y-&gt;size = Size(y-&gt;left) + Size(y-&gt;right) + 1;
  <span style="color: #00ffff;">return</span> y;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #87cefa;">Insert</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">node</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">key</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">result</span>) {
  <span style="color: #00ffff;">if</span> (node == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span> NewNode(key);
  }
  <span style="color: #00ffff;">if</span> (key &lt; node-&gt;key) {
    node-&gt;left = Insert(node-&gt;left, key, result);
    *result = *result + Size(node-&gt;right) + 1;
  } <span style="color: #00ffff;">else</span> {
    node-&gt;right = Insert(node-&gt;right, key, result);
  }
  node-&gt;height = max(Height(node-&gt;left), Height(node-&gt;right)) + 1;
  node-&gt;size = Size(node-&gt;left) + Size(node-&gt;right) + 1;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">balance</span> = GetBalance(node);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Left Left case</span>
  <span style="color: #00ffff;">if</span> (balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key) {
    <span style="color: #00ffff;">return</span> RightRotate(node);
  }
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Right Right Case</span>
  <span style="color: #00ffff;">if</span> (balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key) {
    <span style="color: #00ffff;">return</span> LeftRotate(node);
  }
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Left Right Case</span>
  <span style="color: #00ffff;">if</span> (balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key) {
    node-&gt;left = LeftRotate(node-&gt;left);
    <span style="color: #00ffff;">return</span> RightRotate(node);
  }
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Right Left Case</span>
  <span style="color: #00ffff;">if</span> (balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key) {
    node-&gt;right = RightRotate(node-&gt;right);
    <span style="color: #00ffff;">return</span> LeftRotate(node);
  }
  <span style="color: #00ffff;">return</span> node;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">GetInvCount</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">root</span> = <span style="color: #7fffd4;">NULL</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">result</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    root = Insert(root, arr[i], &amp;result);
  }
  <span style="color: #00ffff;">return</span> result;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arr</span>[] = {8, 4, 2, 1};
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = <span style="color: #00ffff;">sizeof</span>(arr)/<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>);
  cout &lt;&lt; <span style="color: #ffa07a;">"Number of inversions count are : "</span>
       &lt;&lt; GetInvCount(arr,n);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Basic Approach using BIT</h3>
<div class="outline-text-3" id="text-2-3">
<p>
<b>size Θ(maxElement)</b>
</p>

<ul class="org-ul">
<li>Time Complexity :- The update function and getSum function runs for
O(log(maximumelement)) and we are iterating over n elements. So
overall time complexity is : O(nlog(maximumelement)).
</li>
<li>Auxiliary space : O(maxElement)
</li>
</ul>

<p>
<a href="./Files/count_inversions_bit.cc">./Files/count_inversions_bit.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">GetSum</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">bit_tree</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">index</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sum</span> = 0;
  <span style="color: #00ffff;">while</span> (index &gt; 0) {
    sum += bit_tree[index];
    index -= index &amp; (-index);
  }
  <span style="color: #00ffff;">return</span> sum;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">UpdateBit</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">bit_tree</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">index</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">val</span>) {
  <span style="color: #00ffff;">while</span> (index &lt;= n) {
    bit_tree[index] += val;
    index += index &amp; (-index);
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">GetInvCount</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inv_count</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max_element</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    <span style="color: #00ffff;">if</span> (max_element &lt; arr[i]) {
      max_element = arr[i];
    }
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">Bit</span>[max_element+1];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt;= max_element; ++i) {
    Bit[i] = 0;
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = n - 1; i &gt;= 0; --i) {
    inv_count += GetSum(Bit, arr[i] - 1);
    UpdateBit(Bit, max_element, arr[i], 1);
  }
  <span style="color: #00ffff;">return</span> inv_count;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arr</span>[] = {8, 4, 2, 1};
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = <span style="color: #00ffff;">sizeof</span>(arr)/<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>);
  cout &lt;&lt; <span style="color: #ffa07a;">"Number of inversions are : "</span> &lt;&lt; GetInvCount(arr,n);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
<b>size Θ(n)</b>
</p>

<ul class="org-ul">
<li>Time Complexity :- The update function and getSum function runs for
O(log(n)) and we are iterating over n elements. So overall time
complexity is : O(nlogn).
</li>
<li>Auxiliary space : O(n)
</li>
</ul>

<p>
<a href="./Files/count_inversions_bit_optimize.cc">./Files/count_inversions_bit_optimize.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;algorithm&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">GetSum</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">bit_tree</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">index</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sum</span> = 0;
  <span style="color: #00ffff;">while</span> (index &gt; 0) {
    sum += bit_tree[index];
    index -= index &amp; (-index);
  }
  <span style="color: #00ffff;">return</span> sum;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">UpdateBit</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">bit_tree</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">index</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">val</span>) {
  <span style="color: #00ffff;">while</span> (index &lt;= n) {
    bit_tree[index] += val;
    index += index &amp; (-index);
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Convert</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>[n];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    temp[i] = arr[i];
  }
  sort(temp, temp + n);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    arr[i] = lower_bound(temp, temp+n, arr[i]) - temp + 1;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">GetInvCount</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inv_count</span> = 0;
  Convert(arr, n);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">Bit</span>[n+1];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt;= n; ++i) {
    Bit[i] = 0;
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = n - 1; i &gt;= 0; --i) {
    inv_count += GetSum(Bit, arr[i] - 1);
    UpdateBit(Bit, n, arr[i], 1);
  }
  <span style="color: #00ffff;">return</span> inv_count;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arr</span>[] = {8, 4, 2, 1};
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = <span style="color: #00ffff;">sizeof</span>(arr)/<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>);
  cout &lt;&lt; <span style="color: #ffa07a;">"Number of inversions are : "</span> &lt;&lt; GetInvCount(arr,n);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">MO’s Algorithm</h2>
<div class="outline-text-2" id="text-3">
<p>
We are given an array and a set of query ranges, we are required to
find sum of every query range.
</p>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-sh">Input:  arr[]   = {1, 1, 2, 1, 3, 4, 5, 2, 8};
        query[] = [0, 4], [1, 3] [2, 4]
Output: Sum of arr[] elements<span style="color: #00ffff;"> in</span> range [0, 4] is 8
        Sum of arr[] elements<span style="color: #00ffff;"> in</span> range [1, 3] is 4  
        Sum of arr[] elements<span style="color: #00ffff;"> in</span> range [2, 4] is 6
</pre>
</div>

<p>
The idea of MO’s algorithm is to pre-process all queries so that
result of one query can be used in next query. Below are steps.
</p>

<p>
Let a[0…n-1] be input array and q[0..m-1] be array of queries.
</p>

<ul class="org-ul">
<li>Sort all queries in a way that queries with L values from 0 to √n –
1 are put together, then all queries from √n to 2*√n – 1, and so
on. All queries within a block are sorted in increasing order of R
values.
</li>
<li>Process all queries one by one in a way that every query uses sum
computed in previous query.
<ul class="org-ul">
<li>Let ‘sum’ be sum of previous query.
</li>
<li>Remove extra elements of previous query. For example if previous
query is [0, 8] and current query is [3, 9], then we subtract <code>a[0]</code>
and <code>a[1]</code> from sum
</li>
<li>Add new elements of current query. In the same example as above,
we add <code>a[9]</code> to sum.
</li>
</ul>
</li>

<li>How much currR is moved? Since there are O(√n) blocks, total
movement of currR is O(n * √n).
</li>
<li>How much currL is moved? For m queries, total movement of currL is
O(m * √n)
</li>
<li>takes O(n * √n) + O(m * √n) = O((m+n) * √n) time.
</li>
</ul>

<p>
<a href="./Files/MO_algorithm.cc">./Files/MO_algorithm.cc</a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;algorithm&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cmath&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;


<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">g_block</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Query</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #eedd82;">r</span>;
};

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">Compare</span>(<span style="color: #98fb98;">Query</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">Query</span> <span style="color: #eedd82;">y</span>) {
  <span style="color: #00ffff;">if</span> (x.l / g_block != y.l / g_block) {
    <span style="color: #00ffff;">return</span> x.l / g_block &lt; y.l / g_block;
  }
  <span style="color: #00ffff;">return</span> x.r &lt; y.r;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">QueryResults</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">Query</span> *<span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>) {
  g_block = sqrt(n);
  sort(q, q + m, Compare);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">curr_l</span> = 0, <span style="color: #eedd82;">curr_r</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">curr_sum</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; m; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span> = q[i].l;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">r</span> = q[i].r;
    <span style="color: #00ffff;">while</span> (curr_l &lt; l) {
      curr_sum -= a[curr_l++];
    }
    <span style="color: #00ffff;">while</span> (curr_l &gt; l) {
      curr_sum += a[curr_l-1];
      --curr_l;
    }
    <span style="color: #00ffff;">while</span> (curr_r &lt;= r) {
      curr_sum += a[curr_r++];
    }
    <span style="color: #00ffff;">while</span> (curr_r &gt; r + 1) {
      curr_sum -= a[curr_r-1];
      --curr_r;
    }
    cout &lt;&lt; <span style="color: #ffa07a;">"Sum of ["</span> &lt;&lt; l &lt;&lt; <span style="color: #ffa07a;">", "</span> &lt;&lt; r
         &lt;&lt; <span style="color: #ffa07a;">"] is "</span>  &lt;&lt; curr_sum &lt;&lt; endl;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>[] = {1, 1, 2, 1, 3, 4, 5, 2, 8};
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = <span style="color: #00ffff;">sizeof</span>(a)/<span style="color: #00ffff;">sizeof</span>(a[0]);
  <span style="color: #98fb98;">Query</span> <span style="color: #eedd82;">q</span>[] = {{0, 4}, {1, 3}, {2, 4}};
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span> = <span style="color: #00ffff;">sizeof</span>(q)/<span style="color: #00ffff;">sizeof</span>(q[0]);
  QueryResults(a, n, q, m);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">More</h3>
<div class="outline-text-3" id="text-3-1">
<p>
compute prefix sum for all elements from 0 to n-1. Let the prefix sum
be stored in an array preSum[] (The value of preSum[i] stores sum of
arr[0..i]). Once we have built preSum[], we can traverse through all
queries one by one. For every query [L, R], we return value of
preSum[R] – preSum[L]. Here processing every query takes O(1) time.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">cc</h2>
<div class="outline-text-2" id="text-4">
<p>
<del>INCLUDE: "./Files/" src c+</del>
</p>

<div class="org-src-container">

<pre class="src src-sh"></pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2017-04-05 Wed 00:54</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
