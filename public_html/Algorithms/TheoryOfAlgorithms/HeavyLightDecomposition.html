<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Heavy Light Decomposition</title>
<!-- 2016-11-19 Sat 22:47 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Heavy Light Decomposition</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Overview</a>
<ul>
<li><a href="#sec-1-1">Basic idea of the algorithm</a></li>
<li><a href="#sec-1-2">Application</a></li>
</ul>
</li>
<li><a href="#sec-2">Examples</a>
<ul>
<li><a href="#sec-2-1">maximum edge weight on the path from node a to node b</a></li>
<li><a href="#sec-2-2">the maximum edge cost on the path from node a to node b</a></li>
</ul>
</li>
<li><a href="#sec-3">More</a></li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
The heavy-light (H-L) decomposition of a rooted tree is a method of
partitioning of the vertices of the tree into disjoint paths (all
vertices have degree two, except the endpoints of a path, with degree
one) that gives important asymptotic time bounds for certain problems
involving trees.<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Basic idea of the algorithm</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>divide the tree into vertex-disjoint path (no two paths have a node
in common)
</li>
<li>in another words, the path from <b>any node</b> to <b>root</b> can be broken
into pieces, and there are no more than \(logN\) pieces
</li>
<li>use <a href="http://wiki.dreamrunner.org/public_html/Algorithms/TheoryOfAlgorithms/SegmentTree.html">Segment tree</a>/other data structures deal with the different
paths, it can be up to \(O(logN)\) complexity
</li>
<li>any node A to any node B can be broken into two paths: A to LCA(A,B)
and LCA(A,B) to B. Details about LCA(Lowest common ancestor): <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">wiki</a>, <a href="http://wcipeg.com/wiki/Lowest_common_ancestor">wcipeg wiki</a>
and <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/">Range Minimum Query and Lowest Common Ancestor</a>
</li>
<li>the whole complexity: \(O(log^2 N)\)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Application</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>The maximum number of the path between the two vertices
</li>
<li>The sum of the numbers in the path between two vertices
</li>
<li>Repainting edges path between two vertices
</li>
<li>and more
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Examples</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">maximum edge weight on the path from node a to node b<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup></h3>
<div class="outline-text-3" id="text-2-1">
<p>
You are given a tree (an acyclic undirected connected graph) with N
nodes, and edges numbered 1, 2, 3&#x2026;N-1.
We will ask you to perfrom some instructions of the following form:
</p>
<ul class="org-ul">
<li>change(a, b): Update weight of the ath edge to b.
</li>
<li>maxEdge(a, b): Print the maximum edge weight on the path from node a
to node b.
</li>
</ul>

<p>
The basic idea of the source codes:
</p>
<ul class="org-ul">
<li>DFS the whole tree to get tree info(depth, subsize, etc.)
</li>
<li>construct a Segment tree using all nodes
</li>
<li>A easy LCA algorithm:  find first node common in path from v to root
and u to root
</li>
<li>max edge between the u and LCA(u,v): if they are in the same chain,
just use segment tree get the max edge, if are not, continue to
compute the max edge between chain<sub>head</sub>(u) and LCA(u,v)
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span><span style="color: #ffa07a;">&lt;bits/stdc++.h&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">N</span> 1024

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">tree</span>[N][N];  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Matrix representing the tree</span>

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">a tree node structure. Every node has a parent, depth,</span>
<span style="color: #ff7f24;">   subtree size, chain to which it belongs and a position</span>
<span style="color: #ff7f24;">   in base array*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">treeNode</span>
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">par</span>;   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Parent of this node</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">depth</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Depth of this node</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">size</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Size of subtree rooted with this node</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pos_segbase</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Position in segment tree base</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chain</span>;
} <span style="color: #eedd82;">node</span>[N];

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">every Edge has a weight and two ends. We store deeper end */</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Edge</span>
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">weight</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Weight of Edge</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">deeper_end</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Deeper end</span>
} <span style="color: #eedd82;">edge</span>[N];

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">we construct one segment tree, on base array */</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">segmentTree</span>
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">base_array</span>[N], <span style="color: #eedd82;">tree</span>[6*N];
} <span style="color: #eedd82;">s</span>;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A function to add Edges to the Tree matrix</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">e is Edge ID, u and v are the two nodes, w is weight</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">addEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">e</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>)
{
  <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">tree as undirected graph*/</span>
  tree[u-1][v-1] = e-1;
  tree[v-1][u-1] = e-1;
  edge[e-1].weight = w;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A recursive function for DFS on the tree</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">curr is the current node, prev is the parent of curr,</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">dep is its depth</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dfs</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">curr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">prev</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">dep</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">set parent of current node to predecessor*/</span>
  node[curr].par = prev;
  node[curr].depth = dep;
  node[curr].size = 1;

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">for node's every child */</span>
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span>=0; j&lt;n; j++)
  {
    <span style="color: #00ffff;">if</span> (j!=curr &amp;&amp; j!=node[curr].par &amp;&amp; tree[curr][j]!=-1)
    {
      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">set deeper end of the Edge as this child*/</span>
      edge[tree[curr][j]].deeper_end = j;
      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">do a DFS on subtree */</span>
      dfs(j, curr, dep+1, n);
      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">update subtree size */</span>
      node[curr].size+=node[j].size;
    }
  }
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A recursive function that decomposes the Tree into chains</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hld</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">curr_node</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">edge_counted</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">curr_chain</span>,
         <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chain_heads</span>[])
{
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">if the current chain has no head, this node is the first node</span>
<span style="color: #ff7f24;">   * and also chain head */</span>
  <span style="color: #00ffff;">if</span> (chain_heads[*curr_chain]==-1)
    chain_heads[*curr_chain] = curr_node;

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">set chain ID to which the node belongs */</span>
  node[curr_node].chain = *curr_chain;

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">set position of node in the array acting as the base to</span>
<span style="color: #ff7f24;">     the segment tree */</span>
  node[curr_node].pos_segbase = *edge_counted;

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">update array which is the base to the segment tree */</span>
  s.base_array[(*edge_counted)++] = edge[id].weight;

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Find the special child (child with maximum size)  */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">spcl_chld</span> = -1, <span style="color: #eedd82;">spcl_edg_id</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span>=0; j&lt;n; j++)
    <span style="color: #00ffff;">if</span> (j!=curr_node &amp;&amp; j!=node[curr_node].par &amp;&amp; tree[curr_node][j]!=-1)
      <span style="color: #00ffff;">if</span> (spcl_chld==-1 || node[spcl_chld].size &lt; node[j].size)
        spcl_chld = j, spcl_edg_id = tree[curr_node][j];

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">if special child found, extend chain */</span>
  <span style="color: #00ffff;">if</span> (spcl_chld!=-1)
    hld(spcl_chld, spcl_edg_id, edge_counted, curr_chain, n, chain_heads);

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">for every other (normal) child, do HLD on child subtree as separate</span>
<span style="color: #ff7f24;">     chain*/</span>
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span>=0; j&lt;n; j++)
  {
    <span style="color: #00ffff;">if</span> (j!=curr_node &amp;&amp; j!=node[curr_node].par &amp;&amp;
        j!=spcl_chld &amp;&amp; tree[curr_node][j]!=-1)
    {
      (*curr_chain)++;
      hld(j, tree[curr_node][j], edge_counted, curr_chain, n, chain_heads);
    }
  }
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A recursive function that constructs Segment Tree for array[ss..se).</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">si is index of current node in segment tree st</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">construct_ST</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ss</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">se</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">si</span>)
{
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">If there is one element in array, store it in current node of</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">segment tree and return</span>
  <span style="color: #00ffff;">if</span> (ss == se-1)
  {
    s.tree[si] = s.base_array[ss];
    <span style="color: #00ffff;">return</span> s.base_array[ss];
  }

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">If there are more than one elements, then recur for left and</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">right subtrees and store the minimum of two values in this node</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mid</span> = (ss + se)/2;
  s.tree[si] =  max(construct_ST(ss, mid, si*2),
                    construct_ST(mid, se, si*2+1));
  <span style="color: #00ffff;">return</span> s.tree[si];
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A recursive function that updates the Segment Tree</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">x is the node to be updated to value val</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">si is the starting index of the segment tree</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">ss, se mark the corners of the range represented by si</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">update_ST</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ss</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">se</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">si</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">val</span>)
{

  <span style="color: #00ffff;">if</span> (ss &gt; x || se &lt;= x) {
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (ss == x &amp;&amp; ss == se-1) {
    s.tree[si] = val;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mid</span> = (ss + se)/2;
    s.tree[si] = max(update_ST(ss, mid, si*2, x, val),
                     update_ST(mid, se, si*2+1, x, val));
  }
  <span style="color: #00ffff;">return</span> s.tree[si];
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A function to update Edge e's value to val in segment tree</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">change</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">e</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">val</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  update_ST(0, n, 1, node[edge[e].deeper_end].pos_segbase, val);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A function to get the LCA of nodes u and v</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">LCA</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">array for storing path from u to root */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">LCA_aux</span>[n+5];
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Set u is deeper node if it is not</span>
  <span style="color: #00ffff;">if</span> (node[u].depth &lt; node[v].depth)
    swap(u, v);

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">LCA_aux will store path from node u to the root*/</span>
  memset(LCA_aux, -1, <span style="color: #00ffff;">sizeof</span>(LCA_aux));
  <span style="color: #00ffff;">while</span> (u!=-1)
  {
    LCA_aux[u] = 1;
    u = node[u].par;
  }
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">find first node common in path from v to root and u to</span>
<span style="color: #ff7f24;">     root using LCA_aux */</span>
  <span style="color: #00ffff;">while</span> (v)
  {
    <span style="color: #00ffff;">if</span> (LCA_aux[v]==1)
      <span style="color: #00ffff;">break</span>;
    v = node[v].par;
  }
  <span style="color: #00ffff;">return</span> v;
}

<span style="color: #ff7f24;">/*  </span><span style="color: #ff7f24;">A recursive function to get the minimum value in a given range</span>
<span style="color: #ff7f24;">    of array indexes. The following are parameters for this function.</span>
<span style="color: #ff7f24;">    index --&gt; Index of current node in the segment tree. Initially</span>
<span style="color: #ff7f24;">    ss &amp; se  --&gt; Starting and ending indexes of the segment represented</span>
<span style="color: #ff7f24;">    by current node, i.e., st[index]</span>
<span style="color: #ff7f24;">    qs &amp; qe  --&gt; Starting and ending indexes of query range */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">RMQUtil</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ss</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">se</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">qs</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">qe</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">index</span>)
{ 
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">If segment of this node is a part of given range, then return</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">the min of the segment</span>
  <span style="color: #00ffff;">if</span> (qs &lt;= ss &amp;&amp; qe &gt;= se-1)
    <span style="color: #00ffff;">return</span> s.tree[index];
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">If segment of this node is outside the given range</span>
  <span style="color: #00ffff;">if</span> (se-1 &lt; qs || ss &gt; qe)
    <span style="color: #00ffff;">return</span> -1;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">If a part of this segment overlaps with the given range</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mid</span> = (ss + se)/2;
  <span style="color: #00ffff;">return</span> max(RMQUtil(ss, mid, qs, qe, 2*index),
             RMQUtil(mid, se, qs, qe, 2*index+1));
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Return minimum of elements in range from index qs (quey start) to</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">qe (query end).  It mainly uses RMQUtil()</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">RMQ</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">qs</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">qe</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Check for erroneous input values</span>
  <span style="color: #00ffff;">if</span> (qs &lt; 0 || qe &gt; n-1 || qs &gt; qe)
  {
    printf(<span style="color: #ffa07a;">"Invalid Input"</span>);
    <span style="color: #00ffff;">return</span> -1;
  }
  <span style="color: #00ffff;">return</span> RMQUtil(0, n, qs, qe, 1);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A function to move from u to v keeping track of the maximum</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">we move to the surface changing u and chains</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">until u and v donot belong to the same</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">crawl_tree</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chain_heads</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chain_u</span>, <span style="color: #eedd82;">chain_v</span> = node[v].chain, <span style="color: #eedd82;">ans</span> = 0;
  <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>)
  {
    chain_u = node[u].chain;

    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">if the two nodes belong to same chain,</span>
<span style="color: #ff7f24;">     * we can query between their positions in the array</span>
<span style="color: #ff7f24;">     * acting as base to the segment tree. After the RMQ,</span>
<span style="color: #ff7f24;">     * we can break out as we have no where further to go */</span>
    <span style="color: #00ffff;">if</span> (chain_u==chain_v)
    {
      <span style="color: #00ffff;">if</span> (u==v);   <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">trivial</span>
      <span style="color: #00ffff;">else</span>
        ans = max(RMQ(node[v].pos_segbase+1, node[u].pos_segbase, n),
                  ans);
      <span style="color: #00ffff;">break</span>;
    }

    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">else, we query between node u and head of the chain to which</span>
<span style="color: #ff7f24;">       u belongs and later change u to parent of head of the chain</span>
<span style="color: #ff7f24;">       to which u belongs indicating change of chain */</span>
    <span style="color: #00ffff;">else</span>
    {
      ans = max(ans,
                RMQ(node[chain_heads[chain_u]].pos_segbase,
                    node[u].pos_segbase, n));

      u = node[chain_heads[chain_u]].par;
    }
  }
  <span style="color: #00ffff;">return</span> ans;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">maxEdge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chain_heads</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lca</span> = LCA(u, v, n);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ans</span> = max(crawl_tree(u, lca, n, chain_heads),
                crawl_tree(v, lca, n, chain_heads));
  printf(<span style="color: #ffa07a;">"%d\n"</span>, ans);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">fill adjacency matrix with -1 to indicate no connections */</span>
  memset(tree, -1, <span style="color: #00ffff;">sizeof</span>(tree));
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 11;
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">arguments in order: Edge ID, node u, node v, weight w*/</span>
  addEdge(1, 1, 2, 13);
  addEdge(2, 1, 3, 9);
  addEdge(3, 1, 4, 23);
  addEdge(4, 2, 5, 4);
  addEdge(5, 2, 6, 25);
  addEdge(6, 3, 7, 29);
  addEdge(7, 6, 8, 5);
  addEdge(8, 7, 9, 30);
  addEdge(9, 8, 10, 1);
  addEdge(10, 8, 11, 6);

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">our tree is rooted at node 0 at depth 0 */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">root</span> = 0, <span style="color: #eedd82;">parent_of_root</span>=-1, <span style="color: #eedd82;">depth_of_root</span>=0;

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">a DFS on the tree to set up:</span>
<span style="color: #ff7f24;">   * arrays for parent, depth, subtree size for every node;</span>
<span style="color: #ff7f24;">   * deeper end of every Edge */</span>
  dfs(root, parent_of_root, depth_of_root, n);

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chain_heads</span>[N];

  <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">we have initialized no chain heads */</span>
  memset(chain_heads, -1, <span style="color: #00ffff;">sizeof</span>(chain_heads));

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Stores number of edges for construction of segment</span>
<span style="color: #ff7f24;">     tree. Initially we haven't traversed any Edges. */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">edge_counted</span> = 0;

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">we start with filling the 0th chain */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">curr_chain</span> = 0;

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">HLD of tree */</span>
  hld(root, n-1, &amp;edge_counted, &amp;curr_chain, n, chain_heads);

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">ST of segregated Edges */</span>
  construct_ST(0, edge_counted, 1);

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Since indexes are 0 based, node 11 means index 11-1,</span>
<span style="color: #ff7f24;">     8 means 8-1, and so on*/</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span> = 11, <span style="color: #eedd82;">v</span>  = 9;
  cout &lt;&lt; <span style="color: #ffa07a;">"Max edge between "</span> &lt;&lt; u &lt;&lt; <span style="color: #ffa07a;">" and "</span> &lt;&lt; v &lt;&lt; <span style="color: #ffa07a;">" is "</span>;
  maxEdge(u-1, v-1, n, chain_heads);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Change value of edge number 8 (index 8-1) to 28</span>
  change(8-1, 28, n);

  cout &lt;&lt; <span style="color: #ffa07a;">"After Change: max edge between "</span> &lt;&lt; u &lt;&lt; <span style="color: #ffa07a;">" and "</span>
       &lt;&lt; v &lt;&lt; <span style="color: #ffa07a;">" is "</span>;
  maxEdge(u-1, v-1, n, chain_heads);

  v = 4;
  cout &lt;&lt; <span style="color: #ffa07a;">"Max edge between "</span> &lt;&lt; u &lt;&lt; <span style="color: #ffa07a;">" and "</span> &lt;&lt; v &lt;&lt; <span style="color: #ffa07a;">" is "</span>;
  maxEdge(u-1, v-1, n, chain_heads);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Change value of edge number 5 (index 5-1) to 22</span>
  change(5-1, 22, n);
  cout &lt;&lt; <span style="color: #ffa07a;">"After Change: max edge between "</span> &lt;&lt; u &lt;&lt; <span style="color: #ffa07a;">" and "</span>
       &lt;&lt; v &lt;&lt; <span style="color: #ffa07a;">" is "</span>;
  maxEdge(u-1, v-1, n, chain_heads);

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">the maximum edge cost on the path from node a to node b<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup></h3>
<div class="outline-text-3" id="text-2-2">
<p>
You are given a tree (an acyclic undirected connected graph) with N
nodes, and edges numbered 1, 2, 3&#x2026;N-1.
We will ask you to perfrom some instructions of the following form:
</p>
<ul class="org-ul">
<li>CHANGE i ti : change the cost of the i-th edge to ti
</li>
<li>QUERY a b : ask for the maximum edge cost on the path from node a to
node b
</li>
</ul>
</div>

<ul class="org-ul"><li><a id="sec-2-2-1" name="sec-2-2-1"></a>solution <sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup><br  /><div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>DFS the whole tree to get tree info(depth, subsize, etc.)
</li>
<li>construct a Segment tree using all nodes
</li>
<li>A LCA algorithm: use dynamic programming idea store the prev node
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">root</span> 0
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">N</span> 10100
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">LN</span> 14

<span style="color: #98fb98;">vector</span> &lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">adj</span>[N], <span style="color: #eedd82;">costs</span>[N], <span style="color: #eedd82;">indexx</span>[N];
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">baseArray</span>[N], <span style="color: #eedd82;">ptr</span>;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chainNo</span>, <span style="color: #eedd82;">chainInd</span>[N], <span style="color: #eedd82;">chainHead</span>[N], <span style="color: #eedd82;">posInBase</span>[N];
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">depth</span>[N], <span style="color: #eedd82;">pa</span>[LN][N], <span style="color: #eedd82;">otherEnd</span>[N], <span style="color: #eedd82;">subsize</span>[N];
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">st</span>[N*6], <span style="color: #eedd82;">qt</span>[N*6];

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * make_tree:</span>
<span style="color: #ff7f24;"> * Used to construct the segment tree. It uses the baseArray for construction</span>
<span style="color: #ff7f24;"> */</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">make_tree</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cur</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">e</span>) {
        <span style="color: #00ffff;">if</span>(s == e-1) {
                st[cur] = baseArray[s];
                <span style="color: #00ffff;">return</span>;
        }
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c1</span> = (cur&lt;&lt;1), <span style="color: #eedd82;">c2</span> = c1 | 1, <span style="color: #eedd82;">m</span> = (s+e)&gt;&gt;1;
        make_tree(c1, s, m);
        make_tree(c2, m, e);
        st[cur] = st[c1] &gt; st[c2] ? st[c1] : st[c2];
}

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * update_tree:</span>
<span style="color: #ff7f24;"> * Point update. Update a single element of the segment tree.</span>
<span style="color: #ff7f24;"> */</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">update_tree</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cur</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">e</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">val</span>) {
        <span style="color: #00ffff;">if</span>(s &gt; x || e &lt;= x) <span style="color: #00ffff;">return</span>;
        <span style="color: #00ffff;">if</span>(s == x &amp;&amp; s == e-1) {
                st[cur] = val;
                <span style="color: #00ffff;">return</span>;
        }
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c1</span> = (cur&lt;&lt;1), <span style="color: #eedd82;">c2</span> = c1 | 1, <span style="color: #eedd82;">m</span> = (s+e)&gt;&gt;1;
        update_tree(c1, s, m, x, val);
        update_tree(c2, m, e, x, val);
        st[cur] = st[c1] &gt; st[c2] ? st[c1] : st[c2];
}

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * query_tree:</span>
<span style="color: #ff7f24;"> * Given S and E, it will return the maximum value in the range [S,E)</span>
<span style="color: #ff7f24;"> */</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">query_tree</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cur</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">e</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">S</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">E</span>) {
        <span style="color: #00ffff;">if</span>(s &gt;= E || e &lt;= S) {
                qt[cur] = -1;
                <span style="color: #00ffff;">return</span>;
        }
        <span style="color: #00ffff;">if</span>(s &gt;= S &amp;&amp; e &lt;= E) {
                qt[cur] = st[cur];
                <span style="color: #00ffff;">return</span>;
        }
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c1</span> = (cur&lt;&lt;1), <span style="color: #eedd82;">c2</span> = c1 | 1, <span style="color: #eedd82;">m</span> = (s+e)&gt;&gt;1;
        query_tree(c1, s, m, S, E);
        query_tree(c2, m, e, S, E);
        qt[cur] = qt[c1] &gt; qt[c2] ? qt[c1] : qt[c2];
}

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * query_up:</span>
<span style="color: #ff7f24;"> * It takes two nodes u and v, condition is that v is an ancestor of u</span>
<span style="color: #ff7f24;"> * We query the chain in which u is present till chain head, then move to next chain up</span>
<span style="color: #ff7f24;"> * We do that way till u and v are in the same chain, we query for that part of chain and break</span>
<span style="color: #ff7f24;"> */</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">query_up</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>) {
        <span style="color: #00ffff;">if</span>(u == v) <span style="color: #00ffff;">return</span> 0; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Trivial</span>
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">uchain</span>, <span style="color: #eedd82;">vchain</span> = chainInd[v], <span style="color: #eedd82;">ans</span> = -1;
        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">uchain and vchain are chain numbers of u and v</span>
        <span style="color: #00ffff;">while</span>(1) {
                uchain = chainInd[u];
                <span style="color: #00ffff;">if</span>(uchain == vchain) {
                        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Both u and v are in the same chain, so we need to query from u to v, update answer and break.</span>
                        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">We break because we came from u up till v, we are done</span>
                        <span style="color: #00ffff;">if</span>(u==v) <span style="color: #00ffff;">break</span>;
                        query_tree(1, 0, ptr, posInBase[v]+1, posInBase[u]+1);
                        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Above is call to segment tree query function</span>
                        <span style="color: #00ffff;">if</span>(qt[1] &gt; ans) ans = qt[1]; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Update answer</span>
                        <span style="color: #00ffff;">break</span>;
                }
                query_tree(1, 0, ptr, posInBase[chainHead[uchain]], posInBase[u]+1);
                <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Above is call to segment tree query function. We do from chainHead of u till u. That is the whole chain from</span>
                <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">start till head. We then update the answer</span>
                <span style="color: #00ffff;">if</span>(qt[1] &gt; ans) ans = qt[1];
                u = chainHead[uchain]; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">move u to u's chainHead</span>
                u = pa[0][u]; <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">Then move to its parent, that means we changed chains</span>
        }
        <span style="color: #00ffff;">return</span> ans;
}

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * LCA:</span>
<span style="color: #ff7f24;"> * Takes two nodes u, v and returns Lowest Common Ancestor of u, v</span>
<span style="color: #ff7f24;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">LCA</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>) {
        <span style="color: #00ffff;">if</span>(depth[u] &lt; depth[v]) swap(u,v);
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">diff</span> = depth[u] - depth[v];
        <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>=0; i&lt;LN; i++) <span style="color: #00ffff;">if</span>( (diff&gt;&gt;i)&amp;1 ) u = pa[i][u];
        <span style="color: #00ffff;">if</span>(u == v) <span style="color: #00ffff;">return</span> u;
        <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>=LN-1; i&gt;=0; i--) <span style="color: #00ffff;">if</span>(pa[i][u] != pa[i][v]) {
                u = pa[i][u];
                v = pa[i][v];
        }
        <span style="color: #00ffff;">return</span> pa[0][u];
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">query</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>) {
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * We have a query from u to v, we break it into two queries, u to LCA(u,v) and LCA(u,v) to v</span>
<span style="color: #ff7f24;">         */</span>
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lca</span> = LCA(u, v);
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ans</span> = query_up(u, lca); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">One part of path</span>
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span> = query_up(v, lca); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">another part of path</span>
        <span style="color: #00ffff;">if</span>(temp &gt; ans) ans = temp; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">take the maximum of both paths</span>
        printf(<span style="color: #ffa07a;">"%d\n"</span>, ans);
}

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * change:</span>
<span style="color: #ff7f24;"> * We just need to find its position in segment tree and update it</span>
<span style="color: #ff7f24;"> */</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">change</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">val</span>) {
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span> = otherEnd[i];
        update_tree(1, 0, ptr, posInBase[u], val);
}

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * Actual HL-Decomposition part</span>
<span style="color: #ff7f24;"> * Initially all entries of chainHead[] are set to -1.</span>
<span style="color: #ff7f24;"> * So when ever a new chain is started, chain head is correctly assigned.</span>
<span style="color: #ff7f24;"> * As we add a new node to chain, we will note its position in the baseArray.</span>
<span style="color: #ff7f24;"> * In the first for loop we find the child node which has maximum sub-tree size.</span>
<span style="color: #ff7f24;"> * The following if condition is failed for leaf nodes.</span>
<span style="color: #ff7f24;"> * When the if condition passes, we expand the chain to special child.</span>
<span style="color: #ff7f24;"> * In the second for loop we recursively call the function on all normal nodes.</span>
<span style="color: #ff7f24;"> * chainNo++ ensures that we are creating a new chain for each normal child.</span>
<span style="color: #ff7f24;"> */</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">HLD</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">curNode</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cost</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">prev</span>) {
        <span style="color: #00ffff;">if</span>(chainHead[chainNo] == -1) {
                chainHead[chainNo] = curNode; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Assign chain head</span>
        }
        chainInd[curNode] = chainNo;
        posInBase[curNode] = ptr; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Position of this node in baseArray which we will use in Segtree</span>
        baseArray[ptr++] = cost;

        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sc</span> = -1, <span style="color: #eedd82;">ncost</span>;
        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Loop to find special child</span>
        <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>=0; i&lt;adj[curNode].size(); i++) <span style="color: #00ffff;">if</span>(adj[curNode][i] != prev) {
                <span style="color: #00ffff;">if</span>(sc == -1 || subsize[sc] &lt; subsize[adj[curNode][i]]) {
                        sc = adj[curNode][i];
                        ncost = costs[curNode][i];
                }
        }

        <span style="color: #00ffff;">if</span>(sc != -1) {
                <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Expand the chain</span>
                HLD(sc, ncost, curNode);
        }

        <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>=0; i&lt;adj[curNode].size(); i++) <span style="color: #00ffff;">if</span>(adj[curNode][i] != prev) {
                <span style="color: #00ffff;">if</span>(sc != adj[curNode][i]) {
                        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">New chains at each normal node</span>
                        chainNo++;
                        HLD(adj[curNode][i], costs[curNode][i], curNode);
                }
        }
}

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * dfs used to set parent of a node, depth of a node, subtree size of a node</span>
<span style="color: #ff7f24;"> */</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dfs</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cur</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">prev</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">_depth</span>=0) {
        pa[0][cur] = prev;
        depth[cur] = _depth;
        subsize[cur] = 1;
        <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>=0; i&lt;adj[cur].size(); i++)
                <span style="color: #00ffff;">if</span>(adj[cur][i] != prev) {
                        otherEnd[indexx[cur][i]] = adj[cur][i];
                        dfs(adj[cur][i], cur, _depth+1);
                        subsize[cur] += subsize[adj[cur][i]];
                }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>;
        scanf(<span style="color: #ffa07a;">"%d "</span>, &amp;t);
        <span style="color: #00ffff;">while</span>(t--) {
                ptr = 0;
                <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>;
                scanf(<span style="color: #ffa07a;">"%d"</span>, &amp;n);
                <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Cleaning step, new test case</span>
                <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>=0; i&lt;n; i++) {
                        adj[i].clear();
                        costs[i].clear();
                        indexx[i].clear();
                        chainHead[i] = -1;
                        <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span>=0; j&lt;LN; j++) pa[j][i] = -1;
                }
                <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>=1; i&lt;n; i++) {
                        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #eedd82;">v</span>, <span style="color: #eedd82;">c</span>;
                        scanf(<span style="color: #ffa07a;">"%d %d %d"</span>, &amp;u, &amp;v, &amp;c);
                        u--; v--;
                        adj[u].push_back(v);
                        costs[u].push_back(c);
                        indexx[u].push_back(i-1);
                        adj[v].push_back(u);
                        costs[v].push_back(c);
                        indexx[v].push_back(i-1);
                }

                chainNo = 0;
                dfs(root, -1); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">We set up subsize, depth and parent for each node</span>
                HLD(root, -1, -1); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">We decomposed the tree and created baseArray</span>
                make_tree(1, 0, ptr); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">We use baseArray and construct the needed segment tree</span>

                <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Below Dynamic programming code is for LCA.</span>
                <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>=1; i&lt;LN; i++)
                        <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span>=0; j&lt;n; j++)
                                <span style="color: #00ffff;">if</span>(pa[i-1][j] != -1)
                                        pa[i][j] = pa[i-1][pa[i-1][j]];

                <span style="color: #00ffff;">while</span>(1) {
                        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[100];
                        scanf(<span style="color: #ffa07a;">"%s"</span>, s);
                        <span style="color: #00ffff;">if</span>(s[0]==<span style="color: #ffa07a;">'D'</span>) {
                                <span style="color: #00ffff;">break</span>;
                        }
                        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #eedd82;">b</span>;
                        scanf(<span style="color: #ffa07a;">"%d %d"</span>, &amp;a, &amp;b);
                        <span style="color: #00ffff;">if</span>(s[0]==<span style="color: #ffa07a;">'Q'</span>) {
                                query(a-1, b-1);
                        } <span style="color: #00ffff;">else</span> {
                                change(a-1, b);
                        }
                }
        }
}
</pre>
</div>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">More</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li><a href="http://www.geeksforgeeks.org/heavy-light-decomposition-set-1-introduction/">Introduction</a> and <a href="http://www.geeksforgeeks.org/heavy-light-decomposition-set-2-implementation/">implementation</a> by geeksforgeeks
</li>
<li>Description and application: <a href="http://e-maxx.ru/algo/heavy_light">http://e-maxx.ru/algo/heavy_light</a>
</li>
<li>Heavy Light Decomposition Description and application:
<a href="https://blog.anudeep2011.com/heavy-light-decomposition/">https://blog.anudeep2011.com/heavy-light-decomposition/</a>
</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://wcipeg.com/wiki/Heavy-light_decomposition">http://wcipeg.com/wiki/Heavy-light_decomposition</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="http://www.geeksforgeeks.org/heavy-light-decomposition-set-2-implementation/">http://www.geeksforgeeks.org/heavy-light-decomposition-set-2-implementation/</a>
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
<a href="http://www.spoj.com/problems/QTREE/">http://www.spoj.com/problems/QTREE/</a>
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
<a href="https://blog.anudeep2011.com/heavy-light-decomposition">https://blog.anudeep2011.com/heavy-light-decomposition</a>
</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2016-11-19 Sat 22:47</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
